/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/diff-match-patch/index.js
var require_diff_match_patch = __commonJS({
  "node_modules/diff-match-patch/index.js"(exports, module2) {
    var diff_match_patch3 = function() {
      this.Diff_Timeout = 1;
      this.Diff_EditCost = 4;
      this.Match_Threshold = 0.5;
      this.Match_Distance = 1e3;
      this.Patch_DeleteThreshold = 0.5;
      this.Patch_Margin = 4;
      this.Match_MaxBits = 32;
    };
    var DIFF_DELETE3 = -1;
    var DIFF_INSERT3 = 1;
    var DIFF_EQUAL3 = 0;
    diff_match_patch3.Diff = function(op, text2) {
      return [op, text2];
    };
    diff_match_patch3.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
      if (typeof opt_deadline == "undefined") {
        if (this.Diff_Timeout <= 0) {
          opt_deadline = Number.MAX_VALUE;
        } else {
          opt_deadline = new Date().getTime() + this.Diff_Timeout * 1e3;
        }
      }
      var deadline = opt_deadline;
      if (text1 == null || text2 == null) {
        throw new Error("Null input. (diff_main)");
      }
      if (text1 == text2) {
        if (text1) {
          return [new diff_match_patch3.Diff(DIFF_EQUAL3, text1)];
        }
        return [];
      }
      if (typeof opt_checklines == "undefined") {
        opt_checklines = true;
      }
      var checklines = opt_checklines;
      var commonlength = this.diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = this.diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = this.diff_compute_(text1, text2, checklines, deadline);
      if (commonprefix) {
        diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL3, commonprefix));
      }
      if (commonsuffix) {
        diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, commonsuffix));
      }
      this.diff_cleanupMerge(diffs);
      return diffs;
    };
    diff_match_patch3.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
      var diffs;
      if (!text1) {
        return [new diff_match_patch3.Diff(DIFF_INSERT3, text2)];
      }
      if (!text2) {
        return [new diff_match_patch3.Diff(DIFF_DELETE3, text1)];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i != -1) {
        diffs = [
          new diff_match_patch3.Diff(DIFF_INSERT3, longtext.substring(0, i)),
          new diff_match_patch3.Diff(DIFF_EQUAL3, shorttext),
          new diff_match_patch3.Diff(DIFF_INSERT3, longtext.substring(i + shorttext.length))
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE3;
        }
        return diffs;
      }
      if (shorttext.length == 1) {
        return [
          new diff_match_patch3.Diff(DIFF_DELETE3, text1),
          new diff_match_patch3.Diff(DIFF_INSERT3, text2)
        ];
      }
      var hm = this.diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
        return diffs_a.concat([new diff_match_patch3.Diff(DIFF_EQUAL3, mid_common)], diffs_b);
      }
      if (checklines && text1.length > 100 && text2.length > 100) {
        return this.diff_lineMode_(text1, text2, deadline);
      }
      return this.diff_bisect_(text1, text2, deadline);
    };
    diff_match_patch3.prototype.diff_lineMode_ = function(text1, text2, deadline) {
      var a = this.diff_linesToChars_(text1, text2);
      text1 = a.chars1;
      text2 = a.chars2;
      var linearray = a.lineArray;
      var diffs = this.diff_main(text1, text2, false, deadline);
      this.diff_charsToLines_(diffs, linearray);
      this.diff_cleanupSemantic(diffs);
      diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT3:
            count_insert++;
            text_insert += diffs[pointer][1];
            break;
          case DIFF_DELETE3:
            count_delete++;
            text_delete += diffs[pointer][1];
            break;
          case DIFF_EQUAL3:
            if (count_delete >= 1 && count_insert >= 1) {
              diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
              pointer = pointer - count_delete - count_insert;
              var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
              for (var j = subDiff.length - 1; j >= 0; j--) {
                diffs.splice(pointer, 0, subDiff[j]);
              }
              pointer = pointer + subDiff.length;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
        pointer++;
      }
      diffs.pop();
      return diffs;
    };
    diff_match_patch3.prototype.diff_bisect_ = function(text1, text2, deadline) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 != 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        if (new Date().getTime() > deadline) {
          break;
        }
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
      }
      return [
        new diff_match_patch3.Diff(DIFF_DELETE3, text1),
        new diff_match_patch3.Diff(DIFF_INSERT3, text2)
      ];
    };
    diff_match_patch3.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = this.diff_main(text1a, text2a, false, deadline);
      var diffsb = this.diff_main(text1b, text2b, false, deadline);
      return diffs.concat(diffsb);
    };
    diff_match_patch3.prototype.diff_linesToChars_ = function(text1, text2) {
      var lineArray = [];
      var lineHash = {};
      lineArray[0] = "";
      function diff_linesToCharsMunge_(text3) {
        var chars = "";
        var lineStart = 0;
        var lineEnd = -1;
        var lineArrayLength = lineArray.length;
        while (lineEnd < text3.length - 1) {
          lineEnd = text3.indexOf("\n", lineStart);
          if (lineEnd == -1) {
            lineEnd = text3.length - 1;
          }
          var line = text3.substring(lineStart, lineEnd + 1);
          if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
            chars += String.fromCharCode(lineHash[line]);
          } else {
            if (lineArrayLength == maxLines) {
              line = text3.substring(lineStart);
              lineEnd = text3.length;
            }
            chars += String.fromCharCode(lineArrayLength);
            lineHash[line] = lineArrayLength;
            lineArray[lineArrayLength++] = line;
          }
          lineStart = lineEnd + 1;
        }
        return chars;
      }
      var maxLines = 4e4;
      var chars1 = diff_linesToCharsMunge_(text1);
      maxLines = 65535;
      var chars2 = diff_linesToCharsMunge_(text2);
      return { chars1, chars2, lineArray };
    };
    diff_match_patch3.prototype.diff_charsToLines_ = function(diffs, lineArray) {
      for (var i = 0; i < diffs.length; i++) {
        var chars = diffs[i][1];
        var text2 = [];
        for (var j = 0; j < chars.length; j++) {
          text2[j] = lineArray[chars.charCodeAt(j)];
        }
        diffs[i][1] = text2.join("");
      }
    };
    diff_match_patch3.prototype.diff_commonPrefix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch3.prototype.diff_commonSuffix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch3.prototype.diff_commonOverlap_ = function(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    };
    diff_match_patch3.prototype.diff_halfMatch_ = function(text1, text2) {
      if (this.Diff_Timeout <= 0) {
        return null;
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      var dmp = this;
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
          var prefixLength = dmp.diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
          var suffixLength = dmp.diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    };
    diff_match_patch3.prototype.diff_cleanupSemantic = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL3) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT3) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch3.Diff(DIFF_DELETE3, lastEquality));
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT3;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
      this.diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE3 && diffs[pointer][0] == DIFF_INSERT3) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch3.Diff(DIFF_EQUAL3, insertion.substring(0, overlap_length1)));
              diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch3.Diff(DIFF_EQUAL3, deletion.substring(0, overlap_length2)));
              diffs[pointer - 1][0] = DIFF_INSERT3;
              diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
              diffs[pointer + 1][0] = DIFF_DELETE3;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    };
    diff_match_patch3.prototype.diff_cleanupSemanticLossless = function(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(diff_match_patch3.nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(diff_match_patch3.nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch3.whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch3.whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(diff_match_patch3.linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(diff_match_patch3.linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(diff_match_patch3.blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(diff_match_patch3.blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL3 && diffs[pointer + 1][0] == DIFF_EQUAL3) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = this.diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    };
    diff_match_patch3.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    diff_match_patch3.whitespaceRegex_ = /\s/;
    diff_match_patch3.linebreakRegex_ = /[\r\n]/;
    diff_match_patch3.blanklineEndRegex_ = /\n\r?\n$/;
    diff_match_patch3.blanklineStartRegex_ = /^\r?\n\r?\n/;
    diff_match_patch3.prototype.diff_cleanupEfficiency = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var pre_ins = false;
      var pre_del = false;
      var post_ins = false;
      var post_del = false;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL3) {
          if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
            equalities[equalitiesLength++] = pointer;
            pre_ins = post_ins;
            pre_del = post_del;
            lastEquality = diffs[pointer][1];
          } else {
            equalitiesLength = 0;
            lastEquality = null;
          }
          post_ins = post_del = false;
        } else {
          if (diffs[pointer][0] == DIFF_DELETE3) {
            post_del = true;
          } else {
            post_ins = true;
          }
          if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch3.Diff(DIFF_DELETE3, lastEquality));
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT3;
            equalitiesLength--;
            lastEquality = null;
            if (pre_ins && pre_del) {
              post_ins = post_del = true;
              equalitiesLength = 0;
            } else {
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              post_ins = post_del = false;
            }
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch3.prototype.diff_cleanupMerge = function(diffs) {
      diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT3:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE3:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL3:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = this.diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL3) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, new diff_match_patch3.Diff(DIFF_EQUAL3, text_insert.substring(0, commonlength)));
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = this.diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              pointer -= count_delete + count_insert;
              diffs.splice(pointer, count_delete + count_insert);
              if (text_delete.length) {
                diffs.splice(pointer, 0, new diff_match_patch3.Diff(DIFF_DELETE3, text_delete));
                pointer++;
              }
              if (text_insert.length) {
                diffs.splice(pointer, 0, new diff_match_patch3.Diff(DIFF_INSERT3, text_insert));
                pointer++;
              }
              pointer++;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL3) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL3 && diffs[pointer + 1][0] == DIFF_EQUAL3) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch3.prototype.diff_xIndex = function(diffs, loc) {
      var chars1 = 0;
      var chars2 = 0;
      var last_chars1 = 0;
      var last_chars2 = 0;
      var x;
      for (x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT3) {
          chars1 += diffs[x][1].length;
        }
        if (diffs[x][0] !== DIFF_DELETE3) {
          chars2 += diffs[x][1].length;
        }
        if (chars1 > loc) {
          break;
        }
        last_chars1 = chars1;
        last_chars2 = chars2;
      }
      if (diffs.length != x && diffs[x][0] === DIFF_DELETE3) {
        return last_chars2;
      }
      return last_chars2 + (loc - last_chars1);
    };
    diff_match_patch3.prototype.diff_prettyHtml = function(diffs) {
      var html = [];
      var pattern_amp = /&/g;
      var pattern_lt = /</g;
      var pattern_gt = />/g;
      var pattern_para = /\n/g;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        var text2 = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
        switch (op) {
          case DIFF_INSERT3:
            html[x] = '<ins style="background:#e6ffe6;">' + text2 + "</ins>";
            break;
          case DIFF_DELETE3:
            html[x] = '<del style="background:#ffe6e6;">' + text2 + "</del>";
            break;
          case DIFF_EQUAL3:
            html[x] = "<span>" + text2 + "</span>";
            break;
        }
      }
      return html.join("");
    };
    diff_match_patch3.prototype.diff_text1 = function(diffs) {
      var text2 = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT3) {
          text2[x] = diffs[x][1];
        }
      }
      return text2.join("");
    };
    diff_match_patch3.prototype.diff_text2 = function(diffs) {
      var text2 = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_DELETE3) {
          text2[x] = diffs[x][1];
        }
      }
      return text2.join("");
    };
    diff_match_patch3.prototype.diff_levenshtein = function(diffs) {
      var levenshtein = 0;
      var insertions = 0;
      var deletions = 0;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        switch (op) {
          case DIFF_INSERT3:
            insertions += data.length;
            break;
          case DIFF_DELETE3:
            deletions += data.length;
            break;
          case DIFF_EQUAL3:
            levenshtein += Math.max(insertions, deletions);
            insertions = 0;
            deletions = 0;
            break;
        }
      }
      levenshtein += Math.max(insertions, deletions);
      return levenshtein;
    };
    diff_match_patch3.prototype.diff_toDelta = function(diffs) {
      var text2 = [];
      for (var x = 0; x < diffs.length; x++) {
        switch (diffs[x][0]) {
          case DIFF_INSERT3:
            text2[x] = "+" + encodeURI(diffs[x][1]);
            break;
          case DIFF_DELETE3:
            text2[x] = "-" + diffs[x][1].length;
            break;
          case DIFF_EQUAL3:
            text2[x] = "=" + diffs[x][1].length;
            break;
        }
      }
      return text2.join("	").replace(/%20/g, " ");
    };
    diff_match_patch3.prototype.diff_fromDelta = function(text1, delta) {
      var diffs = [];
      var diffsLength = 0;
      var pointer = 0;
      var tokens = delta.split(/\t/g);
      for (var x = 0; x < tokens.length; x++) {
        var param = tokens[x].substring(1);
        switch (tokens[x].charAt(0)) {
          case "+":
            try {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_INSERT3, decodeURI(param));
            } catch (ex) {
              throw new Error("Illegal escape in diff_fromDelta: " + param);
            }
            break;
          case "-":
          case "=":
            var n3 = parseInt(param, 10);
            if (isNaN(n3) || n3 < 0) {
              throw new Error("Invalid number in diff_fromDelta: " + param);
            }
            var text2 = text1.substring(pointer, pointer += n3);
            if (tokens[x].charAt(0) == "=") {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_EQUAL3, text2);
            } else {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_DELETE3, text2);
            }
            break;
          default:
            if (tokens[x]) {
              throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
            }
        }
      }
      if (pointer != text1.length) {
        throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
      }
      return diffs;
    };
    diff_match_patch3.prototype.match_main = function(text2, pattern, loc) {
      if (text2 == null || pattern == null || loc == null) {
        throw new Error("Null input. (match_main)");
      }
      loc = Math.max(0, Math.min(loc, text2.length));
      if (text2 == pattern) {
        return 0;
      } else if (!text2.length) {
        return -1;
      } else if (text2.substring(loc, loc + pattern.length) == pattern) {
        return loc;
      } else {
        return this.match_bitap_(text2, pattern, loc);
      }
    };
    diff_match_patch3.prototype.match_bitap_ = function(text2, pattern, loc) {
      if (pattern.length > this.Match_MaxBits) {
        throw new Error("Pattern too long for this browser.");
      }
      var s = this.match_alphabet_(pattern);
      var dmp = this;
      function match_bitapScore_(e3, x) {
        var accuracy = e3 / pattern.length;
        var proximity = Math.abs(loc - x);
        if (!dmp.Match_Distance) {
          return proximity ? 1 : accuracy;
        }
        return accuracy + proximity / dmp.Match_Distance;
      }
      var score_threshold = this.Match_Threshold;
      var best_loc = text2.indexOf(pattern, loc);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        best_loc = text2.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1) {
          score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        }
      }
      var matchmask = 1 << pattern.length - 1;
      best_loc = -1;
      var bin_min, bin_mid;
      var bin_max = pattern.length + text2.length;
      var last_rd;
      for (var d = 0; d < pattern.length; d++) {
        bin_min = 0;
        bin_mid = bin_max;
        while (bin_min < bin_mid) {
          if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
            bin_min = bin_mid;
          } else {
            bin_max = bin_mid;
          }
          bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
        }
        bin_max = bin_mid;
        var start = Math.max(1, loc - bin_mid + 1);
        var finish = Math.min(loc + bin_mid, text2.length) + pattern.length;
        var rd = Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for (var j = finish; j >= start; j--) {
          var charMatch = s[text2.charAt(j - 1)];
          if (d === 0) {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
          } else {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
          }
          if (rd[j] & matchmask) {
            var score = match_bitapScore_(d, j - 1);
            if (score <= score_threshold) {
              score_threshold = score;
              best_loc = j - 1;
              if (best_loc > loc) {
                start = Math.max(1, 2 * loc - best_loc);
              } else {
                break;
              }
            }
          }
        }
        if (match_bitapScore_(d + 1, loc) > score_threshold) {
          break;
        }
        last_rd = rd;
      }
      return best_loc;
    };
    diff_match_patch3.prototype.match_alphabet_ = function(pattern) {
      var s = {};
      for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] = 0;
      }
      for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
      }
      return s;
    };
    diff_match_patch3.prototype.patch_addContext_ = function(patch, text2) {
      if (text2.length == 0) {
        return;
      }
      if (patch.start2 === null) {
        throw Error("patch not initialized");
      }
      var pattern = text2.substring(patch.start2, patch.start2 + patch.length1);
      var padding = 0;
      while (text2.indexOf(pattern) != text2.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
        padding += this.Patch_Margin;
        pattern = text2.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
      }
      padding += this.Patch_Margin;
      var prefix = text2.substring(patch.start2 - padding, patch.start2);
      if (prefix) {
        patch.diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL3, prefix));
      }
      var suffix = text2.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);
      if (suffix) {
        patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, suffix));
      }
      patch.start1 -= prefix.length;
      patch.start2 -= prefix.length;
      patch.length1 += prefix.length + suffix.length;
      patch.length2 += prefix.length + suffix.length;
    };
    diff_match_patch3.prototype.patch_make = function(a, opt_b, opt_c) {
      var text1, diffs;
      if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
        text1 = a;
        diffs = this.diff_main(text1, opt_b, true);
        if (diffs.length > 2) {
          this.diff_cleanupSemantic(diffs);
          this.diff_cleanupEfficiency(diffs);
        }
      } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
        diffs = a;
        text1 = this.diff_text1(diffs);
      } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
        text1 = a;
        diffs = opt_b;
      } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
        text1 = a;
        diffs = opt_c;
      } else {
        throw new Error("Unknown call format to patch_make.");
      }
      if (diffs.length === 0) {
        return [];
      }
      var patches = [];
      var patch = new diff_match_patch3.patch_obj();
      var patchDiffLength = 0;
      var char_count1 = 0;
      var char_count2 = 0;
      var prepatch_text = text1;
      var postpatch_text = text1;
      for (var x = 0; x < diffs.length; x++) {
        var diff_type = diffs[x][0];
        var diff_text = diffs[x][1];
        if (!patchDiffLength && diff_type !== DIFF_EQUAL3) {
          patch.start1 = char_count1;
          patch.start2 = char_count2;
        }
        switch (diff_type) {
          case DIFF_INSERT3:
            patch.diffs[patchDiffLength++] = diffs[x];
            patch.length2 += diff_text.length;
            postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
            break;
          case DIFF_DELETE3:
            patch.length1 += diff_text.length;
            patch.diffs[patchDiffLength++] = diffs[x];
            postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
            break;
          case DIFF_EQUAL3:
            if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
              patch.diffs[patchDiffLength++] = diffs[x];
              patch.length1 += diff_text.length;
              patch.length2 += diff_text.length;
            } else if (diff_text.length >= 2 * this.Patch_Margin) {
              if (patchDiffLength) {
                this.patch_addContext_(patch, prepatch_text);
                patches.push(patch);
                patch = new diff_match_patch3.patch_obj();
                patchDiffLength = 0;
                prepatch_text = postpatch_text;
                char_count1 = char_count2;
              }
            }
            break;
        }
        if (diff_type !== DIFF_INSERT3) {
          char_count1 += diff_text.length;
        }
        if (diff_type !== DIFF_DELETE3) {
          char_count2 += diff_text.length;
        }
      }
      if (patchDiffLength) {
        this.patch_addContext_(patch, prepatch_text);
        patches.push(patch);
      }
      return patches;
    };
    diff_match_patch3.prototype.patch_deepCopy = function(patches) {
      var patchesCopy = [];
      for (var x = 0; x < patches.length; x++) {
        var patch = patches[x];
        var patchCopy = new diff_match_patch3.patch_obj();
        patchCopy.diffs = [];
        for (var y = 0; y < patch.diffs.length; y++) {
          patchCopy.diffs[y] = new diff_match_patch3.Diff(patch.diffs[y][0], patch.diffs[y][1]);
        }
        patchCopy.start1 = patch.start1;
        patchCopy.start2 = patch.start2;
        patchCopy.length1 = patch.length1;
        patchCopy.length2 = patch.length2;
        patchesCopy[x] = patchCopy;
      }
      return patchesCopy;
    };
    diff_match_patch3.prototype.patch_apply = function(patches, text2) {
      if (patches.length == 0) {
        return [text2, []];
      }
      patches = this.patch_deepCopy(patches);
      var nullPadding = this.patch_addPadding(patches);
      text2 = nullPadding + text2 + nullPadding;
      this.patch_splitMax(patches);
      var delta = 0;
      var results = [];
      for (var x = 0; x < patches.length; x++) {
        var expected_loc = patches[x].start2 + delta;
        var text1 = this.diff_text1(patches[x].diffs);
        var start_loc;
        var end_loc = -1;
        if (text1.length > this.Match_MaxBits) {
          start_loc = this.match_main(text2, text1.substring(0, this.Match_MaxBits), expected_loc);
          if (start_loc != -1) {
            end_loc = this.match_main(text2, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);
            if (end_loc == -1 || start_loc >= end_loc) {
              start_loc = -1;
            }
          }
        } else {
          start_loc = this.match_main(text2, text1, expected_loc);
        }
        if (start_loc == -1) {
          results[x] = false;
          delta -= patches[x].length2 - patches[x].length1;
        } else {
          results[x] = true;
          delta = start_loc - expected_loc;
          var text22;
          if (end_loc == -1) {
            text22 = text2.substring(start_loc, start_loc + text1.length);
          } else {
            text22 = text2.substring(start_loc, end_loc + this.Match_MaxBits);
          }
          if (text1 == text22) {
            text2 = text2.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text2.substring(start_loc + text1.length);
          } else {
            var diffs = this.diff_main(text1, text22, false);
            if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
              results[x] = false;
            } else {
              this.diff_cleanupSemanticLossless(diffs);
              var index1 = 0;
              var index2;
              for (var y = 0; y < patches[x].diffs.length; y++) {
                var mod = patches[x].diffs[y];
                if (mod[0] !== DIFF_EQUAL3) {
                  index2 = this.diff_xIndex(diffs, index1);
                }
                if (mod[0] === DIFF_INSERT3) {
                  text2 = text2.substring(0, start_loc + index2) + mod[1] + text2.substring(start_loc + index2);
                } else if (mod[0] === DIFF_DELETE3) {
                  text2 = text2.substring(0, start_loc + index2) + text2.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));
                }
                if (mod[0] !== DIFF_DELETE3) {
                  index1 += mod[1].length;
                }
              }
            }
          }
        }
      }
      text2 = text2.substring(nullPadding.length, text2.length - nullPadding.length);
      return [text2, results];
    };
    diff_match_patch3.prototype.patch_addPadding = function(patches) {
      var paddingLength = this.Patch_Margin;
      var nullPadding = "";
      for (var x = 1; x <= paddingLength; x++) {
        nullPadding += String.fromCharCode(x);
      }
      for (var x = 0; x < patches.length; x++) {
        patches[x].start1 += paddingLength;
        patches[x].start2 += paddingLength;
      }
      var patch = patches[0];
      var diffs = patch.diffs;
      if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL3) {
        diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL3, nullPadding));
        patch.start1 -= paddingLength;
        patch.start2 -= paddingLength;
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[0][1].length) {
        var extraLength = paddingLength - diffs[0][1].length;
        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
        patch.start1 -= extraLength;
        patch.start2 -= extraLength;
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      patch = patches[patches.length - 1];
      diffs = patch.diffs;
      if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL3) {
        diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, nullPadding));
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[diffs.length - 1][1].length) {
        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      return nullPadding;
    };
    diff_match_patch3.prototype.patch_splitMax = function(patches) {
      var patch_size = this.Match_MaxBits;
      for (var x = 0; x < patches.length; x++) {
        if (patches[x].length1 <= patch_size) {
          continue;
        }
        var bigpatch = patches[x];
        patches.splice(x--, 1);
        var start1 = bigpatch.start1;
        var start2 = bigpatch.start2;
        var precontext = "";
        while (bigpatch.diffs.length !== 0) {
          var patch = new diff_match_patch3.patch_obj();
          var empty2 = true;
          patch.start1 = start1 - precontext.length;
          patch.start2 = start2 - precontext.length;
          if (precontext !== "") {
            patch.length1 = patch.length2 = precontext.length;
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, precontext));
          }
          while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
            var diff_type = bigpatch.diffs[0][0];
            var diff_text = bigpatch.diffs[0][1];
            if (diff_type === DIFF_INSERT3) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
              patch.diffs.push(bigpatch.diffs.shift());
              empty2 = false;
            } else if (diff_type === DIFF_DELETE3 && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL3 && diff_text.length > 2 * patch_size) {
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              empty2 = false;
              patch.diffs.push(new diff_match_patch3.Diff(diff_type, diff_text));
              bigpatch.diffs.shift();
            } else {
              diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              if (diff_type === DIFF_EQUAL3) {
                patch.length2 += diff_text.length;
                start2 += diff_text.length;
              } else {
                empty2 = false;
              }
              patch.diffs.push(new diff_match_patch3.Diff(diff_type, diff_text));
              if (diff_text == bigpatch.diffs[0][1]) {
                bigpatch.diffs.shift();
              } else {
                bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
              }
            }
          }
          precontext = this.diff_text2(patch.diffs);
          precontext = precontext.substring(precontext.length - this.Patch_Margin);
          var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
          if (postcontext !== "") {
            patch.length1 += postcontext.length;
            patch.length2 += postcontext.length;
            if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL3) {
              patch.diffs[patch.diffs.length - 1][1] += postcontext;
            } else {
              patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, postcontext));
            }
          }
          if (!empty2) {
            patches.splice(++x, 0, patch);
          }
        }
      }
    };
    diff_match_patch3.prototype.patch_toText = function(patches) {
      var text2 = [];
      for (var x = 0; x < patches.length; x++) {
        text2[x] = patches[x];
      }
      return text2.join("");
    };
    diff_match_patch3.prototype.patch_fromText = function(textline) {
      var patches = [];
      if (!textline) {
        return patches;
      }
      var text2 = textline.split("\n");
      var textPointer = 0;
      var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
      while (textPointer < text2.length) {
        var m = text2[textPointer].match(patchHeader);
        if (!m) {
          throw new Error("Invalid patch string: " + text2[textPointer]);
        }
        var patch = new diff_match_patch3.patch_obj();
        patches.push(patch);
        patch.start1 = parseInt(m[1], 10);
        if (m[2] === "") {
          patch.start1--;
          patch.length1 = 1;
        } else if (m[2] == "0") {
          patch.length1 = 0;
        } else {
          patch.start1--;
          patch.length1 = parseInt(m[2], 10);
        }
        patch.start2 = parseInt(m[3], 10);
        if (m[4] === "") {
          patch.start2--;
          patch.length2 = 1;
        } else if (m[4] == "0") {
          patch.length2 = 0;
        } else {
          patch.start2--;
          patch.length2 = parseInt(m[4], 10);
        }
        textPointer++;
        while (textPointer < text2.length) {
          var sign = text2[textPointer].charAt(0);
          try {
            var line = decodeURI(text2[textPointer].substring(1));
          } catch (ex) {
            throw new Error("Illegal escape in patch_fromText: " + line);
          }
          if (sign == "-") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_DELETE3, line));
          } else if (sign == "+") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_INSERT3, line));
          } else if (sign == " ") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, line));
          } else if (sign == "@") {
            break;
          } else if (sign === "") {
          } else {
            throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
          }
          textPointer++;
        }
      }
      return patches;
    };
    diff_match_patch3.patch_obj = function() {
      this.diffs = [];
      this.start1 = null;
      this.start2 = null;
      this.length1 = 0;
      this.length2 = 0;
    };
    diff_match_patch3.patch_obj.prototype.toString = function() {
      var coords1, coords2;
      if (this.length1 === 0) {
        coords1 = this.start1 + ",0";
      } else if (this.length1 == 1) {
        coords1 = this.start1 + 1;
      } else {
        coords1 = this.start1 + 1 + "," + this.length1;
      }
      if (this.length2 === 0) {
        coords2 = this.start2 + ",0";
      } else if (this.length2 == 1) {
        coords2 = this.start2 + 1;
      } else {
        coords2 = this.start2 + 1 + "," + this.length2;
      }
      var text2 = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
      var op;
      for (var x = 0; x < this.diffs.length; x++) {
        switch (this.diffs[x][0]) {
          case DIFF_INSERT3:
            op = "+";
            break;
          case DIFF_DELETE3:
            op = "-";
            break;
          case DIFF_EQUAL3:
            op = " ";
            break;
        }
        text2[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
      }
      return text2.join("").replace(/%20/g, " ");
    };
    module2.exports = diff_match_patch3;
    module2.exports["diff_match_patch"] = diff_match_patch3;
    module2.exports["DIFF_DELETE"] = DIFF_DELETE3;
    module2.exports["DIFF_INSERT"] = DIFF_INSERT3;
    module2.exports["DIFF_EQUAL"] = DIFF_EQUAL3;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t3) {
        for (var s, i = 1, n3 = arguments.length; i < n3; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t3[p] = s[p];
        }
        return t3;
      };
      __rest2 = function(s, e3) {
        var t3 = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
            t3[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t3[p[i]] = s[p[i]];
          }
        return t3;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
        return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f, y, t3, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n3) {
          return function(v) {
            return step([n3, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t3 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t3 = y["return"]) && t3.call(y), 0) : y.next) && !(t3 = t3.call(y, op[1])).done)
                return t3;
              if (y = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y = 0;
            } finally {
              f = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o2, p))
            __createBinding2(o2, m, p);
      };
      __createBinding2 = Object.create ? function(o2, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o2, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o2, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o2[k2] = m[k];
      };
      __values2 = function(o2) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o2[s], i = 0;
        if (m)
          return m.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i++], done: !o2 };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o2, n3) {
        var m = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m)
          return o2;
        var i = m.call(o2), r2, ar = [], e3;
        try {
          while ((n3 === void 0 || n3-- > 0) && !(r2 = i.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n3) {
          if (g[n3])
            i[n3] = function(v) {
              return new Promise(function(a, b) {
                q.push([n3, v, a, b]) > 1 || resume(n3, v);
              });
            };
        }
        function resume(n3, v) {
          try {
            step(g[n3](v));
          } catch (e3) {
            settle(q[0][3], e3);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o2) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n3, f) {
          i[n3] = o2[n3] ? function(v) {
            return (p = !p) ? { value: __await2(o2[n3](v)), done: n3 === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o2[Symbol.asyncIterator], i;
        return m ? m.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n3) {
          i[n3] = o2[n3] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o2[n3](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o2, v) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v });
      } : function(o2, v) {
        o2["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// src/main.ts
__export(exports, {
  default: () => ObsidianLiveSyncPlugin
});
var import_obsidian7 = __toModule(require("obsidian"));
var import_diff_match_patch3 = __toModule(require_diff_match_patch());

// src/types.ts
var MAX_DOC_SIZE = 1e3;
var MAX_DOC_SIZE_BIN = 102400;
var VER = 10;
var RECENT_MOFIDIED_DOCS_QTY = 30;
var LEAF_WAIT_TIMEOUT = 9e4;
var LOG_LEVEL = {
  VERBOSE: 1,
  INFO: 10,
  NOTICE: 100,
  URGENT: 1e3
};
var VERSIONINFO_DOCID = "obsydian_livesync_version";
var MILSTONE_DOCID = "_local/obsydian_livesync_milestone";
var NODEINFO_DOCID = "_local/obsydian_livesync_nodeinfo";
var DEFAULT_SETTINGS = {
  couchDB_URI: "",
  couchDB_USER: "",
  couchDB_PASSWORD: "",
  couchDB_DBNAME: "",
  liveSync: false,
  syncOnSave: false,
  syncOnStart: false,
  savingDelay: 200,
  lessInformationInLog: false,
  gcDelay: 300,
  versionUpFlash: "",
  minimumChunkSize: 20,
  longLineThreshold: 250,
  showVerboseLog: false,
  suspendFileWatching: false,
  trashInsteadDelete: true,
  periodicReplication: false,
  periodicReplicationInterval: 60,
  syncOnFileOpen: false,
  encrypt: false,
  passphrase: "",
  workingEncrypt: false,
  workingPassphrase: "",
  doNotDeleteFolder: false,
  resolveConflictsByNewerFile: false,
  batchSave: false,
  deviceAndVaultName: "",
  usePluginSettings: false,
  showOwnPlugins: false,
  showStatusOnEditor: false,
  usePluginSync: false,
  autoSweepPlugins: false,
  autoSweepPluginsPeriodic: false,
  notifyPluginOrSettingUpdated: false,
  checkIntegrityOnSave: false,
  batch_size: 250,
  batches_limit: 40,
  useHistory: false
};
var PERIODIC_PLUGIN_SWEEP = 60;
var FLAGMD_REDFLAG = "redflag.md";

// src/utils.ts
var import_obsidian = __toModule(require("obsidian"));

// src/logger.ts
var Logger = (message, _) => __async(void 0, null, function* () {
  const timestamp = new Date().toLocaleString();
  const messagecontent = typeof message == "string" ? message : message instanceof Error ? `${message.name}:${message.message}` : JSON.stringify(message, null, 2);
  const newmessage = timestamp + "->" + messagecontent;
  console.log(newmessage);
});
function setLogger(loggerFun) {
  Logger = loggerFun;
}

// src/utils.ts
function arrayBufferToBase64(buffer) {
  return new Promise((res) => {
    const blob = new Blob([buffer], { type: "application/octet-binary" });
    const reader = new FileReader();
    reader.onload = function(evt) {
      const dataurl = evt.target.result.toString();
      res(dataurl.substr(dataurl.indexOf(",") + 1));
    };
    reader.readAsDataURL(blob);
  });
}
function base64ToString(base64) {
  try {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }
    return new TextDecoder().decode(bytes);
  } catch (ex) {
    return base64;
  }
}
function base64ToArrayBuffer(base64) {
  try {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
  } catch (ex) {
    try {
      return new Uint16Array([].map.call(base64, function(c) {
        return c.charCodeAt(0);
      })).buffer;
    } catch (ex2) {
      return null;
    }
  }
}
var escapeStringToHTML = (str) => {
  if (!str)
    return "";
  return str.replace(/[<>&"'`]/g, (match) => {
    const escape = {
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      '"': "&quot;",
      "'": "&#39;",
      "`": "&#x60;"
    };
    return escape[match];
  });
};
function resolveWithIgnoreKnownError(p, def) {
  return new Promise((res, rej) => {
    p.then(res).catch((ex) => ex.status && ex.status == 404 ? res(def) : rej(ex));
  });
}
function isValidPath(filename) {
  const regex = /[\u0000-\u001f]|[\\":?<>|*#]/g;
  let x = filename.replace(regex, "_");
  const win = /(\\|\/)(COM\d|LPT\d|CON|PRN|AUX|NUL|CLOCK$)($|\.)/gi;
  const sx = x = x.replace(win, "/_");
  return sx == filename;
}
function shouldBeIgnored(filename) {
  if (filename == FLAGMD_REDFLAG) {
    return true;
  }
  return false;
}
function versionNumberString2Number(version) {
  return version.split(".").reverse().map((e3, i) => e3 / 1 * __pow(1e3, i)).reduce((prev, current) => prev + current, 0);
}
var delay = (ms) => {
  return new Promise((res) => {
    setTimeout(() => {
      res();
    }, ms);
  });
};
function path2id(filename) {
  let x = (0, import_obsidian.normalizePath)(filename);
  if (x.startsWith("_"))
    x = "/" + x;
  return x;
}
function id2path(filename) {
  return (0, import_obsidian.normalizePath)(filename);
}
var runningProcs = [];
var pendingProcs = {};
function objectToKey(key) {
  if (typeof key === "string")
    return key;
  const keys = Object.keys(key).sort((a, b) => a.localeCompare(b));
  return keys.map((e3) => e3 + objectToKey(key[e3])).join(":");
}
function getProcessingCounts() {
  let count = 0;
  for (const v in pendingProcs) {
    count += pendingProcs[v].length;
  }
  count += runningProcs.length;
  return count;
}
var externalNotifier = () => {
};
var notifyTimer = null;
function setLockNotifier(fn) {
  externalNotifier = fn;
}
function notifyLock() {
  if (notifyTimer != null) {
    window.clearTimeout(notifyTimer);
  }
  notifyTimer = window.setTimeout(() => {
    externalNotifier();
  }, 100);
}
function runWithLock(key, ignoreWhenRunning, proc) {
  const lockKey = typeof key === "string" ? key : objectToKey(key);
  const handleNextProcs = () => {
    if (typeof pendingProcs[lockKey] === "undefined") {
      runningProcs.remove(lockKey);
      notifyLock();
    } else {
      Logger(`Lock:${lockKey}:left ${pendingProcs[lockKey].length}`, LOG_LEVEL.VERBOSE);
      let nextProc = null;
      nextProc = pendingProcs[lockKey].shift();
      notifyLock();
      if (nextProc) {
        nextProc().then().catch((err) => {
          Logger(err);
        }).finally(() => {
          if (pendingProcs && lockKey in pendingProcs && pendingProcs[lockKey].length == 0) {
            delete pendingProcs[lockKey];
            notifyLock();
          }
          queueMicrotask(() => {
            handleNextProcs();
          });
        });
      } else {
        if (pendingProcs && lockKey in pendingProcs && pendingProcs[lockKey].length == 0) {
          delete pendingProcs[lockKey];
          notifyLock();
        }
      }
    }
  };
  if (runningProcs.contains(lockKey)) {
    if (ignoreWhenRunning) {
      return null;
    }
    if (typeof pendingProcs[lockKey] === "undefined") {
      pendingProcs[lockKey] = [];
    }
    let responderRes;
    let responderRej;
    const responder = new Promise((res, rej) => {
      responderRes = res;
      responderRej = rej;
    });
    const subproc = () => new Promise((res, rej) => {
      proc().then((v) => {
        handleNextProcs();
        responderRes(v);
        res();
      }).catch((reason) => {
        Logger(`Lock:${key}:rejected`, LOG_LEVEL.VERBOSE);
        handleNextProcs();
        rej(reason);
        responderRej(reason);
      });
    });
    pendingProcs[lockKey].push(subproc);
    notifyLock();
    return responder;
  } else {
    runningProcs.push(lockKey);
    notifyLock();
    return new Promise((res, rej) => {
      proc().then((v) => {
        handleNextProcs();
        res(v);
      }).catch((reason) => {
        handleNextProcs();
        rej(reason);
      });
    });
  }
}
function isPlainText(filename) {
  if (filename.endsWith(".md"))
    return true;
  if (filename.endsWith(".txt"))
    return true;
  if (filename.endsWith(".svg"))
    return true;
  if (filename.endsWith(".html"))
    return true;
  if (filename.endsWith(".csv"))
    return true;
  if (filename.endsWith(".css"))
    return true;
  if (filename.endsWith(".js"))
    return true;
  if (filename.endsWith(".xml"))
    return true;
  return false;
}

// src/LocalPouchDB.ts
var import_obsidian2 = __toModule(require("obsidian"));

// pouchdb-browser-webpack/dist/pouchdb-browser.js
var e = { 105: (e3) => {
  e3.exports = function(e4) {
    return function() {
      var t3 = arguments.length;
      if (t3) {
        for (var n3 = [], r2 = -1; ++r2 < t3; )
          n3[r2] = arguments[r2];
        return e4.call(this, n3);
      }
      return e4.call(this, []);
    };
  };
}, 187: (e3) => {
  var t3, n3 = typeof Reflect == "object" ? Reflect : null, r2 = n3 && typeof n3.apply == "function" ? n3.apply : function(e4, t4, n4) {
    return Function.prototype.apply.call(e4, t4, n4);
  };
  t3 = n3 && typeof n3.ownKeys == "function" ? n3.ownKeys : Object.getOwnPropertySymbols ? function(e4) {
    return Object.getOwnPropertyNames(e4).concat(Object.getOwnPropertySymbols(e4));
  } : function(e4) {
    return Object.getOwnPropertyNames(e4);
  };
  var o2 = Number.isNaN || function(e4) {
    return e4 != e4;
  };
  function i() {
    i.init.call(this);
  }
  e3.exports = i, e3.exports.once = function(e4, t4) {
    return new Promise(function(n4, r3) {
      function o3(n5) {
        e4.removeListener(t4, i2), r3(n5);
      }
      function i2() {
        typeof e4.removeListener == "function" && e4.removeListener("error", o3), n4([].slice.call(arguments));
      }
      v(e4, t4, i2, { once: true }), t4 !== "error" && function(e5, t5, n5) {
        typeof e5.on == "function" && v(e5, "error", t5, { once: true });
      }(e4, o3);
    });
  }, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0;
  var s = 10;
  function a(e4) {
    if (typeof e4 != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e4);
  }
  function u(e4) {
    return e4._maxListeners === void 0 ? i.defaultMaxListeners : e4._maxListeners;
  }
  function c(e4, t4, n4, r3) {
    var o3, i2, s2, c2;
    if (a(n4), (i2 = e4._events) === void 0 ? (i2 = e4._events = Object.create(null), e4._eventsCount = 0) : (i2.newListener !== void 0 && (e4.emit("newListener", t4, n4.listener ? n4.listener : n4), i2 = e4._events), s2 = i2[t4]), s2 === void 0)
      s2 = i2[t4] = n4, ++e4._eventsCount;
    else if (typeof s2 == "function" ? s2 = i2[t4] = r3 ? [n4, s2] : [s2, n4] : r3 ? s2.unshift(n4) : s2.push(n4), (o3 = u(e4)) > 0 && s2.length > o3 && !s2.warned) {
      s2.warned = true;
      var f2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t4) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      f2.name = "MaxListenersExceededWarning", f2.emitter = e4, f2.type = t4, f2.count = s2.length, c2 = f2, console && console.warn && console.warn(c2);
    }
    return e4;
  }
  function f() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(e4, t4, n4) {
    var r3 = { fired: false, wrapFn: void 0, target: e4, type: t4, listener: n4 }, o3 = f.bind(r3);
    return o3.listener = n4, r3.wrapFn = o3, o3;
  }
  function d(e4, t4, n4) {
    var r3 = e4._events;
    if (r3 === void 0)
      return [];
    var o3 = r3[t4];
    return o3 === void 0 ? [] : typeof o3 == "function" ? n4 ? [o3.listener || o3] : [o3] : n4 ? function(e5) {
      for (var t5 = new Array(e5.length), n5 = 0; n5 < t5.length; ++n5)
        t5[n5] = e5[n5].listener || e5[n5];
      return t5;
    }(o3) : p(o3, o3.length);
  }
  function h(e4) {
    var t4 = this._events;
    if (t4 !== void 0) {
      var n4 = t4[e4];
      if (typeof n4 == "function")
        return 1;
      if (n4 !== void 0)
        return n4.length;
    }
    return 0;
  }
  function p(e4, t4) {
    for (var n4 = new Array(t4), r3 = 0; r3 < t4; ++r3)
      n4[r3] = e4[r3];
    return n4;
  }
  function v(e4, t4, n4, r3) {
    if (typeof e4.on == "function")
      r3.once ? e4.once(t4, n4) : e4.on(t4, n4);
    else {
      if (typeof e4.addEventListener != "function")
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e4);
      e4.addEventListener(t4, function o3(i2) {
        r3.once && e4.removeEventListener(t4, o3), n4(i2);
      });
    }
  }
  Object.defineProperty(i, "defaultMaxListeners", { enumerable: true, get: function() {
    return s;
  }, set: function(e4) {
    if (typeof e4 != "number" || e4 < 0 || o2(e4))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e4 + ".");
    s = e4;
  } }), i.init = function() {
    this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, i.prototype.setMaxListeners = function(e4) {
    if (typeof e4 != "number" || e4 < 0 || o2(e4))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e4 + ".");
    return this._maxListeners = e4, this;
  }, i.prototype.getMaxListeners = function() {
    return u(this);
  }, i.prototype.emit = function(e4) {
    for (var t4 = [], n4 = 1; n4 < arguments.length; n4++)
      t4.push(arguments[n4]);
    var o3 = e4 === "error", i2 = this._events;
    if (i2 !== void 0)
      o3 = o3 && i2.error === void 0;
    else if (!o3)
      return false;
    if (o3) {
      var s2;
      if (t4.length > 0 && (s2 = t4[0]), s2 instanceof Error)
        throw s2;
      var a2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
      throw a2.context = s2, a2;
    }
    var u2 = i2[e4];
    if (u2 === void 0)
      return false;
    if (typeof u2 == "function")
      r2(u2, this, t4);
    else {
      var c2 = u2.length, f2 = p(u2, c2);
      for (n4 = 0; n4 < c2; ++n4)
        r2(f2[n4], this, t4);
    }
    return true;
  }, i.prototype.addListener = function(e4, t4) {
    return c(this, e4, t4, false);
  }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function(e4, t4) {
    return c(this, e4, t4, true);
  }, i.prototype.once = function(e4, t4) {
    return a(t4), this.on(e4, l(this, e4, t4)), this;
  }, i.prototype.prependOnceListener = function(e4, t4) {
    return a(t4), this.prependListener(e4, l(this, e4, t4)), this;
  }, i.prototype.removeListener = function(e4, t4) {
    var n4, r3, o3, i2, s2;
    if (a(t4), (r3 = this._events) === void 0)
      return this;
    if ((n4 = r3[e4]) === void 0)
      return this;
    if (n4 === t4 || n4.listener === t4)
      --this._eventsCount == 0 ? this._events = Object.create(null) : (delete r3[e4], r3.removeListener && this.emit("removeListener", e4, n4.listener || t4));
    else if (typeof n4 != "function") {
      for (o3 = -1, i2 = n4.length - 1; i2 >= 0; i2--)
        if (n4[i2] === t4 || n4[i2].listener === t4) {
          s2 = n4[i2].listener, o3 = i2;
          break;
        }
      if (o3 < 0)
        return this;
      o3 === 0 ? n4.shift() : function(e5, t5) {
        for (; t5 + 1 < e5.length; t5++)
          e5[t5] = e5[t5 + 1];
        e5.pop();
      }(n4, o3), n4.length === 1 && (r3[e4] = n4[0]), r3.removeListener !== void 0 && this.emit("removeListener", e4, s2 || t4);
    }
    return this;
  }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function(e4) {
    var t4, n4, r3;
    if ((n4 = this._events) === void 0)
      return this;
    if (n4.removeListener === void 0)
      return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n4[e4] !== void 0 && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete n4[e4]), this;
    if (arguments.length === 0) {
      var o3, i2 = Object.keys(n4);
      for (r3 = 0; r3 < i2.length; ++r3)
        (o3 = i2[r3]) !== "removeListener" && this.removeAllListeners(o3);
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if (typeof (t4 = n4[e4]) == "function")
      this.removeListener(e4, t4);
    else if (t4 !== void 0)
      for (r3 = t4.length - 1; r3 >= 0; r3--)
        this.removeListener(e4, t4[r3]);
    return this;
  }, i.prototype.listeners = function(e4) {
    return d(this, e4, true);
  }, i.prototype.rawListeners = function(e4) {
    return d(this, e4, false);
  }, i.listenerCount = function(e4, t4) {
    return typeof e4.listenerCount == "function" ? e4.listenerCount(t4) : h.call(e4, t4);
  }, i.prototype.listenerCount = h, i.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t3(this._events) : [];
  };
}, 624: (e3, t3, n3) => {
  var r2, o2, i, s = [n3(525), n3(785), n3(291), n3(709), n3(506), n3(176)], a = -1, u = [], c = false;
  function f() {
    r2 && o2 && (r2 = false, o2.length ? u = o2.concat(u) : a = -1, u.length && l());
  }
  function l() {
    if (!r2) {
      c = false, r2 = true;
      for (var e4 = u.length, t4 = setTimeout(f); e4; ) {
        for (o2 = u, u = []; o2 && ++a < e4; )
          o2[a].run();
        a = -1, e4 = u.length;
      }
      o2 = null, a = -1, r2 = false, clearTimeout(t4);
    }
  }
  for (var d = -1, h = s.length; ++d < h; )
    if (s[d] && s[d].test && s[d].test()) {
      i = s[d].install(l);
      break;
    }
  function p(e4, t4) {
    this.fun = e4, this.array = t4;
  }
  p.prototype.run = function() {
    var e4 = this.fun, t4 = this.array;
    switch (t4.length) {
      case 0:
        return e4();
      case 1:
        return e4(t4[0]);
      case 2:
        return e4(t4[0], t4[1]);
      case 3:
        return e4(t4[0], t4[1], t4[2]);
      default:
        return e4.apply(null, t4);
    }
  }, e3.exports = function(e4) {
    var t4 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n4 = 1; n4 < arguments.length; n4++)
        t4[n4 - 1] = arguments[n4];
    u.push(new p(e4, t4)), c || r2 || (c = true, i());
  };
}, 709: (e3, t3, n3) => {
  t3.test = function() {
    return !n3.g.setImmediate && n3.g.MessageChannel !== void 0;
  }, t3.install = function(e4) {
    var t4 = new n3.g.MessageChannel();
    return t4.port1.onmessage = e4, function() {
      t4.port2.postMessage(0);
    };
  };
}, 291: (e3, t3, n3) => {
  var r2 = n3.g.MutationObserver || n3.g.WebKitMutationObserver;
  t3.test = function() {
    return r2;
  }, t3.install = function(e4) {
    var t4 = 0, o2 = new r2(e4), i = n3.g.document.createTextNode("");
    return o2.observe(i, { characterData: true }), function() {
      i.data = t4 = ++t4 % 2;
    };
  };
}, 785: (e3, t3, n3) => {
  t3.test = function() {
    return typeof n3.g.queueMicrotask == "function";
  }, t3.install = function(e4) {
    return function() {
      n3.g.queueMicrotask(e4);
    };
  };
}, 506: (e3, t3, n3) => {
  t3.test = function() {
    return "document" in n3.g && "onreadystatechange" in n3.g.document.createElement("script");
  }, t3.install = function(e4) {
    return function() {
      var t4 = n3.g.document.createElement("script");
      return t4.onreadystatechange = function() {
        e4(), t4.onreadystatechange = null, t4.parentNode.removeChild(t4), t4 = null;
      }, n3.g.document.documentElement.appendChild(t4), e4;
    };
  };
}, 176: (e3, t3) => {
  t3.test = function() {
    return true;
  }, t3.install = function(e4) {
    return function() {
      setTimeout(e4, 0);
    };
  };
}, 717: (e3) => {
  typeof Object.create == "function" ? e3.exports = function(e4, t3) {
    t3 && (e4.super_ = t3, e4.prototype = Object.create(t3.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }));
  } : e3.exports = function(e4, t3) {
    if (t3) {
      e4.super_ = t3;
      var n3 = function() {
      };
      n3.prototype = t3.prototype, e4.prototype = new n3(), e4.prototype.constructor = e4;
    }
  };
}, 322: (e3) => {
  e3.exports = function(e4) {
    var t3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function n3(e5, t4) {
      var n4 = e5[0], r3 = e5[1], o3 = e5[2], i2 = e5[3];
      r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 & o3 | ~r3 & i2) + t4[0] - 680876936 | 0) << 7 | n4 >>> 25) + r3 | 0) & r3 | ~n4 & o3) + t4[1] - 389564586 | 0) << 12 | i2 >>> 20) + n4 | 0) & n4 | ~i2 & r3) + t4[2] + 606105819 | 0) << 17 | o3 >>> 15) + i2 | 0) & i2 | ~o3 & n4) + t4[3] - 1044525330 | 0) << 22 | r3 >>> 10) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 & o3 | ~r3 & i2) + t4[4] - 176418897 | 0) << 7 | n4 >>> 25) + r3 | 0) & r3 | ~n4 & o3) + t4[5] + 1200080426 | 0) << 12 | i2 >>> 20) + n4 | 0) & n4 | ~i2 & r3) + t4[6] - 1473231341 | 0) << 17 | o3 >>> 15) + i2 | 0) & i2 | ~o3 & n4) + t4[7] - 45705983 | 0) << 22 | r3 >>> 10) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 & o3 | ~r3 & i2) + t4[8] + 1770035416 | 0) << 7 | n4 >>> 25) + r3 | 0) & r3 | ~n4 & o3) + t4[9] - 1958414417 | 0) << 12 | i2 >>> 20) + n4 | 0) & n4 | ~i2 & r3) + t4[10] - 42063 | 0) << 17 | o3 >>> 15) + i2 | 0) & i2 | ~o3 & n4) + t4[11] - 1990404162 | 0) << 22 | r3 >>> 10) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 & o3 | ~r3 & i2) + t4[12] + 1804603682 | 0) << 7 | n4 >>> 25) + r3 | 0) & r3 | ~n4 & o3) + t4[13] - 40341101 | 0) << 12 | i2 >>> 20) + n4 | 0) & n4 | ~i2 & r3) + t4[14] - 1502002290 | 0) << 17 | o3 >>> 15) + i2 | 0) & i2 | ~o3 & n4) + t4[15] + 1236535329 | 0) << 22 | r3 >>> 10) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 & i2 | o3 & ~i2) + t4[1] - 165796510 | 0) << 5 | n4 >>> 27) + r3 | 0) & o3 | r3 & ~o3) + t4[6] - 1069501632 | 0) << 9 | i2 >>> 23) + n4 | 0) & r3 | n4 & ~r3) + t4[11] + 643717713 | 0) << 14 | o3 >>> 18) + i2 | 0) & n4 | i2 & ~n4) + t4[0] - 373897302 | 0) << 20 | r3 >>> 12) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 & i2 | o3 & ~i2) + t4[5] - 701558691 | 0) << 5 | n4 >>> 27) + r3 | 0) & o3 | r3 & ~o3) + t4[10] + 38016083 | 0) << 9 | i2 >>> 23) + n4 | 0) & r3 | n4 & ~r3) + t4[15] - 660478335 | 0) << 14 | o3 >>> 18) + i2 | 0) & n4 | i2 & ~n4) + t4[4] - 405537848 | 0) << 20 | r3 >>> 12) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 & i2 | o3 & ~i2) + t4[9] + 568446438 | 0) << 5 | n4 >>> 27) + r3 | 0) & o3 | r3 & ~o3) + t4[14] - 1019803690 | 0) << 9 | i2 >>> 23) + n4 | 0) & r3 | n4 & ~r3) + t4[3] - 187363961 | 0) << 14 | o3 >>> 18) + i2 | 0) & n4 | i2 & ~n4) + t4[8] + 1163531501 | 0) << 20 | r3 >>> 12) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 & i2 | o3 & ~i2) + t4[13] - 1444681467 | 0) << 5 | n4 >>> 27) + r3 | 0) & o3 | r3 & ~o3) + t4[2] - 51403784 | 0) << 9 | i2 >>> 23) + n4 | 0) & r3 | n4 & ~r3) + t4[7] + 1735328473 | 0) << 14 | o3 >>> 18) + i2 | 0) & n4 | i2 & ~n4) + t4[12] - 1926607734 | 0) << 20 | r3 >>> 12) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 ^ o3 ^ i2) + t4[5] - 378558 | 0) << 4 | n4 >>> 28) + r3 | 0) ^ r3 ^ o3) + t4[8] - 2022574463 | 0) << 11 | i2 >>> 21) + n4 | 0) ^ n4 ^ r3) + t4[11] + 1839030562 | 0) << 16 | o3 >>> 16) + i2 | 0) ^ i2 ^ n4) + t4[14] - 35309556 | 0) << 23 | r3 >>> 9) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 ^ o3 ^ i2) + t4[1] - 1530992060 | 0) << 4 | n4 >>> 28) + r3 | 0) ^ r3 ^ o3) + t4[4] + 1272893353 | 0) << 11 | i2 >>> 21) + n4 | 0) ^ n4 ^ r3) + t4[7] - 155497632 | 0) << 16 | o3 >>> 16) + i2 | 0) ^ i2 ^ n4) + t4[10] - 1094730640 | 0) << 23 | r3 >>> 9) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 ^ o3 ^ i2) + t4[13] + 681279174 | 0) << 4 | n4 >>> 28) + r3 | 0) ^ r3 ^ o3) + t4[0] - 358537222 | 0) << 11 | i2 >>> 21) + n4 | 0) ^ n4 ^ r3) + t4[3] - 722521979 | 0) << 16 | o3 >>> 16) + i2 | 0) ^ i2 ^ n4) + t4[6] + 76029189 | 0) << 23 | r3 >>> 9) + o3 | 0, r3 = ((r3 += ((o3 = ((o3 += ((i2 = ((i2 += ((n4 = ((n4 += (r3 ^ o3 ^ i2) + t4[9] - 640364487 | 0) << 4 | n4 >>> 28) + r3 | 0) ^ r3 ^ o3) + t4[12] - 421815835 | 0) << 11 | i2 >>> 21) + n4 | 0) ^ n4 ^ r3) + t4[15] + 530742520 | 0) << 16 | o3 >>> 16) + i2 | 0) ^ i2 ^ n4) + t4[2] - 995338651 | 0) << 23 | r3 >>> 9) + o3 | 0, r3 = ((r3 += ((i2 = ((i2 += (r3 ^ ((n4 = ((n4 += (o3 ^ (r3 | ~i2)) + t4[0] - 198630844 | 0) << 6 | n4 >>> 26) + r3 | 0) | ~o3)) + t4[7] + 1126891415 | 0) << 10 | i2 >>> 22) + n4 | 0) ^ ((o3 = ((o3 += (n4 ^ (i2 | ~r3)) + t4[14] - 1416354905 | 0) << 15 | o3 >>> 17) + i2 | 0) | ~n4)) + t4[5] - 57434055 | 0) << 21 | r3 >>> 11) + o3 | 0, r3 = ((r3 += ((i2 = ((i2 += (r3 ^ ((n4 = ((n4 += (o3 ^ (r3 | ~i2)) + t4[12] + 1700485571 | 0) << 6 | n4 >>> 26) + r3 | 0) | ~o3)) + t4[3] - 1894986606 | 0) << 10 | i2 >>> 22) + n4 | 0) ^ ((o3 = ((o3 += (n4 ^ (i2 | ~r3)) + t4[10] - 1051523 | 0) << 15 | o3 >>> 17) + i2 | 0) | ~n4)) + t4[1] - 2054922799 | 0) << 21 | r3 >>> 11) + o3 | 0, r3 = ((r3 += ((i2 = ((i2 += (r3 ^ ((n4 = ((n4 += (o3 ^ (r3 | ~i2)) + t4[8] + 1873313359 | 0) << 6 | n4 >>> 26) + r3 | 0) | ~o3)) + t4[15] - 30611744 | 0) << 10 | i2 >>> 22) + n4 | 0) ^ ((o3 = ((o3 += (n4 ^ (i2 | ~r3)) + t4[6] - 1560198380 | 0) << 15 | o3 >>> 17) + i2 | 0) | ~n4)) + t4[13] + 1309151649 | 0) << 21 | r3 >>> 11) + o3 | 0, r3 = ((r3 += ((i2 = ((i2 += (r3 ^ ((n4 = ((n4 += (o3 ^ (r3 | ~i2)) + t4[4] - 145523070 | 0) << 6 | n4 >>> 26) + r3 | 0) | ~o3)) + t4[11] - 1120210379 | 0) << 10 | i2 >>> 22) + n4 | 0) ^ ((o3 = ((o3 += (n4 ^ (i2 | ~r3)) + t4[2] + 718787259 | 0) << 15 | o3 >>> 17) + i2 | 0) | ~n4)) + t4[9] - 343485551 | 0) << 21 | r3 >>> 11) + o3 | 0, e5[0] = n4 + e5[0] | 0, e5[1] = r3 + e5[1] | 0, e5[2] = o3 + e5[2] | 0, e5[3] = i2 + e5[3] | 0;
    }
    function r2(e5) {
      var t4, n4 = [];
      for (t4 = 0; t4 < 64; t4 += 4)
        n4[t4 >> 2] = e5.charCodeAt(t4) + (e5.charCodeAt(t4 + 1) << 8) + (e5.charCodeAt(t4 + 2) << 16) + (e5.charCodeAt(t4 + 3) << 24);
      return n4;
    }
    function o2(e5) {
      var t4, n4 = [];
      for (t4 = 0; t4 < 64; t4 += 4)
        n4[t4 >> 2] = e5[t4] + (e5[t4 + 1] << 8) + (e5[t4 + 2] << 16) + (e5[t4 + 3] << 24);
      return n4;
    }
    function i(e5) {
      var t4, o3, i2, s2, a2, u2, c2 = e5.length, f2 = [1732584193, -271733879, -1732584194, 271733878];
      for (t4 = 64; t4 <= c2; t4 += 64)
        n3(f2, r2(e5.substring(t4 - 64, t4)));
      for (o3 = (e5 = e5.substring(t4 - 64)).length, i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t4 = 0; t4 < o3; t4 += 1)
        i2[t4 >> 2] |= e5.charCodeAt(t4) << (t4 % 4 << 3);
      if (i2[t4 >> 2] |= 128 << (t4 % 4 << 3), t4 > 55)
        for (n3(f2, i2), t4 = 0; t4 < 16; t4 += 1)
          i2[t4] = 0;
      return s2 = (s2 = 8 * c2).toString(16).match(/(.*?)(.{0,8})$/), a2 = parseInt(s2[2], 16), u2 = parseInt(s2[1], 16) || 0, i2[14] = a2, i2[15] = u2, n3(f2, i2), f2;
    }
    function s(e5) {
      var n4, r3 = "";
      for (n4 = 0; n4 < 4; n4 += 1)
        r3 += t3[e5 >> 8 * n4 + 4 & 15] + t3[e5 >> 8 * n4 & 15];
      return r3;
    }
    function a(e5) {
      var t4;
      for (t4 = 0; t4 < e5.length; t4 += 1)
        e5[t4] = s(e5[t4]);
      return e5.join("");
    }
    function u(e5) {
      return /[\u0080-\uFFFF]/.test(e5) && (e5 = unescape(encodeURIComponent(e5))), e5;
    }
    function c(e5) {
      var t4, n4 = [], r3 = e5.length;
      for (t4 = 0; t4 < r3 - 1; t4 += 2)
        n4.push(parseInt(e5.substr(t4, 2), 16));
      return String.fromCharCode.apply(String, n4);
    }
    function f() {
      this.reset();
    }
    return a(i("hello")), typeof ArrayBuffer == "undefined" || ArrayBuffer.prototype.slice || function() {
      function e5(e6, t4) {
        return (e6 = 0 | e6 || 0) < 0 ? Math.max(e6 + t4, 0) : Math.min(e6, t4);
      }
      ArrayBuffer.prototype.slice = function(t4, n4) {
        var r3, o3, i2, s2, a2 = this.byteLength, u2 = e5(t4, a2), c2 = a2;
        return n4 !== void 0 && (c2 = e5(n4, a2)), u2 > c2 ? new ArrayBuffer(0) : (r3 = c2 - u2, o3 = new ArrayBuffer(r3), i2 = new Uint8Array(o3), s2 = new Uint8Array(this, u2, r3), i2.set(s2), o3);
      };
    }(), f.prototype.append = function(e5) {
      return this.appendBinary(u(e5)), this;
    }, f.prototype.appendBinary = function(e5) {
      this._buff += e5, this._length += e5.length;
      var t4, o3 = this._buff.length;
      for (t4 = 64; t4 <= o3; t4 += 64)
        n3(this._hash, r2(this._buff.substring(t4 - 64, t4)));
      return this._buff = this._buff.substring(t4 - 64), this;
    }, f.prototype.end = function(e5) {
      var t4, n4, r3 = this._buff, o3 = r3.length, i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t4 = 0; t4 < o3; t4 += 1)
        i2[t4 >> 2] |= r3.charCodeAt(t4) << (t4 % 4 << 3);
      return this._finish(i2, o3), n4 = a(this._hash), e5 && (n4 = c(n4)), this.reset(), n4;
    }, f.prototype.reset = function() {
      return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, f.prototype.getState = function() {
      return { buff: this._buff, length: this._length, hash: this._hash.slice() };
    }, f.prototype.setState = function(e5) {
      return this._buff = e5.buff, this._length = e5.length, this._hash = e5.hash, this;
    }, f.prototype.destroy = function() {
      delete this._hash, delete this._buff, delete this._length;
    }, f.prototype._finish = function(e5, t4) {
      var r3, o3, i2, s2 = t4;
      if (e5[s2 >> 2] |= 128 << (s2 % 4 << 3), s2 > 55)
        for (n3(this._hash, e5), s2 = 0; s2 < 16; s2 += 1)
          e5[s2] = 0;
      r3 = (r3 = 8 * this._length).toString(16).match(/(.*?)(.{0,8})$/), o3 = parseInt(r3[2], 16), i2 = parseInt(r3[1], 16) || 0, e5[14] = o3, e5[15] = i2, n3(this._hash, e5);
    }, f.hash = function(e5, t4) {
      return f.hashBinary(u(e5), t4);
    }, f.hashBinary = function(e5, t4) {
      var n4 = a(i(e5));
      return t4 ? c(n4) : n4;
    }, f.ArrayBuffer = function() {
      this.reset();
    }, f.ArrayBuffer.prototype.append = function(e5) {
      var t4, r3, i2, s2, a2, u2 = (r3 = this._buff.buffer, i2 = e5, s2 = true, (a2 = new Uint8Array(r3.byteLength + i2.byteLength)).set(new Uint8Array(r3)), a2.set(new Uint8Array(i2), r3.byteLength), s2 ? a2 : a2.buffer), c2 = u2.length;
      for (this._length += e5.byteLength, t4 = 64; t4 <= c2; t4 += 64)
        n3(this._hash, o2(u2.subarray(t4 - 64, t4)));
      return this._buff = t4 - 64 < c2 ? new Uint8Array(u2.buffer.slice(t4 - 64)) : new Uint8Array(0), this;
    }, f.ArrayBuffer.prototype.end = function(e5) {
      var t4, n4, r3 = this._buff, o3 = r3.length, i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t4 = 0; t4 < o3; t4 += 1)
        i2[t4 >> 2] |= r3[t4] << (t4 % 4 << 3);
      return this._finish(i2, o3), n4 = a(this._hash), e5 && (n4 = c(n4)), this.reset(), n4;
    }, f.ArrayBuffer.prototype.reset = function() {
      return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, f.ArrayBuffer.prototype.getState = function() {
      var e5, t4 = f.prototype.getState.call(this);
      return t4.buff = (e5 = t4.buff, String.fromCharCode.apply(null, new Uint8Array(e5))), t4;
    }, f.ArrayBuffer.prototype.setState = function(e5) {
      return e5.buff = function(e6, t4) {
        var n4, r3 = e6.length, o3 = new ArrayBuffer(r3), i2 = new Uint8Array(o3);
        for (n4 = 0; n4 < r3; n4 += 1)
          i2[n4] = e6.charCodeAt(n4);
        return t4 ? i2 : o3;
      }(e5.buff, true), f.prototype.setState.call(this, e5);
    }, f.ArrayBuffer.prototype.destroy = f.prototype.destroy, f.ArrayBuffer.prototype._finish = f.prototype._finish, f.ArrayBuffer.hash = function(e5, t4) {
      var r3 = a(function(e6) {
        var t5, r4, i2, s2, a2, u2, c2 = e6.length, f2 = [1732584193, -271733879, -1732584194, 271733878];
        for (t5 = 64; t5 <= c2; t5 += 64)
          n3(f2, o2(e6.subarray(t5 - 64, t5)));
        for (r4 = (e6 = t5 - 64 < c2 ? e6.subarray(t5 - 64) : new Uint8Array(0)).length, i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t5 = 0; t5 < r4; t5 += 1)
          i2[t5 >> 2] |= e6[t5] << (t5 % 4 << 3);
        if (i2[t5 >> 2] |= 128 << (t5 % 4 << 3), t5 > 55)
          for (n3(f2, i2), t5 = 0; t5 < 16; t5 += 1)
            i2[t5] = 0;
        return s2 = (s2 = 8 * c2).toString(16).match(/(.*?)(.{0,8})$/), a2 = parseInt(s2[2], 16), u2 = parseInt(s2[1], 16) || 0, i2[14] = a2, i2[15] = u2, n3(f2, i2), f2;
      }(new Uint8Array(e5)));
      return t4 ? c(r3) : r3;
    }, f;
  }();
}, 825: (e3, t3) => {
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = void 0;
  const n3 = [];
  for (let e4 = 0; e4 < 256; ++e4)
    n3.push((e4 + 256).toString(16).substr(1));
  t3.default = function(e4, t4) {
    const r2 = t4 || 0, o2 = n3;
    return (o2[e4[r2 + 0]] + o2[e4[r2 + 1]] + o2[e4[r2 + 2]] + o2[e4[r2 + 3]] + "-" + o2[e4[r2 + 4]] + o2[e4[r2 + 5]] + "-" + o2[e4[r2 + 6]] + o2[e4[r2 + 7]] + "-" + o2[e4[r2 + 8]] + o2[e4[r2 + 9]] + "-" + o2[e4[r2 + 10]] + o2[e4[r2 + 11]] + o2[e4[r2 + 12]] + o2[e4[r2 + 13]] + o2[e4[r2 + 14]] + o2[e4[r2 + 15]]).toLowerCase();
  };
}, 593: (e3, t3, n3) => {
  Object.defineProperty(t3, "v1", { enumerable: true, get: function() {
    return r2.default;
  } }), Object.defineProperty(t3, "v3", { enumerable: true, get: function() {
    return o2.default;
  } }), Object.defineProperty(t3, "v4", { enumerable: true, get: function() {
    return i.default;
  } }), Object.defineProperty(t3, "v5", { enumerable: true, get: function() {
    return s.default;
  } });
  var r2 = a(n3(922)), o2 = a(n3(964)), i = a(n3(509)), s = a(n3(669));
  function a(e4) {
    return e4 && e4.__esModule ? e4 : { default: e4 };
  }
}, 489: (e3, t3) => {
  function n3(e4) {
    return 14 + (e4 + 64 >>> 9 << 4) + 1;
  }
  function r2(e4, t4) {
    const n4 = (65535 & e4) + (65535 & t4);
    return (e4 >> 16) + (t4 >> 16) + (n4 >> 16) << 16 | 65535 & n4;
  }
  function o2(e4, t4, n4, o3, i2, s2) {
    return r2((a2 = r2(r2(t4, e4), r2(o3, s2))) << (u2 = i2) | a2 >>> 32 - u2, n4);
    var a2, u2;
  }
  function i(e4, t4, n4, r3, i2, s2, a2) {
    return o2(t4 & n4 | ~t4 & r3, e4, t4, i2, s2, a2);
  }
  function s(e4, t4, n4, r3, i2, s2, a2) {
    return o2(t4 & r3 | n4 & ~r3, e4, t4, i2, s2, a2);
  }
  function a(e4, t4, n4, r3, i2, s2, a2) {
    return o2(t4 ^ n4 ^ r3, e4, t4, i2, s2, a2);
  }
  function u(e4, t4, n4, r3, i2, s2, a2) {
    return o2(n4 ^ (t4 | ~r3), e4, t4, i2, s2, a2);
  }
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = void 0;
  t3.default = function(e4) {
    if (typeof e4 == "string") {
      const t4 = unescape(encodeURIComponent(e4));
      e4 = new Uint8Array(t4.length);
      for (let n4 = 0; n4 < t4.length; ++n4)
        e4[n4] = t4.charCodeAt(n4);
    }
    return function(e5) {
      const t4 = [], n4 = 32 * e5.length, r3 = "0123456789abcdef";
      for (let o3 = 0; o3 < n4; o3 += 8) {
        const n5 = e5[o3 >> 5] >>> o3 % 32 & 255, i2 = parseInt(r3.charAt(n5 >>> 4 & 15) + r3.charAt(15 & n5), 16);
        t4.push(i2);
      }
      return t4;
    }(function(e5, t4) {
      e5[t4 >> 5] |= 128 << t4 % 32, e5[n3(t4) - 1] = t4;
      let o3 = 1732584193, c = -271733879, f = -1732584194, l = 271733878;
      for (let t5 = 0; t5 < e5.length; t5 += 16) {
        const n4 = o3, d = c, h = f, p = l;
        o3 = i(o3, c, f, l, e5[t5], 7, -680876936), l = i(l, o3, c, f, e5[t5 + 1], 12, -389564586), f = i(f, l, o3, c, e5[t5 + 2], 17, 606105819), c = i(c, f, l, o3, e5[t5 + 3], 22, -1044525330), o3 = i(o3, c, f, l, e5[t5 + 4], 7, -176418897), l = i(l, o3, c, f, e5[t5 + 5], 12, 1200080426), f = i(f, l, o3, c, e5[t5 + 6], 17, -1473231341), c = i(c, f, l, o3, e5[t5 + 7], 22, -45705983), o3 = i(o3, c, f, l, e5[t5 + 8], 7, 1770035416), l = i(l, o3, c, f, e5[t5 + 9], 12, -1958414417), f = i(f, l, o3, c, e5[t5 + 10], 17, -42063), c = i(c, f, l, o3, e5[t5 + 11], 22, -1990404162), o3 = i(o3, c, f, l, e5[t5 + 12], 7, 1804603682), l = i(l, o3, c, f, e5[t5 + 13], 12, -40341101), f = i(f, l, o3, c, e5[t5 + 14], 17, -1502002290), c = i(c, f, l, o3, e5[t5 + 15], 22, 1236535329), o3 = s(o3, c, f, l, e5[t5 + 1], 5, -165796510), l = s(l, o3, c, f, e5[t5 + 6], 9, -1069501632), f = s(f, l, o3, c, e5[t5 + 11], 14, 643717713), c = s(c, f, l, o3, e5[t5], 20, -373897302), o3 = s(o3, c, f, l, e5[t5 + 5], 5, -701558691), l = s(l, o3, c, f, e5[t5 + 10], 9, 38016083), f = s(f, l, o3, c, e5[t5 + 15], 14, -660478335), c = s(c, f, l, o3, e5[t5 + 4], 20, -405537848), o3 = s(o3, c, f, l, e5[t5 + 9], 5, 568446438), l = s(l, o3, c, f, e5[t5 + 14], 9, -1019803690), f = s(f, l, o3, c, e5[t5 + 3], 14, -187363961), c = s(c, f, l, o3, e5[t5 + 8], 20, 1163531501), o3 = s(o3, c, f, l, e5[t5 + 13], 5, -1444681467), l = s(l, o3, c, f, e5[t5 + 2], 9, -51403784), f = s(f, l, o3, c, e5[t5 + 7], 14, 1735328473), c = s(c, f, l, o3, e5[t5 + 12], 20, -1926607734), o3 = a(o3, c, f, l, e5[t5 + 5], 4, -378558), l = a(l, o3, c, f, e5[t5 + 8], 11, -2022574463), f = a(f, l, o3, c, e5[t5 + 11], 16, 1839030562), c = a(c, f, l, o3, e5[t5 + 14], 23, -35309556), o3 = a(o3, c, f, l, e5[t5 + 1], 4, -1530992060), l = a(l, o3, c, f, e5[t5 + 4], 11, 1272893353), f = a(f, l, o3, c, e5[t5 + 7], 16, -155497632), c = a(c, f, l, o3, e5[t5 + 10], 23, -1094730640), o3 = a(o3, c, f, l, e5[t5 + 13], 4, 681279174), l = a(l, o3, c, f, e5[t5], 11, -358537222), f = a(f, l, o3, c, e5[t5 + 3], 16, -722521979), c = a(c, f, l, o3, e5[t5 + 6], 23, 76029189), o3 = a(o3, c, f, l, e5[t5 + 9], 4, -640364487), l = a(l, o3, c, f, e5[t5 + 12], 11, -421815835), f = a(f, l, o3, c, e5[t5 + 15], 16, 530742520), c = a(c, f, l, o3, e5[t5 + 2], 23, -995338651), o3 = u(o3, c, f, l, e5[t5], 6, -198630844), l = u(l, o3, c, f, e5[t5 + 7], 10, 1126891415), f = u(f, l, o3, c, e5[t5 + 14], 15, -1416354905), c = u(c, f, l, o3, e5[t5 + 5], 21, -57434055), o3 = u(o3, c, f, l, e5[t5 + 12], 6, 1700485571), l = u(l, o3, c, f, e5[t5 + 3], 10, -1894986606), f = u(f, l, o3, c, e5[t5 + 10], 15, -1051523), c = u(c, f, l, o3, e5[t5 + 1], 21, -2054922799), o3 = u(o3, c, f, l, e5[t5 + 8], 6, 1873313359), l = u(l, o3, c, f, e5[t5 + 15], 10, -30611744), f = u(f, l, o3, c, e5[t5 + 6], 15, -1560198380), c = u(c, f, l, o3, e5[t5 + 13], 21, 1309151649), o3 = u(o3, c, f, l, e5[t5 + 4], 6, -145523070), l = u(l, o3, c, f, e5[t5 + 11], 10, -1120210379), f = u(f, l, o3, c, e5[t5 + 2], 15, 718787259), c = u(c, f, l, o3, e5[t5 + 9], 21, -343485551), o3 = r2(o3, n4), c = r2(c, d), f = r2(f, h), l = r2(l, p);
      }
      return [o3, c, f, l];
    }(function(e5) {
      if (e5.length === 0)
        return [];
      const t4 = 8 * e5.length, r3 = new Uint32Array(n3(t4));
      for (let n4 = 0; n4 < t4; n4 += 8)
        r3[n4 >> 5] |= (255 & e5[n4 / 8]) << n4 % 32;
      return r3;
    }(e4), 8 * e4.length));
  };
}, 827: (e3, t3) => {
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = function() {
    if (!n3)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return n3(r2);
  };
  const n3 = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), r2 = new Uint8Array(16);
}, 558: (e3, t3) => {
  function n3(e4, t4, n4, r3) {
    switch (e4) {
      case 0:
        return t4 & n4 ^ ~t4 & r3;
      case 1:
      case 3:
        return t4 ^ n4 ^ r3;
      case 2:
        return t4 & n4 ^ t4 & r3 ^ n4 & r3;
    }
  }
  function r2(e4, t4) {
    return e4 << t4 | e4 >>> 32 - t4;
  }
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = void 0;
  t3.default = function(e4) {
    const t4 = [1518500249, 1859775393, 2400959708, 3395469782], o2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof e4 == "string") {
      const t5 = unescape(encodeURIComponent(e4));
      e4 = [];
      for (let n4 = 0; n4 < t5.length; ++n4)
        e4.push(t5.charCodeAt(n4));
    }
    e4.push(128);
    const i = e4.length / 4 + 2, s = Math.ceil(i / 16), a = new Array(s);
    for (let t5 = 0; t5 < s; ++t5) {
      const n4 = new Uint32Array(16);
      for (let r3 = 0; r3 < 16; ++r3)
        n4[r3] = e4[64 * t5 + 4 * r3] << 24 | e4[64 * t5 + 4 * r3 + 1] << 16 | e4[64 * t5 + 4 * r3 + 2] << 8 | e4[64 * t5 + 4 * r3 + 3];
      a[t5] = n4;
    }
    a[s - 1][14] = 8 * (e4.length - 1) / Math.pow(2, 32), a[s - 1][14] = Math.floor(a[s - 1][14]), a[s - 1][15] = 8 * (e4.length - 1) & 4294967295;
    for (let e5 = 0; e5 < s; ++e5) {
      const i2 = new Uint32Array(80);
      for (let t5 = 0; t5 < 16; ++t5)
        i2[t5] = a[e5][t5];
      for (let e6 = 16; e6 < 80; ++e6)
        i2[e6] = r2(i2[e6 - 3] ^ i2[e6 - 8] ^ i2[e6 - 14] ^ i2[e6 - 16], 1);
      let s2 = o2[0], u = o2[1], c = o2[2], f = o2[3], l = o2[4];
      for (let e6 = 0; e6 < 80; ++e6) {
        const o3 = Math.floor(e6 / 20), a2 = r2(s2, 5) + n3(o3, u, c, f) + l + t4[o3] + i2[e6] >>> 0;
        l = f, f = c, c = r2(u, 30) >>> 0, u = s2, s2 = a2;
      }
      o2[0] = o2[0] + s2 >>> 0, o2[1] = o2[1] + u >>> 0, o2[2] = o2[2] + c >>> 0, o2[3] = o2[3] + f >>> 0, o2[4] = o2[4] + l >>> 0;
    }
    return [o2[0] >> 24 & 255, o2[0] >> 16 & 255, o2[0] >> 8 & 255, 255 & o2[0], o2[1] >> 24 & 255, o2[1] >> 16 & 255, o2[1] >> 8 & 255, 255 & o2[1], o2[2] >> 24 & 255, o2[2] >> 16 & 255, o2[2] >> 8 & 255, 255 & o2[2], o2[3] >> 24 & 255, o2[3] >> 16 & 255, o2[3] >> 8 & 255, 255 & o2[3], o2[4] >> 24 & 255, o2[4] >> 16 & 255, o2[4] >> 8 & 255, 255 & o2[4]];
  };
}, 922: (e3, t3, n3) => {
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = void 0;
  var r2 = i(n3(827)), o2 = i(n3(825));
  function i(e4) {
    return e4 && e4.__esModule ? e4 : { default: e4 };
  }
  let s, a, u = 0, c = 0;
  t3.default = function(e4, t4, n4) {
    let i2 = t4 && n4 || 0;
    const f = t4 || [];
    let l = (e4 = e4 || {}).node || s, d = e4.clockseq !== void 0 ? e4.clockseq : a;
    if (l == null || d == null) {
      const t5 = e4.random || (e4.rng || r2.default)();
      l == null && (l = s = [1 | t5[0], t5[1], t5[2], t5[3], t5[4], t5[5]]), d == null && (d = a = 16383 & (t5[6] << 8 | t5[7]));
    }
    let h = e4.msecs !== void 0 ? e4.msecs : Date.now(), p = e4.nsecs !== void 0 ? e4.nsecs : c + 1;
    const v = h - u + (p - c) / 1e4;
    if (v < 0 && e4.clockseq === void 0 && (d = d + 1 & 16383), (v < 0 || h > u) && e4.nsecs === void 0 && (p = 0), p >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    u = h, c = p, a = d, h += 122192928e5;
    const y = (1e4 * (268435455 & h) + p) % 4294967296;
    f[i2++] = y >>> 24 & 255, f[i2++] = y >>> 16 & 255, f[i2++] = y >>> 8 & 255, f[i2++] = 255 & y;
    const _ = h / 4294967296 * 1e4 & 268435455;
    f[i2++] = _ >>> 8 & 255, f[i2++] = 255 & _, f[i2++] = _ >>> 24 & 15 | 16, f[i2++] = _ >>> 16 & 255, f[i2++] = d >>> 8 | 128, f[i2++] = 255 & d;
    for (let e5 = 0; e5 < 6; ++e5)
      f[i2 + e5] = l[e5];
    return t4 || (0, o2.default)(f);
  };
}, 964: (e3, t3, n3) => {
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = void 0;
  var r2 = i(n3(137)), o2 = i(n3(489));
  function i(e4) {
    return e4 && e4.__esModule ? e4 : { default: e4 };
  }
  var s = (0, r2.default)("v3", 48, o2.default);
  t3.default = s;
}, 137: (e3, t3, n3) => {
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = function(e4, t4, n4) {
    function r3(e5, r4, i2, s2) {
      const a = i2 && s2 || 0;
      if (typeof e5 == "string" && (e5 = function(e6) {
        e6 = unescape(encodeURIComponent(e6));
        const t5 = [];
        for (let n5 = 0; n5 < e6.length; ++n5)
          t5.push(e6.charCodeAt(n5));
        return t5;
      }(e5)), typeof r4 == "string" && (r4 = function(e6) {
        const t5 = [];
        return e6.replace(/[a-fA-F0-9]{2}/g, function(e7) {
          t5.push(parseInt(e7, 16));
        }), t5;
      }(r4)), !Array.isArray(e5))
        throw TypeError("value must be an array of bytes");
      if (!Array.isArray(r4) || r4.length !== 16)
        throw TypeError("namespace must be uuid string or an Array of 16 byte values");
      const u = n4(r4.concat(e5));
      if (u[6] = 15 & u[6] | t4, u[8] = 63 & u[8] | 128, i2)
        for (let e6 = 0; e6 < 16; ++e6)
          i2[a + e6] = u[e6];
      return i2 || (0, o2.default)(u);
    }
    try {
      r3.name = e4;
    } catch (e5) {
    }
    return r3.DNS = i, r3.URL = s, r3;
  }, t3.URL = t3.DNS = void 0;
  var r2, o2 = (r2 = n3(825)) && r2.__esModule ? r2 : { default: r2 };
  const i = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  t3.DNS = i;
  const s = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  t3.URL = s;
}, 509: (e3, t3, n3) => {
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = void 0;
  var r2 = i(n3(827)), o2 = i(n3(825));
  function i(e4) {
    return e4 && e4.__esModule ? e4 : { default: e4 };
  }
  t3.default = function(e4, t4, n4) {
    typeof e4 == "string" && (t4 = e4 === "binary" ? new Uint8Array(16) : null, e4 = null);
    const i2 = (e4 = e4 || {}).random || (e4.rng || r2.default)();
    if (i2[6] = 15 & i2[6] | 64, i2[8] = 63 & i2[8] | 128, t4) {
      const e5 = n4 || 0;
      for (let n5 = 0; n5 < 16; ++n5)
        t4[e5 + n5] = i2[n5];
      return t4;
    }
    return (0, o2.default)(i2);
  };
}, 669: (e3, t3, n3) => {
  Object.defineProperty(t3, "__esModule", { value: true }), t3.default = void 0;
  var r2 = i(n3(137)), o2 = i(n3(558));
  function i(e4) {
    return e4 && e4.__esModule ? e4 : { default: e4 };
  }
  var s = (0, r2.default)("v5", 80, o2.default);
  t3.default = s;
}, 684: (e3, t3) => {
  function n3(e4, t4, n4) {
    var r2 = n4[n4.length - 1];
    e4 === r2.element && (n4.pop(), r2 = n4[n4.length - 1]);
    var o2 = r2.element, i = r2.index;
    Array.isArray(o2) ? o2.push(e4) : i === t4.length - 2 ? o2[t4.pop()] = e4 : t4.push(e4);
  }
  t3.stringify = function(e4) {
    var t4 = [];
    t4.push({ obj: e4 });
    for (var n4, r2, o2, i, s, a, u, c, f, l, d = ""; n4 = t4.pop(); )
      if (r2 = n4.obj, d += n4.prefix || "", o2 = n4.val || "")
        d += o2;
      else if (typeof r2 != "object")
        d += r2 === void 0 ? null : JSON.stringify(r2);
      else if (r2 === null)
        d += "null";
      else if (Array.isArray(r2)) {
        for (t4.push({ val: "]" }), i = r2.length - 1; i >= 0; i--)
          s = i === 0 ? "" : ",", t4.push({ obj: r2[i], prefix: s });
        t4.push({ val: "[" });
      } else {
        for (u in a = [], r2)
          r2.hasOwnProperty(u) && a.push(u);
        for (t4.push({ val: "}" }), i = a.length - 1; i >= 0; i--)
          f = r2[c = a[i]], l = i > 0 ? "," : "", l += JSON.stringify(c) + ":", t4.push({ obj: f, prefix: l });
        t4.push({ val: "{" });
      }
    return d;
  }, t3.parse = function(e4) {
    for (var t4, r2, o2, i, s, a, u, c, f, l = [], d = [], h = 0; ; )
      if ((t4 = e4[h++]) !== "}" && t4 !== "]" && t4 !== void 0)
        switch (t4) {
          case " ":
          case "	":
          case "\n":
          case ":":
          case ",":
            break;
          case "n":
            h += 3, n3(null, l, d);
            break;
          case "t":
            h += 3, n3(true, l, d);
            break;
          case "f":
            h += 4, n3(false, l, d);
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
          case "-":
            for (r2 = "", h--; ; ) {
              if (o2 = e4[h++], !/[\d\.\-e\+]/.test(o2)) {
                h--;
                break;
              }
              r2 += o2;
            }
            n3(parseFloat(r2), l, d);
            break;
          case '"':
            for (i = "", s = void 0, a = 0; (u = e4[h++]) !== '"' || s === "\\" && a % 2 == 1; )
              i += u, (s = u) === "\\" ? a++ : a = 0;
            n3(JSON.parse('"' + i + '"'), l, d);
            break;
          case "[":
            c = { element: [], index: l.length }, l.push(c.element), d.push(c);
            break;
          case "{":
            f = { element: {}, index: l.length }, l.push(f.element), d.push(f);
            break;
          default:
            throw new Error("unexpectedly reached end of input: " + t4);
        }
      else {
        if (l.length === 1)
          return l.pop();
        n3(l.pop(), l, d);
      }
  };
}, 525: () => {
} };
var t = {};
function n(r2) {
  var o2 = t[r2];
  if (o2 !== void 0)
    return o2.exports;
  var i = t[r2] = { exports: {} };
  return e[r2](i, i.exports, n), i.exports;
}
n.n = (e3) => {
  var t3 = e3 && e3.__esModule ? () => e3.default : () => e3;
  return n.d(t3, { a: t3 }), t3;
}, n.d = (e3, t3) => {
  for (var r2 in t3)
    n.o(t3, r2) && !n.o(e3, r2) && Object.defineProperty(e3, r2, { enumerable: true, get: t3[r2] });
}, n.g = function() {
  if (typeof globalThis == "object")
    return globalThis;
  try {
    return this || new Function("return this")();
  } catch (e3) {
    if (typeof window == "object")
      return window;
  }
}(), n.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3);
var r = {};
(() => {
  n.d(r, { o: () => cr });
  var e3 = n(624), t3 = n.n(e3), o2 = n(593);
  o2.v1, o2.v3;
  const i = o2.v4;
  o2.v5;
  var s, a, u = n(322), c = n.n(u), f = n(684), l = n(105), d = n.n(l), h = n(717), p = n.n(h), v = n(187), y = n.n(v);
  function _(e4) {
    return "$" + e4;
  }
  function g(e4) {
    return e4.substring(1);
  }
  function m() {
    this._store = {};
  }
  function b(e4) {
    if (this._store = new m(), e4 && Array.isArray(e4))
      for (var t4 = 0, n3 = e4.length; t4 < n3; t4++)
        this.add(e4[t4]);
  }
  m.prototype.get = function(e4) {
    var t4 = _(e4);
    return this._store[t4];
  }, m.prototype.set = function(e4, t4) {
    var n3 = _(e4);
    return this._store[n3] = t4, true;
  }, m.prototype.has = function(e4) {
    return _(e4) in this._store;
  }, m.prototype.delete = function(e4) {
    var t4 = _(e4), n3 = t4 in this._store;
    return delete this._store[t4], n3;
  }, m.prototype.forEach = function(e4) {
    for (var t4 = Object.keys(this._store), n3 = 0, r2 = t4.length; n3 < r2; n3++) {
      var o3 = t4[n3];
      e4(this._store[o3], o3 = g(o3));
    }
  }, Object.defineProperty(m.prototype, "size", { get: function() {
    return Object.keys(this._store).length;
  } }), b.prototype.add = function(e4) {
    return this._store.set(e4, true);
  }, b.prototype.has = function(e4) {
    return this._store.has(e4);
  }, b.prototype.forEach = function(e4) {
    this._store.forEach(function(t4, n3) {
      e4(n3);
    });
  }, Object.defineProperty(b.prototype, "size", { get: function() {
    return this._store.size;
  } }), function() {
    if (typeof Symbol == "undefined" || typeof Map == "undefined" || typeof Set == "undefined")
      return false;
    var e4 = Object.getOwnPropertyDescriptor(Map, Symbol.species);
    return e4 && "get" in e4 && Map[Symbol.species] === Map;
  }() ? (s = Set, a = Map) : (s = b, a = m);
  var w, k = Function.prototype.toString, j = k.call(Object);
  function O(e4) {
    var t4, n3, r2;
    if (!e4 || typeof e4 != "object")
      return e4;
    if (Array.isArray(e4)) {
      for (t4 = [], n3 = 0, r2 = e4.length; n3 < r2; n3++)
        t4[n3] = O(e4[n3]);
      return t4;
    }
    if (e4 instanceof Date)
      return e4.toISOString();
    if (function(e5) {
      return typeof ArrayBuffer != "undefined" && e5 instanceof ArrayBuffer || typeof Blob != "undefined" && e5 instanceof Blob;
    }(e4))
      return function(e5) {
        if (e5 instanceof ArrayBuffer)
          return function(e6) {
            if (typeof e6.slice == "function")
              return e6.slice(0);
            var t6 = new ArrayBuffer(e6.byteLength), n5 = new Uint8Array(t6), r3 = new Uint8Array(e6);
            return n5.set(r3), t6;
          }(e5);
        var t5 = e5.size, n4 = e5.type;
        return typeof e5.slice == "function" ? e5.slice(0, t5, n4) : e5.webkitSlice(0, t5, n4);
      }(e4);
    if (!function(e5) {
      var t5 = Object.getPrototypeOf(e5);
      if (t5 === null)
        return true;
      var n4 = t5.constructor;
      return typeof n4 == "function" && n4 instanceof n4 && k.call(n4) == j;
    }(e4))
      return e4;
    for (n3 in t4 = {}, e4)
      if (Object.prototype.hasOwnProperty.call(e4, n3)) {
        var o3 = O(e4[n3]);
        o3 !== void 0 && (t4[n3] = o3);
      }
    return t4;
  }
  function A(e4) {
    var t4 = false;
    return d()(function(n3) {
      if (t4)
        throw new Error("once called more than once");
      t4 = true, e4.apply(this, n3);
    });
  }
  function q(e4) {
    return d()(function(t4) {
      t4 = O(t4);
      var n3 = this, r2 = typeof t4[t4.length - 1] == "function" && t4.pop(), o3 = new Promise(function(r3, o4) {
        var i2;
        try {
          var s2 = A(function(e5, t5) {
            e5 ? o4(e5) : r3(t5);
          });
          t4.push(s2), (i2 = e4.apply(n3, t4)) && typeof i2.then == "function" && r3(i2);
        } catch (e5) {
          o4(e5);
        }
      });
      return r2 && o3.then(function(e5) {
        r2(null, e5);
      }, r2), o3;
    });
  }
  function S(e4, t4) {
    return q(d()(function(n3) {
      if (this._closed)
        return Promise.reject(new Error("database is closed"));
      if (this._destroyed)
        return Promise.reject(new Error("database is destroyed"));
      var r2 = this;
      return function(e5, t5, n4) {
        if (e5.constructor.listeners("debug").length) {
          for (var r3 = ["api", e5.name, t5], o3 = 0; o3 < n4.length - 1; o3++)
            r3.push(n4[o3]);
          e5.constructor.emit("debug", r3);
          var i2 = n4[n4.length - 1];
          n4[n4.length - 1] = function(n5, r4) {
            var o4 = ["api", e5.name, t5];
            o4 = o4.concat(n5 ? ["error", n5] : ["success", r4]), e5.constructor.emit("debug", o4), i2(n5, r4);
          };
        }
      }(r2, e4, n3), this.taskqueue.isReady ? t4.apply(this, n3) : new Promise(function(t5, o3) {
        r2.taskqueue.addTask(function(i2) {
          i2 ? o3(i2) : t5(r2[e4].apply(r2, n3));
        });
      });
    }));
  }
  function x(e4, t4) {
    for (var n3 = {}, r2 = 0, o3 = t4.length; r2 < o3; r2++) {
      var i2 = t4[r2];
      i2 in e4 && (n3[i2] = e4[i2]);
    }
    return n3;
  }
  function E(e4) {
    return e4;
  }
  function C(e4) {
    return [{ ok: e4 }];
  }
  function P(e4, t4, n3) {
    var r2 = t4.docs, o3 = new a();
    r2.forEach(function(e5) {
      o3.has(e5.id) ? o3.get(e5.id).push(e5) : o3.set(e5.id, [e5]);
    });
    var i2 = o3.size, s2 = 0, u2 = new Array(i2);
    var c2 = [];
    o3.forEach(function(e5, t5) {
      c2.push(t5);
    });
    var f2 = 0;
    !function r3() {
      if (!(f2 >= c2.length)) {
        var a2 = Math.min(f2 + 6, c2.length), l2 = c2.slice(f2, a2);
        !function(a3, c3) {
          a3.forEach(function(a4, f3) {
            var l3 = c3 + f3, d2 = o3.get(a4), h2 = x(d2[0], ["atts_since", "attachments"]);
            h2.open_revs = d2.map(function(e5) {
              return e5.rev;
            }), h2.open_revs = h2.open_revs.filter(E);
            var p2 = E;
            h2.open_revs.length === 0 && (delete h2.open_revs, p2 = C), ["revs", "attachments", "binary", "ajax", "latest"].forEach(function(e5) {
              e5 in t4 && (h2[e5] = t4[e5]);
            }), e4.get(a4, h2, function(e5, t5) {
              var o4, c4, f4, d3;
              o4 = e5 ? [{ error: e5 }] : p2(t5), c4 = a4, f4 = o4, u2[l3] = { id: c4, docs: f4 }, ++s2 === i2 && (d3 = [], u2.forEach(function(e6) {
                e6.docs.forEach(function(t6) {
                  d3.push({ id: e6.id, docs: [t6] });
                });
              }), n3(null, { results: d3 })), r3();
            });
          });
        }(l2, f2), f2 += l2.length;
      }
    }();
  }
  try {
    localStorage.setItem("_pouch_check_localstorage", 1), w = !!localStorage.getItem("_pouch_check_localstorage");
  } catch (e4) {
    w = false;
  }
  function L() {
    return w;
  }
  function D() {
    y().call(this), this._listeners = {}, function(e4) {
      L() && addEventListener("storage", function(t4) {
        e4.emit(t4.key);
      });
    }(this);
  }
  function $(e4) {
    if (typeof console != "undefined" && typeof console[e4] == "function") {
      var t4 = Array.prototype.slice.call(arguments, 1);
      console[e4].apply(console, t4);
    }
  }
  function I(e4) {
    var t4 = 0;
    return e4 || (t4 = 2e3), function(e5, t5) {
      var n3 = 6e5;
      return e5 = parseInt(e5, 10) || 0, (t5 = parseInt(t5, 10)) != t5 || t5 <= e5 ? t5 = (e5 || 1) << 1 : t5 += 1, t5 > n3 && (e5 = 3e5, t5 = n3), ~~((t5 - e5) * Math.random() + e5);
    }(e4, t4);
  }
  function B(e4, t4) {
    $("info", "The above " + e4 + " is totally normal. " + t4);
  }
  p()(D, y()), D.prototype.addListener = function(e4, n3, r2, o3) {
    if (!this._listeners[n3]) {
      var i2 = this, s2 = false;
      this._listeners[n3] = a2, this.on(e4, a2);
    }
    function a2() {
      if (i2._listeners[n3])
        if (s2)
          s2 = "waiting";
        else {
          s2 = true;
          var e5 = x(o3, ["style", "include_docs", "attachments", "conflicts", "filter", "doc_ids", "view", "since", "query_params", "binary", "return_docs"]);
          r2.changes(e5).on("change", function(e6) {
            e6.seq > o3.since && !o3.cancelled && (o3.since = e6.seq, o3.onChange(e6));
          }).on("complete", function() {
            s2 === "waiting" && t3()(a2), s2 = false;
          }).on("error", function() {
            s2 = false;
          });
        }
    }
  }, D.prototype.removeListener = function(e4, t4) {
    t4 in this._listeners && (y().prototype.removeListener.call(this, e4, this._listeners[t4]), delete this._listeners[t4]);
  }, D.prototype.notifyLocalWindows = function(e4) {
    L() && (localStorage[e4] = localStorage[e4] === "a" ? "b" : "a");
  }, D.prototype.notify = function(e4) {
    this.emit(e4), this.notifyLocalWindows(e4);
  };
  var R = typeof Object.assign == "function" ? Object.assign : function(e4) {
    for (var t4 = Object(e4), n3 = 1; n3 < arguments.length; n3++) {
      var r2 = arguments[n3];
      if (r2 != null)
        for (var o3 in r2)
          Object.prototype.hasOwnProperty.call(r2, o3) && (t4[o3] = r2[o3]);
    }
    return t4;
  };
  function T(e4, t4, n3) {
    Error.call(this, n3), this.status = e4, this.name = t4, this.message = n3, this.error = true;
  }
  p()(T, Error), T.prototype.toString = function() {
    return JSON.stringify({ status: this.status, name: this.name, message: this.message, reason: this.reason });
  }, new T(401, "unauthorized", "Name or password is incorrect.");
  var M = new T(400, "bad_request", "Missing JSON list of 'docs'"), N = new T(404, "not_found", "missing"), U = new T(409, "conflict", "Document update conflict"), F = new T(400, "bad_request", "_id field must contain a string"), K = new T(412, "missing_id", "_id is required for puts"), J = new T(400, "bad_request", "Only reserved document ids may start with underscore."), z = (new T(412, "precondition_failed", "Database not open"), new T(500, "unknown_error", "Database encountered an unknown error")), V = new T(500, "badarg", "Some query argument is invalid"), G = (new T(400, "invalid_request", "Request was invalid"), new T(400, "query_parse_error", "Some query parameter is invalid")), Q = new T(500, "doc_validation", "Bad special document member"), W = new T(400, "bad_request", "Something wrong with the request"), Y = new T(400, "bad_request", "Document must be a JSON object"), H = (new T(404, "not_found", "Database not found"), new T(500, "indexed_db_went_bad", "unknown")), X = (new T(500, "web_sql_went_bad", "unknown"), new T(500, "levelDB_went_went_bad", "unknown"), new T(403, "forbidden", "Forbidden by design doc validate_doc_update function"), new T(400, "bad_request", "Invalid rev format")), Z = (new T(412, "file_exists", "The database could not be created, the file already exists."), new T(412, "missing_stub", "A pre-existing attachment stub wasn't found"));
  function ee(e4, t4) {
    function n3(t5) {
      for (var n4 = Object.getOwnPropertyNames(e4), r2 = 0, o3 = n4.length; r2 < o3; r2++)
        typeof e4[n4[r2]] != "function" && (this[n4[r2]] = e4[n4[r2]]);
      t5 !== void 0 && (this.reason = t5);
    }
    return n3.prototype = T.prototype, new n3(t4);
  }
  function te(e4) {
    if (typeof e4 != "object") {
      var t4 = e4;
      (e4 = z).data = t4;
    }
    return "error" in e4 && e4.error === "conflict" && (e4.name = "conflict", e4.status = 409), "name" in e4 || (e4.name = e4.error || "unknown"), "status" in e4 || (e4.status = 500), "message" in e4 || (e4.message = e4.message || e4.reason), e4;
  }
  function ne(e4) {
    var t4 = {}, n3 = e4.filter && typeof e4.filter == "function";
    return t4.query = e4.query_params, function(r2) {
      r2.doc || (r2.doc = {});
      var o3 = n3 && function(e5, t5, n4) {
        try {
          return !e5(t5, n4);
        } catch (e6) {
          var r3 = "Filter function threw: " + e6.toString();
          return ee(W, r3);
        }
      }(e4.filter, r2.doc, t4);
      if (typeof o3 == "object")
        return o3;
      if (o3)
        return false;
      if (e4.include_docs) {
        if (!e4.attachments)
          for (var i2 in r2.doc._attachments)
            r2.doc._attachments.hasOwnProperty(i2) && (r2.doc._attachments[i2].stub = true);
      } else
        delete r2.doc;
      return true;
    };
  }
  function re(e4) {
    for (var t4 = [], n3 = 0, r2 = e4.length; n3 < r2; n3++)
      t4 = t4.concat(e4[n3]);
    return t4;
  }
  function oe(e4) {
    var t4;
    if (e4 ? typeof e4 != "string" ? t4 = ee(F) : /^_/.test(e4) && !/^_(design|local)/.test(e4) && (t4 = ee(J)) : t4 = ee(K), t4)
      throw t4;
  }
  function ie(e4) {
    return typeof e4._remote == "boolean" ? e4._remote : typeof e4.type == "function" && ($("warn", "db.type() is deprecated and will be removed in a future version of PouchDB"), e4.type() === "http");
  }
  function se(e4) {
    if (!e4)
      return null;
    var t4 = e4.split("/");
    return t4.length === 2 ? t4 : t4.length === 1 ? [e4, e4] : null;
  }
  function ae(e4) {
    var t4 = se(e4);
    return t4 ? t4.join("/") : null;
  }
  new T(413, "invalid_url", "Provided URL is invalid");
  var ue = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], ce = "queryKey", fe = /(?:^|&)([^&=]*)=?([^&]*)/g, le = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  function de(e4) {
    for (var t4 = le.exec(e4), n3 = {}, r2 = 14; r2--; ) {
      var o3 = ue[r2], i2 = t4[r2] || "", s2 = ["user", "password"].indexOf(o3) !== -1;
      n3[o3] = s2 ? decodeURIComponent(i2) : i2;
    }
    return n3[ce] = {}, n3[ue[12]].replace(fe, function(e5, t5, r3) {
      t5 && (n3[ce][t5] = r3);
    }), n3;
  }
  function he(e4, t4) {
    var n3 = [], r2 = [];
    for (var o3 in t4)
      t4.hasOwnProperty(o3) && (n3.push(o3), r2.push(t4[o3]));
    return n3.push(e4), Function.apply(null, n3).apply(null, r2);
  }
  function pe(e4, t4, n3) {
    return new Promise(function(r2, o3) {
      e4.get(t4, function(i2, s2) {
        if (i2) {
          if (i2.status !== 404)
            return o3(i2);
          s2 = {};
        }
        var a2 = s2._rev, u2 = n3(s2);
        if (!u2)
          return r2({ updated: false, rev: a2 });
        u2._id = t4, u2._rev = a2, r2(function(e5, t5, n4) {
          return e5.put(t5).then(function(e6) {
            return { updated: true, rev: e6.rev };
          }, function(r3) {
            if (r3.status !== 409)
              throw r3;
            return pe(e5, t5._id, n4);
          });
        }(e4, u2, n3));
      });
    });
  }
  var ve = function(e4) {
    return atob(e4);
  }, ye = function(e4) {
    return btoa(e4);
  };
  function _e(e4, t4) {
    e4 = e4 || [], t4 = t4 || {};
    try {
      return new Blob(e4, t4);
    } catch (o3) {
      if (o3.name !== "TypeError")
        throw o3;
      for (var n3 = new (typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder)(), r2 = 0; r2 < e4.length; r2 += 1)
        n3.append(e4[r2]);
      return n3.getBlob(t4.type);
    }
  }
  function ge(e4) {
    for (var t4 = e4.length, n3 = new ArrayBuffer(t4), r2 = new Uint8Array(n3), o3 = 0; o3 < t4; o3++)
      r2[o3] = e4.charCodeAt(o3);
    return n3;
  }
  function me(e4, t4) {
    return _e([ge(e4)], { type: t4 });
  }
  function be(e4, t4) {
    return me(ve(e4), t4);
  }
  function we(e4, t4) {
    var n3 = new FileReader(), r2 = typeof n3.readAsBinaryString == "function";
    n3.onloadend = function(e5) {
      var n4 = e5.target.result || "";
      if (r2)
        return t4(n4);
      t4(function(e6) {
        for (var t5 = "", n5 = new Uint8Array(e6), r3 = n5.byteLength, o3 = 0; o3 < r3; o3++)
          t5 += String.fromCharCode(n5[o3]);
        return t5;
      }(n4));
    }, r2 ? n3.readAsBinaryString(e4) : n3.readAsArrayBuffer(e4);
  }
  function ke(e4, t4) {
    we(e4, function(e5) {
      t4(e5);
    });
  }
  function je(e4, t4) {
    ke(e4, function(e5) {
      t4(ye(e5));
    });
  }
  var Oe = self.setImmediate || self.setTimeout;
  function Ae(e4, t4, n3, r2, o3) {
    (n3 > 0 || r2 < t4.size) && (t4 = function(e5, t5, n4) {
      return e5.webkitSlice ? e5.webkitSlice(t5, n4) : e5.slice(t5, n4);
    }(t4, n3, r2)), function(e5, t5) {
      var n4 = new FileReader();
      n4.onloadend = function(e6) {
        var n5 = e6.target.result || new ArrayBuffer(0);
        t5(n5);
      }, n4.readAsArrayBuffer(e5);
    }(t4, function(t5) {
      e4.append(t5), o3();
    });
  }
  function qe(e4, t4, n3, r2, o3) {
    (n3 > 0 || r2 < t4.length) && (t4 = t4.substring(n3, r2)), e4.appendBinary(t4), o3();
  }
  function Se(e4, t4) {
    var n3 = typeof e4 == "string", r2 = n3 ? e4.length : e4.size, o3 = Math.min(32768, r2), i2 = Math.ceil(r2 / o3), s2 = 0, a2 = n3 ? new (c())() : new (c()).ArrayBuffer(), u2 = n3 ? qe : Ae;
    function f2() {
      Oe(d2);
    }
    function l2() {
      var e5, n4 = (e5 = a2.end(true), ye(e5));
      t4(n4), a2.destroy();
    }
    function d2() {
      var t5 = s2 * o3;
      s2++, u2(a2, e4, t5, t5 + o3, s2 < i2 ? f2 : l2);
    }
    d2();
  }
  function xe(e4) {
    return c().hash(e4);
  }
  function Ee(e4, t4) {
    var n3 = O(e4);
    return t4 ? (delete n3._rev_tree, xe(JSON.stringify(n3))) : i().replace(/-/g, "").toLowerCase();
  }
  var Ce = i;
  function Pe(e4) {
    for (var t4, n3, r2, o3, i2 = e4.rev_tree.slice(); o3 = i2.pop(); ) {
      var s2 = o3.ids, a2 = s2[2], u2 = o3.pos;
      if (a2.length)
        for (var c2 = 0, f2 = a2.length; c2 < f2; c2++)
          i2.push({ pos: u2 + 1, ids: a2[c2] });
      else {
        var l2 = !!s2[1].deleted, d2 = s2[0];
        t4 && !(r2 !== l2 ? r2 : n3 !== u2 ? n3 < u2 : t4 < d2) || (t4 = d2, n3 = u2, r2 = l2);
      }
    }
    return n3 + "-" + t4;
  }
  function Le(e4, t4) {
    for (var n3, r2 = e4.slice(); n3 = r2.pop(); )
      for (var o3 = n3.pos, i2 = n3.ids, s2 = i2[2], a2 = t4(s2.length === 0, o3, i2[0], n3.ctx, i2[1]), u2 = 0, c2 = s2.length; u2 < c2; u2++)
        r2.push({ pos: o3 + 1, ids: s2[u2], ctx: a2 });
  }
  function De(e4, t4) {
    return e4.pos - t4.pos;
  }
  function $e(e4) {
    var t4 = [];
    Le(e4, function(e5, n4, r3, o3, i2) {
      e5 && t4.push({ rev: n4 + "-" + r3, pos: n4, opts: i2 });
    }), t4.sort(De).reverse();
    for (var n3 = 0, r2 = t4.length; n3 < r2; n3++)
      delete t4[n3].pos;
    return t4;
  }
  function Ie(e4) {
    for (var t4 = Pe(e4), n3 = $e(e4.rev_tree), r2 = [], o3 = 0, i2 = n3.length; o3 < i2; o3++) {
      var s2 = n3[o3];
      s2.rev === t4 || s2.opts.deleted || r2.push(s2.rev);
    }
    return r2;
  }
  function Be(e4) {
    for (var t4, n3 = [], r2 = e4.slice(); t4 = r2.pop(); ) {
      var o3 = t4.pos, i2 = t4.ids, s2 = i2[0], a2 = i2[1], u2 = i2[2], c2 = u2.length === 0, f2 = t4.history ? t4.history.slice() : [];
      f2.push({ id: s2, opts: a2 }), c2 && n3.push({ pos: o3 + 1 - f2.length, ids: f2 });
      for (var l2 = 0, d2 = u2.length; l2 < d2; l2++)
        r2.push({ pos: o3 + 1, ids: u2[l2], history: f2 });
    }
    return n3.reverse();
  }
  function Re(e4, t4) {
    return e4.pos - t4.pos;
  }
  function Te(e4, t4, n3) {
    var r2 = function(e5, t5, n4) {
      for (var r3, o3 = 0, i2 = e5.length; o3 < i2; )
        n4(e5[r3 = o3 + i2 >>> 1], t5) < 0 ? o3 = r3 + 1 : i2 = r3;
      return o3;
    }(e4, t4, n3);
    e4.splice(r2, 0, t4);
  }
  function Me(e4, t4) {
    for (var n3, r2, o3 = t4, i2 = e4.length; o3 < i2; o3++) {
      var s2 = e4[o3], a2 = [s2.id, s2.opts, []];
      r2 ? (r2[2].push(a2), r2 = a2) : n3 = r2 = a2;
    }
    return n3;
  }
  function Ne(e4, t4) {
    return e4[0] < t4[0] ? -1 : 1;
  }
  function Ue(e4, t4) {
    for (var n3 = [{ tree1: e4, tree2: t4 }], r2 = false; n3.length > 0; ) {
      var o3 = n3.pop(), i2 = o3.tree1, s2 = o3.tree2;
      (i2[1].status || s2[1].status) && (i2[1].status = i2[1].status === "available" || s2[1].status === "available" ? "available" : "missing");
      for (var a2 = 0; a2 < s2[2].length; a2++)
        if (i2[2][0]) {
          for (var u2 = false, c2 = 0; c2 < i2[2].length; c2++)
            i2[2][c2][0] === s2[2][a2][0] && (n3.push({ tree1: i2[2][c2], tree2: s2[2][a2] }), u2 = true);
          u2 || (r2 = "new_branch", Te(i2[2], s2[2][a2], Ne));
        } else
          r2 = "new_leaf", i2[2][0] = s2[2][a2];
    }
    return { conflicts: r2, tree: e4 };
  }
  function Fe(e4, t4, n3) {
    var r2, o3 = [], i2 = false, s2 = false;
    if (!e4.length)
      return { tree: [t4], conflicts: "new_leaf" };
    for (var a2 = 0, u2 = e4.length; a2 < u2; a2++) {
      var c2 = e4[a2];
      if (c2.pos === t4.pos && c2.ids[0] === t4.ids[0])
        r2 = Ue(c2.ids, t4.ids), o3.push({ pos: c2.pos, ids: r2.tree }), i2 = i2 || r2.conflicts, s2 = true;
      else if (n3 !== true) {
        var f2 = c2.pos < t4.pos ? c2 : t4, l2 = c2.pos < t4.pos ? t4 : c2, d2 = l2.pos - f2.pos, h2 = [], p2 = [];
        for (p2.push({ ids: f2.ids, diff: d2, parent: null, parentIdx: null }); p2.length > 0; ) {
          var v2 = p2.pop();
          if (v2.diff !== 0)
            for (var y2 = v2.ids[2], _2 = 0, g2 = y2.length; _2 < g2; _2++)
              p2.push({ ids: y2[_2], diff: v2.diff - 1, parent: v2.ids, parentIdx: _2 });
          else
            v2.ids[0] === l2.ids[0] && h2.push(v2);
        }
        var m2 = h2[0];
        m2 ? (r2 = Ue(m2.ids, l2.ids), m2.parent[2][m2.parentIdx] = r2.tree, o3.push({ pos: f2.pos, ids: f2.ids }), i2 = i2 || r2.conflicts, s2 = true) : o3.push(c2);
      } else
        o3.push(c2);
    }
    return s2 || o3.push(t4), o3.sort(Re), { tree: o3, conflicts: i2 || "internal_node" };
  }
  function Ke(e4, t4, n3) {
    var r2 = Fe(e4, t4), o3 = function(e5, t5) {
      for (var n4, r3, o4 = Be(e5), i2 = 0, s2 = o4.length; i2 < s2; i2++) {
        var a2, u2 = o4[i2], c2 = u2.ids;
        if (c2.length > t5) {
          n4 || (n4 = {});
          var f2 = c2.length - t5;
          a2 = { pos: u2.pos + f2, ids: Me(c2, f2) };
          for (var l2 = 0; l2 < f2; l2++) {
            var d2 = u2.pos + l2 + "-" + c2[l2].id;
            n4[d2] = true;
          }
        } else
          a2 = { pos: u2.pos, ids: Me(c2, 0) };
        r3 = r3 ? Fe(r3, a2, true).tree : [a2];
      }
      return n4 && Le(r3, function(e6, t6, r4) {
        delete n4[t6 + "-" + r4];
      }), { tree: r3, revs: n4 ? Object.keys(n4) : [] };
    }(r2.tree, n3);
    return { tree: o3.tree, stemmedRevs: o3.revs, conflicts: r2.conflicts };
  }
  function Je(e4) {
    return e4.ids;
  }
  function ze(e4, t4) {
    t4 || (t4 = Pe(e4));
    for (var n3, r2 = t4.substring(t4.indexOf("-") + 1), o3 = e4.rev_tree.map(Je); n3 = o3.pop(); ) {
      if (n3[0] === r2)
        return !!n3[1].deleted;
      o3 = o3.concat(n3[2]);
    }
  }
  function Ve(e4) {
    return /^_local/.test(e4);
  }
  function Ge(e4, t4, n3) {
    y().call(this);
    var r2 = this;
    this.db = e4;
    var o3 = (t4 = t4 ? O(t4) : {}).complete = A(function(t5, n4) {
      var o4, s3;
      t5 ? (s3 = "error", ("listenerCount" in (o4 = r2) ? o4.listenerCount(s3) : y().listenerCount(o4, s3)) > 0 && r2.emit("error", t5)) : r2.emit("complete", n4), r2.removeAllListeners(), e4.removeListener("destroyed", i2);
    });
    function i2() {
      r2.cancel();
    }
    n3 && (r2.on("complete", function(e5) {
      n3(null, e5);
    }), r2.on("error", n3)), e4.once("destroyed", i2), t4.onChange = function(e5, t5, n4) {
      r2.isCancelled || function(e6, t6, n5, r3) {
        try {
          e6.emit("change", t6, n5, r3);
        } catch (e7) {
          $("error", 'Error in .on("change", function):', e7);
        }
      }(r2, e5, t5, n4);
    };
    var s2 = new Promise(function(e5, n4) {
      t4.complete = function(t5, r3) {
        t5 ? n4(t5) : e5(r3);
      };
    });
    r2.once("cancel", function() {
      e4.removeListener("destroyed", i2), t4.complete(null, { status: "cancelled" });
    }), this.then = s2.then.bind(s2), this.catch = s2.catch.bind(s2), this.then(function(e5) {
      o3(null, e5);
    }, o3), e4.taskqueue.isReady ? r2.validateChanges(t4) : e4.taskqueue.addTask(function(e5) {
      e5 ? t4.complete(e5) : r2.isCancelled ? r2.emit("cancel") : r2.validateChanges(t4);
    });
  }
  function Qe(e4, t4, n3) {
    var r2 = [{ rev: e4._rev }];
    n3.style === "all_docs" && (r2 = $e(t4.rev_tree).map(function(e5) {
      return { rev: e5.rev };
    }));
    var o3 = { id: t4.id, changes: r2, doc: e4 };
    return ze(t4, e4._rev) && (o3.deleted = true), n3.conflicts && (o3.doc._conflicts = Ie(t4), o3.doc._conflicts.length || delete o3.doc._conflicts), o3;
  }
  function We(e4, t4) {
    return e4 < t4 ? -1 : e4 > t4 ? 1 : 0;
  }
  function Ye(e4, t4) {
    return function(n3, r2) {
      n3 || r2[0] && r2[0].error ? ((n3 = n3 || r2[0]).docId = t4, e4(n3)) : e4(null, r2.length ? r2[0] : r2);
    };
  }
  function He(e4, t4) {
    var n3 = We(e4._id, t4._id);
    return n3 !== 0 ? n3 : We(e4._revisions ? e4._revisions.start : 0, t4._revisions ? t4._revisions.start : 0);
  }
  function Xe(e4) {
    var n3 = e4._compactionQueue[0], r2 = n3.opts, o3 = n3.callback;
    e4.get("_local/compaction").catch(function() {
      return false;
    }).then(function(n4) {
      n4 && n4.last_seq && (r2.last_seq = n4.last_seq), e4._compact(r2, function(n5, r3) {
        n5 ? o3(n5) : o3(null, r3), t3()(function() {
          e4._compactionQueue.shift(), e4._compactionQueue.length && Xe(e4);
        });
      });
    });
  }
  function Ze() {
    for (var e4 in y().call(this), Ze.prototype)
      typeof this[e4] == "function" && (this[e4] = this[e4].bind(this));
  }
  function et() {
    this.isReady = false, this.failed = false, this.queue = [];
  }
  function tt(e4, t4) {
    if (!(this instanceof tt))
      return new tt(e4, t4);
    var n3 = this;
    if (t4 = t4 || {}, e4 && typeof e4 == "object" && (e4 = (t4 = e4).name, delete t4.name), t4.deterministic_revs === void 0 && (t4.deterministic_revs = true), this.__opts = t4 = O(t4), n3.auto_compaction = t4.auto_compaction, n3.prefix = tt.prefix, typeof e4 != "string")
      throw new Error("Missing/invalid DB name");
    var r2 = function(e5, t5) {
      var n4 = e5.match(/([a-z-]*):\/\/(.*)/);
      if (n4)
        return { name: /https?/.test(n4[1]) ? n4[1] + "://" + n4[2] : n4[2], adapter: n4[1] };
      var r3 = tt.adapters, o3 = tt.preferredAdapters, i2 = tt.prefix, s2 = t5.adapter;
      if (!s2)
        for (var a2 = 0; a2 < o3.length && (s2 = o3[a2]) === "idb" && "websql" in r3 && L() && localStorage["_pouch__websqldb_" + i2 + e5]; ++a2)
          $("log", 'PouchDB is downgrading "' + e5 + '" to WebSQL to avoid data loss, because it was already opened with WebSQL.');
      var u2 = r3[s2];
      return { name: u2 && "use_prefix" in u2 && !u2.use_prefix ? e5 : i2 + e5, adapter: s2 };
    }((t4.prefix || "") + e4, t4);
    if (t4.name = r2.name, t4.adapter = t4.adapter || r2.adapter, n3.name = e4, n3._adapter = t4.adapter, tt.emit("debug", ["adapter", "Picked adapter: ", t4.adapter]), !tt.adapters[t4.adapter] || !tt.adapters[t4.adapter].valid())
      throw new Error("Invalid Adapter: " + t4.adapter);
    Ze.call(n3), n3.taskqueue = new et(), n3.adapter = t4.adapter, tt.adapters[t4.adapter].call(n3, t4, function(e5) {
      if (e5)
        return n3.taskqueue.fail(e5);
      !function(e6) {
        function t5(t6) {
          e6.removeListener("closed", n4), t6 || e6.constructor.emit("destroyed", e6.name);
        }
        function n4() {
          e6.removeListener("destroyed", t5), e6.constructor.emit("unref", e6);
        }
        e6.once("destroyed", t5), e6.once("closed", n4), e6.constructor.emit("ref", e6);
      }(n3), n3.emit("created", n3), tt.emit("created", n3.name), n3.taskqueue.ready(n3);
    });
  }
  p()(Ge, y()), Ge.prototype.cancel = function() {
    this.isCancelled = true, this.db.taskqueue.isReady && this.emit("cancel");
  }, Ge.prototype.validateChanges = function(e4) {
    var t4 = e4.complete, n3 = this;
    tt._changesFilterPlugin ? tt._changesFilterPlugin.validate(e4, function(r2) {
      if (r2)
        return t4(r2);
      n3.doChanges(e4);
    }) : n3.doChanges(e4);
  }, Ge.prototype.doChanges = function(e4) {
    var t4 = this, n3 = e4.complete;
    if ("live" in (e4 = O(e4)) && !("continuous" in e4) && (e4.continuous = e4.live), e4.processChange = Qe, e4.since === "latest" && (e4.since = "now"), e4.since || (e4.since = 0), e4.since !== "now") {
      if (tt._changesFilterPlugin) {
        if (tt._changesFilterPlugin.normalize(e4), tt._changesFilterPlugin.shouldFilter(this, e4))
          return tt._changesFilterPlugin.filter(this, e4);
      } else
        ["doc_ids", "filter", "selector", "view"].forEach(function(t5) {
          t5 in e4 && $("warn", 'The "' + t5 + '" option was passed in to changes/replicate, but pouchdb-changes-filter plugin is not installed, so it was ignored. Please install the plugin to enable filtering.');
        });
      "descending" in e4 || (e4.descending = false), e4.limit = e4.limit === 0 ? 1 : e4.limit, e4.complete = n3;
      var r2 = this.db._changes(e4);
      if (r2 && typeof r2.cancel == "function") {
        var o3 = t4.cancel;
        t4.cancel = d()(function(e5) {
          r2.cancel(), o3.apply(this, e5);
        });
      }
    } else
      this.db.info().then(function(r3) {
        t4.isCancelled ? n3(null, { status: "cancelled" }) : (e4.since = r3.update_seq, t4.doChanges(e4));
      }, n3);
  }, p()(Ze, y()), Ze.prototype.post = S("post", function(e4, t4, n3) {
    if (typeof t4 == "function" && (n3 = t4, t4 = {}), typeof e4 != "object" || Array.isArray(e4))
      return n3(ee(Y));
    this.bulkDocs({ docs: [e4] }, t4, Ye(n3, e4._id));
  }), Ze.prototype.put = S("put", function(e4, t4, n3) {
    if (typeof t4 == "function" && (n3 = t4, t4 = {}), typeof e4 != "object" || Array.isArray(e4))
      return n3(ee(Y));
    if (oe(e4._id), Ve(e4._id) && typeof this._putLocal == "function")
      return e4._deleted ? this._removeLocal(e4, n3) : this._putLocal(e4, n3);
    var r2, o3, i2, s2, a2 = this;
    function u2(n4) {
      typeof a2._put == "function" && t4.new_edits !== false ? a2._put(e4, t4, n4) : a2.bulkDocs({ docs: [e4] }, t4, Ye(n4, e4._id));
    }
    t4.force && e4._rev ? (o3 = (r2 = e4._rev.split("-"))[1], i2 = parseInt(r2[0], 10) + 1, s2 = Ee(), e4._revisions = { start: i2, ids: [s2, o3] }, e4._rev = i2 + "-" + s2, t4.new_edits = false, u2(function(t5) {
      var r3 = t5 ? null : { ok: true, id: e4._id, rev: e4._rev };
      n3(t5, r3);
    })) : u2(n3);
  }), Ze.prototype.putAttachment = S("putAttachment", function(e4, t4, n3, r2, o3) {
    var i2 = this;
    function s2(e5) {
      var n4 = "_rev" in e5 ? parseInt(e5._rev, 10) : 0;
      return e5._attachments = e5._attachments || {}, e5._attachments[t4] = { content_type: o3, data: r2, revpos: ++n4 }, i2.put(e5);
    }
    return typeof o3 == "function" && (o3 = r2, r2 = n3, n3 = null), o3 === void 0 && (o3 = r2, r2 = n3, n3 = null), o3 || $("warn", "Attachment", t4, "on document", e4, "is missing content_type"), i2.get(e4).then(function(e5) {
      if (e5._rev !== n3)
        throw ee(U);
      return s2(e5);
    }, function(t5) {
      if (t5.reason === N.message)
        return s2({ _id: e4 });
      throw t5;
    });
  }), Ze.prototype.removeAttachment = S("removeAttachment", function(e4, t4, n3, r2) {
    var o3 = this;
    o3.get(e4, function(e5, i2) {
      if (e5)
        r2(e5);
      else if (i2._rev === n3) {
        if (!i2._attachments)
          return r2();
        delete i2._attachments[t4], Object.keys(i2._attachments).length === 0 && delete i2._attachments, o3.put(i2, r2);
      } else
        r2(ee(U));
    });
  }), Ze.prototype.remove = S("remove", function(e4, t4, n3, r2) {
    var o3;
    typeof t4 == "string" ? (o3 = { _id: e4, _rev: t4 }, typeof n3 == "function" && (r2 = n3, n3 = {})) : (o3 = e4, typeof t4 == "function" ? (r2 = t4, n3 = {}) : (r2 = n3, n3 = t4)), (n3 = n3 || {}).was_delete = true;
    var i2 = { _id: o3._id, _rev: o3._rev || n3.rev, _deleted: true };
    if (Ve(i2._id) && typeof this._removeLocal == "function")
      return this._removeLocal(o3, r2);
    this.bulkDocs({ docs: [i2] }, n3, Ye(r2, i2._id));
  }), Ze.prototype.revsDiff = S("revsDiff", function(e4, t4, n3) {
    typeof t4 == "function" && (n3 = t4, t4 = {});
    var r2 = Object.keys(e4);
    if (!r2.length)
      return n3(null, {});
    var o3 = 0, i2 = new a();
    function s2(e5, t5) {
      i2.has(e5) || i2.set(e5, { missing: [] }), i2.get(e5).missing.push(t5);
    }
    r2.map(function(t5) {
      this._getRevisionTree(t5, function(a2, u2) {
        if (a2 && a2.status === 404 && a2.message === "missing")
          i2.set(t5, { missing: e4[t5] });
        else {
          if (a2)
            return n3(a2);
          !function(t6, n4) {
            var r3 = e4[t6].slice(0);
            Le(n4, function(e5, n5, o4, i3, a3) {
              var u3 = n5 + "-" + o4, c3 = r3.indexOf(u3);
              c3 !== -1 && (r3.splice(c3, 1), a3.status !== "available" && s2(t6, u3));
            }), r3.forEach(function(e5) {
              s2(t6, e5);
            });
          }(t5, u2);
        }
        if (++o3 === r2.length) {
          var c2 = {};
          return i2.forEach(function(e5, t6) {
            c2[t6] = e5;
          }), n3(null, c2);
        }
      });
    }, this);
  }), Ze.prototype.bulkGet = S("bulkGet", function(e4, t4) {
    P(this, e4, t4);
  }), Ze.prototype.compactDocument = S("compactDocument", function(e4, t4, n3) {
    var r2 = this;
    this._getRevisionTree(e4, function(o3, i2) {
      if (o3)
        return n3(o3);
      var s2 = function(e5) {
        var t5 = {}, n4 = [];
        return Le(e5, function(e6, r3, o4, i3) {
          var s3 = r3 + "-" + o4;
          return e6 && (t5[s3] = 0), i3 !== void 0 && n4.push({ from: i3, to: s3 }), s3;
        }), n4.reverse(), n4.forEach(function(e6) {
          t5[e6.from] === void 0 ? t5[e6.from] = 1 + t5[e6.to] : t5[e6.from] = Math.min(t5[e6.from], 1 + t5[e6.to]);
        }), t5;
      }(i2), a2 = [], u2 = [];
      Object.keys(s2).forEach(function(e5) {
        s2[e5] > t4 && a2.push(e5);
      }), Le(i2, function(e5, t5, n4, r3, o4) {
        var i3 = t5 + "-" + n4;
        o4.status === "available" && a2.indexOf(i3) !== -1 && u2.push(i3);
      }), r2._doCompaction(e4, u2, n3);
    });
  }), Ze.prototype.compact = S("compact", function(e4, t4) {
    typeof e4 == "function" && (t4 = e4, e4 = {});
    var n3 = this;
    e4 = e4 || {}, n3._compactionQueue = n3._compactionQueue || [], n3._compactionQueue.push({ opts: e4, callback: t4 }), n3._compactionQueue.length === 1 && Xe(n3);
  }), Ze.prototype._compact = function(e4, t4) {
    var n3 = this, r2 = { return_docs: false, last_seq: e4.last_seq || 0 }, o3 = [];
    n3.changes(r2).on("change", function(e5) {
      o3.push(n3.compactDocument(e5.id, 0));
    }).on("complete", function(e5) {
      var r3 = e5.last_seq;
      Promise.all(o3).then(function() {
        return pe(n3, "_local/compaction", function(e6) {
          return (!e6.last_seq || e6.last_seq < r3) && (e6.last_seq = r3, e6);
        });
      }).then(function() {
        t4(null, { ok: true });
      }).catch(t4);
    }).on("error", t4);
  }, Ze.prototype.get = S("get", function(e4, t4, n3) {
    if (typeof t4 == "function" && (n3 = t4, t4 = {}), typeof e4 != "string")
      return n3(ee(F));
    if (Ve(e4) && typeof this._getLocal == "function")
      return this._getLocal(e4, n3);
    var r2 = [], o3 = this;
    function i2() {
      var i3 = [], s3 = r2.length;
      if (!s3)
        return n3(null, i3);
      r2.forEach(function(r3) {
        o3.get(e4, { rev: r3, revs: t4.revs, latest: t4.latest, attachments: t4.attachments, binary: t4.binary }, function(e5, t5) {
          if (e5)
            i3.push({ missing: r3 });
          else {
            for (var o4, a3 = 0, u2 = i3.length; a3 < u2; a3++)
              if (i3[a3].ok && i3[a3].ok._rev === t5._rev) {
                o4 = true;
                break;
              }
            o4 || i3.push({ ok: t5 });
          }
          --s3 || n3(null, i3);
        });
      });
    }
    if (!t4.open_revs)
      return this._get(e4, t4, function(r3, i3) {
        if (r3)
          return r3.docId = e4, n3(r3);
        var s3 = i3.doc, a3 = i3.metadata, u2 = i3.ctx;
        if (t4.conflicts) {
          var c2 = Ie(a3);
          c2.length && (s3._conflicts = c2);
        }
        if (ze(a3, s3._rev) && (s3._deleted = true), t4.revs || t4.revs_info) {
          for (var f2 = s3._rev.split("-"), l2 = parseInt(f2[0], 10), d2 = f2[1], h2 = Be(a3.rev_tree), p2 = null, v2 = 0; v2 < h2.length; v2++) {
            var y2 = h2[v2], _2 = y2.ids.map(function(e5) {
              return e5.id;
            }).indexOf(d2);
            (_2 === l2 - 1 || !p2 && _2 !== -1) && (p2 = y2);
          }
          if (!p2)
            return (r3 = new Error("invalid rev tree")).docId = e4, n3(r3);
          var g2 = p2.ids.map(function(e5) {
            return e5.id;
          }).indexOf(s3._rev.split("-")[1]) + 1, m2 = p2.ids.length - g2;
          if (p2.ids.splice(g2, m2), p2.ids.reverse(), t4.revs && (s3._revisions = { start: p2.pos + p2.ids.length - 1, ids: p2.ids.map(function(e5) {
            return e5.id;
          }) }), t4.revs_info) {
            var b2 = p2.pos + p2.ids.length;
            s3._revs_info = p2.ids.map(function(e5) {
              return { rev: --b2 + "-" + e5.id, status: e5.opts.status };
            });
          }
        }
        if (t4.attachments && s3._attachments) {
          var w2 = s3._attachments, k2 = Object.keys(w2).length;
          if (k2 === 0)
            return n3(null, s3);
          Object.keys(w2).forEach(function(e5) {
            this._getAttachment(s3._id, e5, w2[e5], { rev: s3._rev, binary: t4.binary, ctx: u2 }, function(t5, r4) {
              var o4 = s3._attachments[e5];
              o4.data = r4, delete o4.stub, delete o4.length, --k2 || n3(null, s3);
            });
          }, o3);
        } else {
          if (s3._attachments)
            for (var j2 in s3._attachments)
              s3._attachments.hasOwnProperty(j2) && (s3._attachments[j2].stub = true);
          n3(null, s3);
        }
      });
    if (t4.open_revs === "all")
      this._getRevisionTree(e4, function(e5, t5) {
        if (e5)
          return n3(e5);
        r2 = $e(t5).map(function(e6) {
          return e6.rev;
        }), i2();
      });
    else {
      if (!Array.isArray(t4.open_revs))
        return n3(ee(z, "function_clause"));
      r2 = t4.open_revs;
      for (var s2 = 0; s2 < r2.length; s2++) {
        var a2 = r2[s2];
        if (typeof a2 != "string" || !/^\d+-/.test(a2))
          return n3(ee(X));
      }
      i2();
    }
  }), Ze.prototype.getAttachment = S("getAttachment", function(e4, t4, n3, r2) {
    var o3 = this;
    n3 instanceof Function && (r2 = n3, n3 = {}), this._get(e4, n3, function(i2, s2) {
      return i2 ? r2(i2) : s2.doc._attachments && s2.doc._attachments[t4] ? (n3.ctx = s2.ctx, n3.binary = true, void o3._getAttachment(e4, t4, s2.doc._attachments[t4], n3, r2)) : r2(ee(N));
    });
  }), Ze.prototype.allDocs = S("allDocs", function(e4, t4) {
    if (typeof e4 == "function" && (t4 = e4, e4 = {}), e4.skip = e4.skip !== void 0 ? e4.skip : 0, e4.start_key && (e4.startkey = e4.start_key), e4.end_key && (e4.endkey = e4.end_key), "keys" in e4) {
      if (!Array.isArray(e4.keys))
        return t4(new TypeError("options.keys must be an array"));
      var n3 = ["startkey", "endkey", "key"].filter(function(t5) {
        return t5 in e4;
      })[0];
      if (n3)
        return void t4(ee(G, "Query parameter `" + n3 + "` is not compatible with multi-get"));
      if (!ie(this) && (function(e5) {
        var t5 = "limit" in e5 ? e5.keys.slice(e5.skip, e5.limit + e5.skip) : e5.skip > 0 ? e5.keys.slice(e5.skip) : e5.keys;
        e5.keys = t5, e5.skip = 0, delete e5.limit, e5.descending && (t5.reverse(), e5.descending = false);
      }(e4), e4.keys.length === 0))
        return this._allDocs({ limit: 0 }, t4);
    }
    return this._allDocs(e4, t4);
  }), Ze.prototype.changes = function(e4, t4) {
    return typeof e4 == "function" && (t4 = e4, e4 = {}), (e4 = e4 || {}).return_docs = "return_docs" in e4 ? e4.return_docs : !e4.live, new Ge(this, e4, t4);
  }, Ze.prototype.close = S("close", function(e4) {
    return this._closed = true, this.emit("closed"), this._close(e4);
  }), Ze.prototype.info = S("info", function(e4) {
    var t4 = this;
    this._info(function(n3, r2) {
      if (n3)
        return e4(n3);
      r2.db_name = r2.db_name || t4.name, r2.auto_compaction = !(!t4.auto_compaction || ie(t4)), r2.adapter = t4.adapter, e4(null, r2);
    });
  }), Ze.prototype.id = S("id", function(e4) {
    return this._id(e4);
  }), Ze.prototype.type = function() {
    return typeof this._type == "function" ? this._type() : this.adapter;
  }, Ze.prototype.bulkDocs = S("bulkDocs", function(e4, t4, n3) {
    if (typeof t4 == "function" && (n3 = t4, t4 = {}), t4 = t4 || {}, Array.isArray(e4) && (e4 = { docs: e4 }), !e4 || !e4.docs || !Array.isArray(e4.docs))
      return n3(ee(M));
    for (var r2 = 0; r2 < e4.docs.length; ++r2)
      if (typeof e4.docs[r2] != "object" || Array.isArray(e4.docs[r2]))
        return n3(ee(Y));
    var o3;
    if (e4.docs.forEach(function(e5) {
      e5._attachments && Object.keys(e5._attachments).forEach(function(t5) {
        o3 = o3 || function(e6) {
          return e6.charAt(0) === "_" && e6 + " is not a valid attachment name, attachment names cannot start with '_'";
        }(t5), e5._attachments[t5].content_type || $("warn", "Attachment", t5, "on document", e5._id, "is missing content_type");
      });
    }), o3)
      return n3(ee(W, o3));
    "new_edits" in t4 || (t4.new_edits = !("new_edits" in e4) || e4.new_edits);
    var i2 = this;
    t4.new_edits || ie(i2) || e4.docs.sort(He), function(e5) {
      for (var t5 = 0; t5 < e5.length; t5++) {
        var n4 = e5[t5];
        if (n4._deleted)
          delete n4._attachments;
        else if (n4._attachments)
          for (var r3 = Object.keys(n4._attachments), o4 = 0; o4 < r3.length; o4++) {
            var i3 = r3[o4];
            n4._attachments[i3] = x(n4._attachments[i3], ["data", "digest", "content_type", "length", "revpos", "stub"]);
          }
      }
    }(e4.docs);
    var s2 = e4.docs.map(function(e5) {
      return e5._id;
    });
    return this._bulkDocs(e4, t4, function(e5, r3) {
      if (e5)
        return n3(e5);
      if (t4.new_edits || (r3 = r3.filter(function(e6) {
        return e6.error;
      })), !ie(i2))
        for (var o4 = 0, a2 = r3.length; o4 < a2; o4++)
          r3[o4].id = r3[o4].id || s2[o4];
      n3(null, r3);
    });
  }), Ze.prototype.registerDependentDatabase = S("registerDependentDatabase", function(e4, t4) {
    var n3 = new this.constructor(e4, this.__opts);
    pe(this, "_local/_pouch_dependentDbs", function(t5) {
      return t5.dependentDbs = t5.dependentDbs || {}, !t5.dependentDbs[e4] && (t5.dependentDbs[e4] = true, t5);
    }).then(function() {
      t4(null, { db: n3 });
    }).catch(t4);
  }), Ze.prototype.destroy = S("destroy", function(e4, t4) {
    typeof e4 == "function" && (t4 = e4, e4 = {});
    var n3 = this, r2 = !("use_prefix" in n3) || n3.use_prefix;
    function o3() {
      n3._destroy(e4, function(e5, r3) {
        if (e5)
          return t4(e5);
        n3._destroyed = true, n3.emit("destroyed"), t4(null, r3 || { ok: true });
      });
    }
    if (ie(n3))
      return o3();
    n3.get("_local/_pouch_dependentDbs", function(e5, i2) {
      if (e5)
        return e5.status !== 404 ? t4(e5) : o3();
      var s2 = i2.dependentDbs, a2 = n3.constructor, u2 = Object.keys(s2).map(function(e6) {
        var t5 = r2 ? e6.replace(new RegExp("^" + a2.prefix), "") : e6;
        return new a2(t5, n3.__opts).destroy();
      });
      Promise.all(u2).then(o3, t4);
    });
  }), et.prototype.execute = function() {
    var e4;
    if (this.failed)
      for (; e4 = this.queue.shift(); )
        e4(this.failed);
    else
      for (; e4 = this.queue.shift(); )
        e4();
  }, et.prototype.fail = function(e4) {
    this.failed = e4, this.execute();
  }, et.prototype.ready = function(e4) {
    this.isReady = true, this.db = e4, this.execute();
  }, et.prototype.addTask = function(e4) {
    this.queue.push(e4), this.failed && this.execute();
  }, p()(tt, Ze);
  var nt = typeof AbortController != "undefined" ? AbortController : function() {
    return { abort: function() {
    } };
  }, rt = fetch, ot = Headers;
  tt.adapters = {}, tt.preferredAdapters = [], tt.prefix = "_pouch_";
  var it = new (y())();
  function st(e4, t4) {
    for (var n3 = e4, r2 = 0, o3 = t4.length; r2 < o3 && (n3 = n3[t4[r2]]); r2++)
      ;
    return n3;
  }
  function at(e4) {
    for (var t4 = [], n3 = "", r2 = 0, o3 = e4.length; r2 < o3; r2++) {
      var i2 = e4[r2];
      i2 === "." ? r2 > 0 && e4[r2 - 1] === "\\" ? n3 = n3.substring(0, n3.length - 1) + "." : (t4.push(n3), n3 = "") : n3 += i2;
    }
    return t4.push(n3), t4;
  }
  !function(e4) {
    Object.keys(y().prototype).forEach(function(t5) {
      typeof y().prototype[t5] == "function" && (e4[t5] = it[t5].bind(it));
    });
    var t4 = e4._destructionListeners = new a();
    e4.on("ref", function(e5) {
      t4.has(e5.name) || t4.set(e5.name, []), t4.get(e5.name).push(e5);
    }), e4.on("unref", function(e5) {
      if (t4.has(e5.name)) {
        var n3 = t4.get(e5.name), r2 = n3.indexOf(e5);
        r2 < 0 || (n3.splice(r2, 1), n3.length > 1 ? t4.set(e5.name, n3) : t4.delete(e5.name));
      }
    }), e4.on("destroyed", function(e5) {
      if (t4.has(e5)) {
        var n3 = t4.get(e5);
        t4.delete(e5), n3.forEach(function(e6) {
          e6.emit("destroyed", true);
        });
      }
    });
  }(tt), tt.adapter = function(e4, t4, n3) {
    t4.valid() && (tt.adapters[e4] = t4, n3 && tt.preferredAdapters.push(e4));
  }, tt.plugin = function(e4) {
    if (typeof e4 == "function")
      e4(tt);
    else {
      if (typeof e4 != "object" || Object.keys(e4).length === 0)
        throw new Error('Invalid plugin: got "' + e4 + '", expected an object or a function');
      Object.keys(e4).forEach(function(t4) {
        tt.prototype[t4] = e4[t4];
      });
    }
    return this.__defaults && (tt.__defaults = R({}, this.__defaults)), tt;
  }, tt.defaults = function(e4) {
    function t4(e5, n3) {
      if (!(this instanceof t4))
        return new t4(e5, n3);
      n3 = n3 || {}, e5 && typeof e5 == "object" && (e5 = (n3 = e5).name, delete n3.name), n3 = R({}, t4.__defaults, n3), tt.call(this, e5, n3);
    }
    return p()(t4, tt), t4.preferredAdapters = tt.preferredAdapters.slice(), Object.keys(tt).forEach(function(e5) {
      e5 in t4 || (t4[e5] = tt[e5]);
    }), t4.__defaults = R({}, this.__defaults, e4), t4;
  }, tt.fetch = function(e4, t4) {
    return rt(e4, t4);
  };
  var ut = ["$or", "$nor", "$not"];
  function ct(e4) {
    return ut.indexOf(e4) > -1;
  }
  function ft(e4) {
    return Object.keys(e4)[0];
  }
  function lt(e4) {
    var t4 = {};
    return e4.forEach(function(e5) {
      Object.keys(e5).forEach(function(n3) {
        var r2 = e5[n3];
        if (typeof r2 != "object" && (r2 = { $eq: r2 }), ct(n3))
          t4[n3] = r2 instanceof Array ? r2.map(function(e6) {
            return lt([e6]);
          }) : lt([r2]);
        else {
          var o3 = t4[n3] = t4[n3] || {};
          Object.keys(r2).forEach(function(e6) {
            var t5 = r2[e6];
            return e6 === "$gt" || e6 === "$gte" ? function(e7, t6, n4) {
              n4.$eq === void 0 && (n4.$gte !== void 0 ? e7 === "$gte" ? t6 > n4.$gte && (n4.$gte = t6) : t6 >= n4.$gte && (delete n4.$gte, n4.$gt = t6) : n4.$gt !== void 0 ? e7 === "$gte" ? t6 > n4.$gt && (delete n4.$gt, n4.$gte = t6) : t6 > n4.$gt && (n4.$gt = t6) : n4[e7] = t6);
            }(e6, t5, o3) : e6 === "$lt" || e6 === "$lte" ? function(e7, t6, n4) {
              n4.$eq === void 0 && (n4.$lte !== void 0 ? e7 === "$lte" ? t6 < n4.$lte && (n4.$lte = t6) : t6 <= n4.$lte && (delete n4.$lte, n4.$lt = t6) : n4.$lt !== void 0 ? e7 === "$lte" ? t6 < n4.$lt && (delete n4.$lt, n4.$lte = t6) : t6 < n4.$lt && (n4.$lt = t6) : n4[e7] = t6);
            }(e6, t5, o3) : e6 === "$ne" ? function(e7, t6) {
              "$ne" in t6 ? t6.$ne.push(e7) : t6.$ne = [e7];
            }(t5, o3) : e6 === "$eq" ? function(e7, t6) {
              delete t6.$gt, delete t6.$gte, delete t6.$lt, delete t6.$lte, delete t6.$ne, t6.$eq = e7;
            }(t5, o3) : void (o3[e6] = t5);
          });
        }
      });
    }), t4;
  }
  function dt(e4) {
    for (var t4 in e4) {
      if (Array.isArray(e4))
        for (var n3 in e4)
          e4[n3].$and && (e4[n3] = lt(e4[n3].$and));
      var r2 = e4[t4];
      typeof r2 == "object" && dt(r2);
    }
    return e4;
  }
  function ht(e4, t4) {
    for (var n3 in e4) {
      n3 === "$and" && (t4 = true);
      var r2 = e4[n3];
      typeof r2 == "object" && (t4 = ht(r2, t4));
    }
    return t4;
  }
  function pt(e4) {
    var t4 = O(e4), n3 = false;
    ht(t4, false) && ("$and" in (t4 = dt(t4)) && (t4 = lt(t4.$and)), n3 = true), ["$or", "$nor"].forEach(function(e5) {
      e5 in t4 && t4[e5].forEach(function(e6) {
        for (var t5 = Object.keys(e6), n4 = 0; n4 < t5.length; n4++) {
          var r3 = t5[n4], o4 = e6[r3];
          typeof o4 == "object" && o4 !== null || (e6[r3] = { $eq: o4 });
        }
      });
    }), "$not" in t4 && (t4.$not = lt([t4.$not]));
    for (var r2 = Object.keys(t4), o3 = 0; o3 < r2.length; o3++) {
      var i2 = r2[o3], s2 = t4[i2];
      typeof s2 != "object" || s2 === null ? s2 = { $eq: s2 } : "$ne" in s2 && !n3 && (s2.$ne = [s2.$ne]), t4[i2] = s2;
    }
    return t4;
  }
  function vt(e4, t4) {
    if (e4 === t4)
      return 0;
    e4 = yt(e4), t4 = yt(t4);
    var n3 = bt(e4), r2 = bt(t4);
    if (n3 - r2 != 0)
      return n3 - r2;
    switch (typeof e4) {
      case "number":
        return e4 - t4;
      case "boolean":
        return e4 < t4 ? -1 : 1;
      case "string":
        return function(e5, t5) {
          return e5 === t5 ? 0 : e5 > t5 ? 1 : -1;
        }(e4, t4);
    }
    return Array.isArray(e4) ? function(e5, t5) {
      for (var n4 = Math.min(e5.length, t5.length), r3 = 0; r3 < n4; r3++) {
        var o3 = vt(e5[r3], t5[r3]);
        if (o3 !== 0)
          return o3;
      }
      return e5.length === t5.length ? 0 : e5.length > t5.length ? 1 : -1;
    }(e4, t4) : function(e5, t5) {
      for (var n4 = Object.keys(e5), r3 = Object.keys(t5), o3 = Math.min(n4.length, r3.length), i2 = 0; i2 < o3; i2++) {
        var s2 = vt(n4[i2], r3[i2]);
        if (s2 !== 0)
          return s2;
        if ((s2 = vt(e5[n4[i2]], t5[r3[i2]])) !== 0)
          return s2;
      }
      return n4.length === r3.length ? 0 : n4.length > r3.length ? 1 : -1;
    }(e4, t4);
  }
  function yt(e4) {
    switch (typeof e4) {
      case "undefined":
        return null;
      case "number":
        return e4 === 1 / 0 || e4 === -1 / 0 || isNaN(e4) ? null : e4;
      case "object":
        var t4 = e4;
        if (Array.isArray(e4)) {
          var n3 = e4.length;
          e4 = new Array(n3);
          for (var r2 = 0; r2 < n3; r2++)
            e4[r2] = yt(t4[r2]);
        } else {
          if (e4 instanceof Date)
            return e4.toJSON();
          if (e4 !== null) {
            for (var o3 in e4 = {}, t4)
              if (t4.hasOwnProperty(o3)) {
                var i2 = t4[o3];
                i2 !== void 0 && (e4[o3] = yt(i2));
              }
          }
        }
    }
    return e4;
  }
  function _t(e4) {
    return bt(e4 = yt(e4)) + "" + function(e5) {
      if (e5 !== null)
        switch (typeof e5) {
          case "boolean":
            return e5 ? 1 : 0;
          case "number":
            return function(e6) {
              if (e6 === 0)
                return "1";
              var t5, n4 = e6.toExponential().split(/e\+?/), r3 = parseInt(n4[1], 10), o4 = e6 < 0, i3 = o4 ? "0" : "2";
              i3 += "" + (function(e7, t6, n5) {
                for (var r4 = "", o5 = 3 - e7.length; r4.length < o5; )
                  r4 += "0";
                return r4;
              }(t5 = ((o4 ? -r3 : r3) - -324).toString()) + t5);
              var s3 = Math.abs(parseFloat(n4[0]));
              o4 && (s3 = 10 - s3);
              var a2 = s3.toFixed(20);
              return i3 + "" + a2.replace(/\.?0+$/, "");
            }(e5);
          case "string":
            return e5.replace(/\u0002/g, "").replace(/\u0001/g, "").replace(/\u0000/g, "");
          case "object":
            var t4 = Array.isArray(e5), n3 = t4 ? e5 : Object.keys(e5), r2 = -1, o3 = n3.length, i2 = "";
            if (t4)
              for (; ++r2 < o3; )
                i2 += _t(n3[r2]);
            else
              for (; ++r2 < o3; ) {
                var s2 = n3[r2];
                i2 += _t(s2) + _t(e5[s2]);
              }
            return i2;
        }
      return "";
    }(e4) + "\0";
  }
  function gt(e4, t4) {
    var n3, r2 = t4;
    if (e4[t4] === "1")
      n3 = 0, t4++;
    else {
      var o3 = e4[t4] === "0";
      t4++;
      var i2 = "", s2 = e4.substring(t4, t4 + 3), a2 = parseInt(s2, 10) + -324;
      for (o3 && (a2 = -a2), t4 += 3; ; ) {
        var u2 = e4[t4];
        if (u2 === "\0")
          break;
        i2 += u2, t4++;
      }
      n3 = (i2 = i2.split(".")).length === 1 ? parseInt(i2, 10) : parseFloat(i2[0] + "." + i2[1]), o3 && (n3 -= 10), a2 !== 0 && (n3 = parseFloat(n3 + "e" + a2));
    }
    return { num: n3, length: t4 - r2 };
  }
  function mt(e4, t4) {
    var n3 = e4.pop();
    if (t4.length) {
      var r2 = t4[t4.length - 1];
      n3 === r2.element && (t4.pop(), r2 = t4[t4.length - 1]);
      var o3 = r2.element, i2 = r2.index;
      Array.isArray(o3) ? o3.push(n3) : i2 === e4.length - 2 ? o3[e4.pop()] = n3 : e4.push(n3);
    }
  }
  function bt(e4) {
    var t4 = ["boolean", "number", "string", "object"].indexOf(typeof e4);
    return ~t4 ? e4 === null ? 1 : Array.isArray(e4) ? 5 : t4 < 3 ? t4 + 2 : t4 + 3 : Array.isArray(e4) ? 5 : void 0;
  }
  function wt(e4, t4, n3) {
    return n3.every(function(n4) {
      var r2 = t4[n4], o3 = at(n4), i2 = st(e4, o3);
      return ct(n4) ? function(e5, t5, n5) {
        return e5 === "$or" ? t5.some(function(e6) {
          return wt(n5, e6, Object.keys(e6));
        }) : e5 === "$not" ? !wt(n5, t5, Object.keys(t5)) : !t5.find(function(e6) {
          return wt(n5, e6, Object.keys(e6));
        });
      }(n4, r2, e4) : kt(r2, e4, o3, i2);
    });
  }
  function kt(e4, t4, n3, r2) {
    return !e4 || (typeof e4 == "object" ? Object.keys(e4).every(function(o3) {
      var i2 = e4[o3];
      return function(e5, t5, n4, r3, o4) {
        if (!qt[e5])
          throw new Error('unknown operator "' + e5 + '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, $nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
        return qt[e5](t5, n4, r3, o4);
      }(o3, t4, i2, n3, r2);
    }) : e4 === r2);
  }
  function jt(e4) {
    return e4 != null;
  }
  function Ot(e4) {
    return e4 !== void 0;
  }
  function At(e4, t4) {
    return t4.some(function(t5) {
      return e4 instanceof Array ? e4.indexOf(t5) > -1 : e4 === t5;
    });
  }
  var qt = { $elemMatch: function(e4, t4, n3, r2) {
    return !!Array.isArray(r2) && r2.length !== 0 && (typeof r2[0] == "object" ? r2.some(function(e5) {
      return wt(e5, t4, Object.keys(t4));
    }) : r2.some(function(r3) {
      return kt(t4, e4, n3, r3);
    }));
  }, $allMatch: function(e4, t4, n3, r2) {
    return !!Array.isArray(r2) && r2.length !== 0 && (typeof r2[0] == "object" ? r2.every(function(e5) {
      return wt(e5, t4, Object.keys(t4));
    }) : r2.every(function(r3) {
      return kt(t4, e4, n3, r3);
    }));
  }, $eq: function(e4, t4, n3, r2) {
    return Ot(r2) && vt(r2, t4) === 0;
  }, $gte: function(e4, t4, n3, r2) {
    return Ot(r2) && vt(r2, t4) >= 0;
  }, $gt: function(e4, t4, n3, r2) {
    return Ot(r2) && vt(r2, t4) > 0;
  }, $lte: function(e4, t4, n3, r2) {
    return Ot(r2) && vt(r2, t4) <= 0;
  }, $lt: function(e4, t4, n3, r2) {
    return Ot(r2) && vt(r2, t4) < 0;
  }, $exists: function(e4, t4, n3, r2) {
    return t4 ? Ot(r2) : !Ot(r2);
  }, $mod: function(e4, t4, n3, r2) {
    return jt(r2) && function(e5, t5) {
      var n4 = t5[0], r3 = t5[1];
      if (n4 === 0)
        throw new Error("Bad divisor, cannot divide by zero");
      if (parseInt(n4, 10) !== n4)
        throw new Error("Divisor is not an integer");
      if (parseInt(r3, 10) !== r3)
        throw new Error("Modulus is not an integer");
      return parseInt(e5, 10) === e5 && e5 % n4 === r3;
    }(r2, t4);
  }, $ne: function(e4, t4, n3, r2) {
    return t4.every(function(e5) {
      return vt(r2, e5) !== 0;
    });
  }, $in: function(e4, t4, n3, r2) {
    return jt(r2) && At(r2, t4);
  }, $nin: function(e4, t4, n3, r2) {
    return jt(r2) && !At(r2, t4);
  }, $size: function(e4, t4, n3, r2) {
    return jt(r2) && function(e5, t5) {
      return e5.length === t5;
    }(r2, t4);
  }, $all: function(e4, t4, n3, r2) {
    return Array.isArray(r2) && function(e5, t5) {
      return t5.every(function(t6) {
        return e5.indexOf(t6) > -1;
      });
    }(r2, t4);
  }, $regex: function(e4, t4, n3, r2) {
    return jt(r2) && function(e5, t5) {
      return new RegExp(t5).test(e5);
    }(r2, t4);
  }, $type: function(e4, t4, n3, r2) {
    return function(e5, t5) {
      switch (t5) {
        case "null":
          return e5 === null;
        case "boolean":
          return typeof e5 == "boolean";
        case "number":
          return typeof e5 == "number";
        case "string":
          return typeof e5 == "string";
        case "array":
          return e5 instanceof Array;
        case "object":
          return {}.toString.call(e5) === "[object Object]";
      }
      throw new Error(t5 + " not supported as a type.Please use one of object, string, array, number, boolean or null.");
    }(r2, t4);
  } };
  function St(e4, t4) {
    if (e4.selector && e4.filter && e4.filter !== "_selector") {
      var n3 = typeof e4.filter == "string" ? e4.filter : "function";
      return t4(new Error('selector invalid for filter "' + n3 + '"'));
    }
    t4();
  }
  function xt(e4) {
    e4.view && !e4.filter && (e4.filter = "_view"), e4.selector && !e4.filter && (e4.filter = "_selector"), e4.filter && typeof e4.filter == "string" && (e4.filter === "_view" ? e4.view = ae(e4.view) : e4.filter = ae(e4.filter));
  }
  function Et(e4, t4) {
    return t4.filter && typeof t4.filter == "string" && !t4.doc_ids && !ie(e4.db);
  }
  function Ct(e4, t4) {
    var n3 = t4.complete;
    if (t4.filter === "_view") {
      if (!t4.view || typeof t4.view != "string") {
        var r2 = ee(W, "`view` filter parameter not found or invalid.");
        return n3(r2);
      }
      var o3 = se(t4.view);
      e4.db.get("_design/" + o3[0], function(r3, i3) {
        if (e4.isCancelled)
          return n3(null, { status: "cancelled" });
        if (r3)
          return n3(te(r3));
        var s2 = i3 && i3.views && i3.views[o3[1]] && i3.views[o3[1]].map;
        if (!s2)
          return n3(ee(N, i3.views ? "missing json key: " + o3[1] : "missing json key: views"));
        t4.filter = he(["return function(doc) {", '  "use strict";', "  var emitted = false;", "  var emit = function (a, b) {", "    emitted = true;", "  };", "  var view = " + s2 + ";", "  view(doc);", "  if (emitted) {", "    return true;", "  }", "};"].join("\n"), {}), e4.doChanges(t4);
      });
    } else if (t4.selector)
      t4.filter = function(e5) {
        return function(e6, t5) {
          if (typeof t5 != "object")
            throw new Error("Selector error: expected a JSON object");
          var n4 = function(e7, t6, n5) {
            if (e7 = e7.filter(function(e8) {
              return wt(e8.doc, t6.selector, n5);
            }), t6.sort) {
              var r3 = function(e8) {
                function t7(t8) {
                  return e8.map(function(e9) {
                    var n6 = at(ft(e9));
                    return st(t8, n6);
                  });
                }
                return function(e9, n6) {
                  var r4, o5, i4 = vt(t7(e9.doc), t7(n6.doc));
                  return i4 !== 0 ? i4 : (r4 = e9.doc._id) < (o5 = n6.doc._id) ? -1 : r4 > o5 ? 1 : 0;
                };
              }(t6.sort);
              e7 = e7.sort(r3), typeof t6.sort[0] != "string" && (o4 = t6.sort[0])[ft(o4)] === "desc" && (e7 = e7.reverse());
            }
            var o4;
            if ("limit" in t6 || "skip" in t6) {
              var i3 = t6.skip || 0, s2 = ("limit" in t6 ? t6.limit : e7.length) + i3;
              e7 = e7.slice(i3, s2);
            }
            return e7;
          }([{ doc: e6 }], { selector: t5 = pt(t5) }, Object.keys(t5));
          return n4 && n4.length === 1;
        }(e5, t4.selector);
      }, e4.doChanges(t4);
    else {
      var i2 = se(t4.filter);
      e4.db.get("_design/" + i2[0], function(r3, o4) {
        if (e4.isCancelled)
          return n3(null, { status: "cancelled" });
        if (r3)
          return n3(te(r3));
        var s2 = o4 && o4.filters && o4.filters[i2[1]];
        if (!s2)
          return n3(ee(N, o4 && o4.filters ? "missing json key: " + i2[1] : "missing json key: filters"));
        t4.filter = he('"use strict";\nreturn ' + s2 + ";", {}), e4.doChanges(t4);
      });
    }
  }
  function Pt(e4) {
    return e4.reduce(function(e5, t4) {
      return e5[t4] = true, e5;
    }, {});
  }
  tt.plugin(function(e4) {
    e4._changesFilterPlugin = { validate: St, normalize: xt, shouldFilter: Et, filter: Ct };
  }), tt.version = "7.2.2";
  var Lt = Pt(["_id", "_rev", "_attachments", "_deleted", "_revisions", "_revs_info", "_conflicts", "_deleted_conflicts", "_local_seq", "_rev_tree", "_replication_id", "_replication_state", "_replication_state_time", "_replication_state_reason", "_replication_stats", "_removed"]), Dt = Pt(["_attachments", "_replication_id", "_replication_state", "_replication_state_time", "_replication_state_reason", "_replication_stats"]);
  function $t(e4) {
    if (!/^\d+-/.test(e4))
      return ee(X);
    var t4 = e4.indexOf("-"), n3 = e4.substring(0, t4), r2 = e4.substring(t4 + 1);
    return { prefix: parseInt(n3, 10), id: r2 };
  }
  function It(e4, t4, n3) {
    var r2, o3, i2;
    n3 || (n3 = { deterministic_revs: true });
    var s2 = { status: "available" };
    if (e4._deleted && (s2.deleted = true), t4)
      if (e4._id || (e4._id = Ce()), o3 = Ee(e4, n3.deterministic_revs), e4._rev) {
        if ((i2 = $t(e4._rev)).error)
          return i2;
        e4._rev_tree = [{ pos: i2.prefix, ids: [i2.id, { status: "missing" }, [[o3, s2, []]]] }], r2 = i2.prefix + 1;
      } else
        e4._rev_tree = [{ pos: 1, ids: [o3, s2, []] }], r2 = 1;
    else if (e4._revisions && (e4._rev_tree = function(e5, t5) {
      for (var n4 = e5.start - e5.ids.length + 1, r3 = e5.ids, o4 = [r3[0], t5, []], i3 = 1, s3 = r3.length; i3 < s3; i3++)
        o4 = [r3[i3], { status: "missing" }, [o4]];
      return [{ pos: n4, ids: o4 }];
    }(e4._revisions, s2), r2 = e4._revisions.start, o3 = e4._revisions.ids[0]), !e4._rev_tree) {
      if ((i2 = $t(e4._rev)).error)
        return i2;
      r2 = i2.prefix, o3 = i2.id, e4._rev_tree = [{ pos: r2, ids: [o3, s2, []] }];
    }
    oe(e4._id), e4._rev = r2 + "-" + o3;
    var a2 = { metadata: {}, data: {} };
    for (var u2 in e4)
      if (Object.prototype.hasOwnProperty.call(e4, u2)) {
        var c2 = u2[0] === "_";
        if (c2 && !Lt[u2]) {
          var f2 = ee(Q, u2);
          throw f2.message = Q.message + ": " + u2, f2;
        }
        c2 && !Dt[u2] ? a2.metadata[u2.slice(1)] = e4[u2] : a2.data[u2] = e4[u2];
      }
    return a2;
  }
  function Bt(e4, t4, n3) {
    if (e4.stub)
      return n3();
    typeof e4.data == "string" ? function(e5, t5, n4) {
      var r2 = function(e6) {
        try {
          return ve(e6);
        } catch (e7) {
          return { error: ee(V, "Attachment is not a valid base64 string") };
        }
      }(e5.data);
      if (r2.error)
        return n4(r2.error);
      e5.length = r2.length, e5.data = t5 === "blob" ? me(r2, e5.content_type) : t5 === "base64" ? ye(r2) : r2, Se(r2, function(t6) {
        e5.digest = "md5-" + t6, n4();
      });
    }(e4, t4, n3) : function(e5, t5, n4) {
      Se(e5.data, function(r2) {
        e5.digest = "md5-" + r2, e5.length = e5.data.size || e5.data.length || 0, t5 === "binary" ? ke(e5.data, function(t6) {
          e5.data = t6, n4();
        }) : t5 === "base64" ? je(e5.data, function(t6) {
          e5.data = t6, n4();
        }) : n4();
      });
    }(e4, t4, n3);
  }
  function Rt(e4, t4, n3, r2, o3, i2, s2, u2, c2) {
    e4 = e4 || 1e3;
    var f2 = u2.new_edits, l2 = new a(), d2 = 0, h2 = t4.length;
    function p2() {
      ++d2 === h2 && c2 && c2();
    }
    t4.forEach(function(e5, t5) {
      if (e5._id && Ve(e5._id)) {
        var r3 = e5._deleted ? "_removeLocal" : "_putLocal";
        n3[r3](e5, { ctx: o3 }, function(e6, n4) {
          i2[t5] = e6 || n4, p2();
        });
      } else {
        var s3 = e5.metadata.id;
        l2.has(s3) ? (h2--, l2.get(s3).push([e5, t5])) : l2.set(s3, [[e5, t5]]);
      }
    }), l2.forEach(function(t5, n4) {
      var o4 = 0;
      function a2() {
        ++o4 < t5.length ? c3() : p2();
      }
      function c3() {
        var c4 = t5[o4], l3 = c4[0], d3 = c4[1];
        if (r2.has(n4))
          !function(e5, t6, n5, r3, o5, i3, s3, a3) {
            if (function(e6, t7) {
              for (var n6, r4 = e6.slice(), o6 = t7.split("-"), i4 = parseInt(o6[0], 10), s4 = o6[1]; n6 = r4.pop(); ) {
                if (n6.pos === i4 && n6.ids[0] === s4)
                  return true;
                for (var a4 = n6.ids[2], u4 = 0, c6 = a4.length; u4 < c6; u4++)
                  r4.push({ pos: n6.pos + 1, ids: a4[u4] });
              }
              return false;
            }(t6.rev_tree, n5.metadata.rev) && !a3)
              return r3[o5] = n5, i3();
            var u3 = t6.winningRev || Pe(t6), c5 = "deleted" in t6 ? t6.deleted : ze(t6, u3), f3 = "deleted" in n5.metadata ? n5.metadata.deleted : ze(n5.metadata), l4 = /^1-/.test(n5.metadata.rev);
            if (c5 && !f3 && a3 && l4) {
              var d4 = n5.data;
              d4._rev = u3, d4._id = n5.metadata.id, n5 = It(d4, a3);
            }
            var h4 = Ke(t6.rev_tree, n5.metadata.rev_tree[0], e5);
            if (a3 && (c5 && f3 && h4.conflicts !== "new_leaf" || !c5 && h4.conflicts !== "new_leaf" || c5 && !f3 && h4.conflicts === "new_branch")) {
              var p3 = ee(U);
              return r3[o5] = p3, i3();
            }
            var v2 = n5.metadata.rev;
            n5.metadata.rev_tree = h4.tree, n5.stemmedRevs = h4.stemmedRevs || [], t6.rev_map && (n5.metadata.rev_map = t6.rev_map);
            var y2 = Pe(n5.metadata), _2 = ze(n5.metadata, y2), g2 = c5 === _2 ? 0 : c5 < _2 ? -1 : 1;
            s3(n5, y2, _2, v2 === y2 ? _2 : ze(n5.metadata, v2), true, g2, o5, i3);
          }(e4, r2.get(n4), l3, i2, d3, a2, s2, f2);
        else {
          var h3 = Ke([], l3.metadata.rev_tree[0], e4);
          l3.metadata.rev_tree = h3.tree, l3.stemmedRevs = h3.stemmedRevs || [], function(e5, t6, n5) {
            var r3 = Pe(e5.metadata), o5 = ze(e5.metadata, r3);
            if ("was_delete" in u2 && o5)
              return i2[t6] = ee(N, "deleted"), n5();
            var a3 = f2 && function(e6) {
              return e6.metadata.rev_tree[0].ids[1].status === "missing";
            }(e5);
            if (a3) {
              var c5 = ee(U);
              return i2[t6] = c5, n5();
            }
            s2(e5, r3, o5, o5, false, o5 ? 0 : 1, t6, n5);
          }(l3, d3, a2);
        }
      }
      c3();
    });
  }
  var Tt = "document-store", Mt = "by-sequence", Nt = "attach-store", Ut = "attach-seq-store", Ft = "meta-store", Kt = "local-store", Jt = "detect-blob-support";
  function zt(e4) {
    try {
      return JSON.stringify(e4);
    } catch (t4) {
      return f.stringify(e4);
    }
  }
  function Vt(e4) {
    return function(t4) {
      var n3 = "unknown_error";
      t4.target && t4.target.error && (n3 = t4.target.error.name || t4.target.error.message), e4(ee(H, n3, t4.type));
    };
  }
  function Gt(e4, t4, n3) {
    return { data: zt(e4), winningRev: t4, deletedOrLocal: n3 ? "1" : "0", seq: e4.seq, id: e4.id };
  }
  function Qt(e4) {
    if (!e4)
      return null;
    var t4 = function(e5) {
      try {
        return JSON.parse(e5);
      } catch (t5) {
        return f.parse(e5);
      }
    }(e4.data);
    return t4.winningRev = e4.winningRev, t4.deleted = e4.deletedOrLocal === "1", t4.seq = e4.seq, t4;
  }
  function Wt(e4) {
    if (!e4)
      return e4;
    var t4 = e4._doc_id_rev.lastIndexOf(":");
    return e4._id = e4._doc_id_rev.substring(0, t4 - 1), e4._rev = e4._doc_id_rev.substring(t4 + 1), delete e4._doc_id_rev, e4;
  }
  function Yt(e4, t4, n3, r2) {
    n3 ? r2(e4 ? typeof e4 != "string" ? e4 : be(e4, t4) : _e([""], { type: t4 })) : e4 ? typeof e4 != "string" ? we(e4, function(e5) {
      r2(ye(e5));
    }) : r2(e4) : r2("");
  }
  function Ht(e4, t4, n3, r2) {
    var o3 = Object.keys(e4._attachments || {});
    if (!o3.length)
      return r2 && r2();
    var i2 = 0;
    function s2() {
      ++i2 === o3.length && r2 && r2();
    }
    o3.forEach(function(r3) {
      t4.attachments && t4.include_docs ? function(e5, t5) {
        var r4 = e5._attachments[t5], o4 = r4.digest;
        n3.objectStore(Nt).get(o4).onsuccess = function(e6) {
          r4.body = e6.target.result.body, s2();
        };
      }(e4, r3) : (e4._attachments[r3].stub = true, s2());
    });
  }
  function Xt(e4, t4) {
    return Promise.all(e4.map(function(e5) {
      if (e5.doc && e5.doc._attachments) {
        var n3 = Object.keys(e5.doc._attachments);
        return Promise.all(n3.map(function(n4) {
          var r2 = e5.doc._attachments[n4];
          if ("body" in r2) {
            var o3 = r2.body, i2 = r2.content_type;
            return new Promise(function(s2) {
              Yt(o3, i2, t4, function(t5) {
                e5.doc._attachments[n4] = R(x(r2, ["digest", "content_type"]), { data: t5 }), s2();
              });
            });
          }
        }));
      }
    }));
  }
  function Zt(e4, t4, n3) {
    var r2 = [], o3 = n3.objectStore(Mt), i2 = n3.objectStore(Nt), s2 = n3.objectStore(Ut), a2 = e4.length;
    function u2() {
      --a2 || r2.length && r2.forEach(function(e5) {
        s2.index("digestSeq").count(IDBKeyRange.bound(e5 + "::", e5 + "::\uFFFF", false, false)).onsuccess = function(t5) {
          t5.target.result || i2.delete(e5);
        };
      });
    }
    e4.forEach(function(e5) {
      var n4 = o3.index("_doc_id_rev"), i3 = t4 + "::" + e5;
      n4.getKey(i3).onsuccess = function(e6) {
        var t5 = e6.target.result;
        if (typeof t5 != "number")
          return u2();
        o3.delete(t5), s2.index("seq").openCursor(IDBKeyRange.only(t5)).onsuccess = function(e7) {
          var t6 = e7.target.result;
          if (t6) {
            var n5 = t6.value.digestSeq.split("::")[0];
            r2.push(n5), s2.delete(t6.primaryKey), t6.continue();
          } else
            u2();
        };
      };
    });
  }
  function en(e4, t4, n3) {
    try {
      return { txn: e4.transaction(t4, n3) };
    } catch (e5) {
      return { error: e5 };
    }
  }
  var tn = new D();
  function nn(e4, t4, n3, r2, o3, i2) {
    for (var s2, u2, c2, f2, l2, d2, h2, p2, v2 = t4.docs, y2 = 0, _2 = v2.length; y2 < _2; y2++) {
      var g2 = v2[y2];
      g2._id && Ve(g2._id) || (g2 = v2[y2] = It(g2, n3.new_edits, e4)).error && !h2 && (h2 = g2);
    }
    if (h2)
      return i2(h2);
    var m2 = false, b2 = 0, w2 = new Array(v2.length), k2 = new a(), j2 = false, O2 = r2._meta.blobSupport ? "blob" : "base64";
    function A2() {
      m2 = true, q2();
    }
    function q2() {
      p2 && m2 && (p2.docCount += b2, d2.put(p2));
    }
    function S2() {
      j2 || (tn.notify(r2._meta.name), i2(null, w2));
    }
    function x2(e5, t5, n4, r3, o4, i3, s3, a2) {
      e5.metadata.winningRev = t5, e5.metadata.deleted = n4;
      var u3 = e5.data;
      if (u3._id = e5.metadata.id, u3._rev = e5.metadata.rev, r3 && (u3._deleted = true), u3._attachments && Object.keys(u3._attachments).length)
        return function(e6, t6, n5, r4, o5, i4) {
          var s4 = e6.data, a3 = 0, u4 = Object.keys(s4._attachments);
          function c3() {
            a3 === u4.length && E2(e6, t6, n5, r4, o5, i4);
          }
          function l3() {
            a3++, c3();
          }
          u4.forEach(function(n6) {
            var r5 = e6.data._attachments[n6];
            if (r5.stub)
              a3++, c3();
            else {
              var o6 = r5.data;
              delete r5.data, r5.revpos = parseInt(t6, 10), function(e7, t7, n7) {
                f2.count(e7).onsuccess = function(r6) {
                  if (r6.target.result)
                    return n7();
                  var o7 = { digest: e7, body: t7 };
                  f2.put(o7).onsuccess = n7;
                };
              }(r5.digest, o6, l3);
            }
          });
        }(e5, t5, n4, o4, s3, a2);
      b2 += i3, q2(), E2(e5, t5, n4, o4, s3, a2);
    }
    function E2(e5, t5, n4, o4, i3, a2) {
      var f3 = e5.data, d3 = e5.metadata;
      function h3(i4) {
        var a3 = e5.stemmedRevs || [];
        o4 && r2.auto_compaction && (a3 = a3.concat(function(e6) {
          var t6 = [];
          return Le(e6.rev_tree, function(e7, n5, r3, o5, i5) {
            i5.status !== "available" || e7 || (t6.push(n5 + "-" + r3), i5.status = "missing");
          }), t6;
        }(e5.metadata))), a3 && a3.length && Zt(a3, e5.metadata.id, s2), d3.seq = i4.target.result;
        var c3 = Gt(d3, t5, n4);
        u2.put(c3).onsuccess = p3;
      }
      function p3() {
        w2[i3] = { ok: true, id: d3.id, rev: d3.rev }, k2.set(e5.metadata.id, e5.metadata), function(e6, t6, n5) {
          var r3 = 0, o5 = Object.keys(e6.data._attachments || {});
          if (!o5.length)
            return n5();
          function i4() {
            ++r3 === o5.length && n5();
          }
          function s3(n6) {
            var r4 = e6.data._attachments[n6].digest, o6 = l2.put({ seq: t6, digestSeq: r4 + "::" + t6 });
            o6.onsuccess = i4, o6.onerror = function(e7) {
              e7.preventDefault(), e7.stopPropagation(), i4();
            };
          }
          for (var a3 = 0; a3 < o5.length; a3++)
            s3(o5[a3]);
        }(e5, d3.seq, a2);
      }
      f3._doc_id_rev = d3.id + "::" + d3.rev, delete f3._id, delete f3._rev;
      var v3 = c2.put(f3);
      v3.onsuccess = h3, v3.onerror = function(e6) {
        e6.preventDefault(), e6.stopPropagation(), c2.index("_doc_id_rev").getKey(f3._doc_id_rev).onsuccess = function(e7) {
          c2.put(f3, e7.target.result).onsuccess = h3;
        };
      };
    }
    !function(e5, t5, n4) {
      if (!e5.length)
        return n4();
      var r3, o4 = 0;
      function i3() {
        o4++, e5.length === o4 && (r3 ? n4(r3) : n4());
      }
      e5.forEach(function(e6) {
        var n5 = e6.data && e6.data._attachments ? Object.keys(e6.data._attachments) : [], o5 = 0;
        if (!n5.length)
          return i3();
        function s3(e7) {
          r3 = e7, ++o5 === n5.length && i3();
        }
        for (var a2 in e6.data._attachments)
          e6.data._attachments.hasOwnProperty(a2) && Bt(e6.data._attachments[a2], t5, s3);
      });
    }(v2, O2, function(t5) {
      if (t5)
        return i2(t5);
      !function() {
        var t6 = en(o3, [Tt, Mt, Nt, Kt, Ut, Ft], "readwrite");
        if (t6.error)
          return i2(t6.error);
        (s2 = t6.txn).onabort = Vt(i2), s2.ontimeout = Vt(i2), s2.oncomplete = S2, u2 = s2.objectStore(Tt), c2 = s2.objectStore(Mt), f2 = s2.objectStore(Nt), l2 = s2.objectStore(Ut), (d2 = s2.objectStore(Ft)).get(Ft).onsuccess = function(e5) {
          p2 = e5.target.result, q2();
        }, function(e5) {
          var t7 = [];
          if (v2.forEach(function(e6) {
            e6.data && e6.data._attachments && Object.keys(e6.data._attachments).forEach(function(n5) {
              var r4 = e6.data._attachments[n5];
              r4.stub && t7.push(r4.digest);
            });
          }), !t7.length)
            return e5();
          var n4, r3 = 0;
          t7.forEach(function(o4) {
            !function(e6, t8) {
              f2.get(e6).onsuccess = function(n5) {
                if (n5.target.result)
                  t8();
                else {
                  var r4 = ee(Z, "unknown stub attachment with digest " + e6);
                  r4.status = 412, t8(r4);
                }
              };
            }(o4, function(o5) {
              o5 && !n4 && (n4 = o5), ++r3 === t7.length && e5(n4);
            });
          });
        }(function(t7) {
          if (t7)
            return j2 = true, i2(t7);
          !function() {
            if (v2.length)
              for (var t8 = 0, o4 = 0, i3 = v2.length; o4 < i3; o4++) {
                var a2 = v2[o4];
                a2._id && Ve(a2._id) ? c3() : u2.get(a2.metadata.id).onsuccess = f3;
              }
            function c3() {
              ++t8 === v2.length && Rt(e4.revs_limit, v2, r2, k2, s2, w2, x2, n3, A2);
            }
            function f3(e5) {
              var t9 = Qt(e5.target.result);
              t9 && k2.set(t9.id, t9), c3();
            }
          }();
        });
      }();
    });
  }
  function rn(e4, t4, n3, r2, o3) {
    var i2, s2, a2;
    function u2(e5) {
      s2 = e5.target.result, i2 && o3(i2, s2, a2);
    }
    function c2(e5) {
      i2 = e5.target.result, s2 && o3(i2, s2, a2);
    }
    function f2(e5) {
      var t5 = e5.target.result;
      if (!t5)
        return o3();
      o3([t5.key], [t5.value], t5);
    }
    r2 === -1 && (r2 = 1e3), typeof e4.getAll == "function" && typeof e4.getAllKeys == "function" && r2 > 1 && !n3 ? (a2 = { continue: function() {
      if (!i2.length)
        return o3();
      var n4, a3 = i2[i2.length - 1];
      if (t4 && t4.upper)
        try {
          n4 = IDBKeyRange.bound(a3, t4.upper, true, t4.upperOpen);
        } catch (e5) {
          if (e5.name === "DataError" && e5.code === 0)
            return o3();
        }
      else
        n4 = IDBKeyRange.lowerBound(a3, true);
      t4 = n4, i2 = null, s2 = null, e4.getAll(t4, r2).onsuccess = u2, e4.getAllKeys(t4, r2).onsuccess = c2;
    } }, e4.getAll(t4, r2).onsuccess = u2, e4.getAllKeys(t4, r2).onsuccess = c2) : n3 ? e4.openCursor(t4, "prev").onsuccess = f2 : e4.openCursor(t4).onsuccess = f2;
  }
  function on(e4, t4, n3) {
    var r2, o3, i2 = "startkey" in e4 && e4.startkey, s2 = "endkey" in e4 && e4.endkey, a2 = "key" in e4 && e4.key, u2 = "keys" in e4 && e4.keys, c2 = e4.skip || 0, f2 = typeof e4.limit == "number" ? e4.limit : -1, l2 = e4.inclusive_end !== false;
    if (!u2 && (r2 = function(e5, t5, n4, r3, o4) {
      try {
        if (e5 && t5)
          return o4 ? IDBKeyRange.bound(t5, e5, !n4, false) : IDBKeyRange.bound(e5, t5, false, !n4);
        if (e5)
          return o4 ? IDBKeyRange.upperBound(e5) : IDBKeyRange.lowerBound(e5);
        if (t5)
          return o4 ? IDBKeyRange.lowerBound(t5, !n4) : IDBKeyRange.upperBound(t5, !n4);
        if (r3)
          return IDBKeyRange.only(r3);
      } catch (e6) {
        return { error: e6 };
      }
      return null;
    }(i2, s2, l2, a2, e4.descending), (o3 = r2 && r2.error) && (o3.name !== "DataError" || o3.code !== 0)))
      return n3(ee(H, o3.name, o3.message));
    var d2 = [Tt, Mt, Ft];
    e4.attachments && d2.push(Nt);
    var h2 = en(t4, d2, "readonly");
    if (h2.error)
      return n3(h2.error);
    var p2 = h2.txn;
    p2.oncomplete = function() {
      e4.attachments ? Xt(w2, e4.binary).then(A2) : A2();
    }, p2.onabort = Vt(n3);
    var v2, y2, _2 = p2.objectStore(Tt), g2 = p2.objectStore(Mt), m2 = p2.objectStore(Ft), b2 = g2.index("_doc_id_rev"), w2 = [];
    function k2(t5, n4) {
      var r3 = { id: n4.id, key: n4.id, value: { rev: t5 } };
      n4.deleted ? u2 && (w2.push(r3), r3.value.deleted = true, r3.doc = null) : c2-- <= 0 && (w2.push(r3), e4.include_docs && function(t6, n5, r4) {
        var o4 = t6.id + "::" + r4;
        b2.get(o4).onsuccess = function(r5) {
          if (n5.doc = Wt(r5.target.result) || {}, e4.conflicts) {
            var o5 = Ie(t6);
            o5.length && (n5.doc._conflicts = o5);
          }
          Ht(n5.doc, e4, p2);
        };
      }(n4, r3, t5));
    }
    function j2(e5) {
      for (var t5 = 0, n4 = e5.length; t5 < n4 && w2.length !== f2; t5++) {
        var r3 = e5[t5];
        if (r3.error && u2)
          w2.push(r3);
        else {
          var o4 = Qt(r3);
          k2(o4.winningRev, o4);
        }
      }
    }
    function O2(e5, t5, n4) {
      n4 && (j2(t5), w2.length < f2 && n4.continue());
    }
    function A2() {
      var t5 = { total_rows: v2, offset: e4.skip, rows: w2 };
      e4.update_seq && y2 !== void 0 && (t5.update_seq = y2), n3(null, t5);
    }
    return m2.get(Ft).onsuccess = function(e5) {
      v2 = e5.target.result.docCount;
    }, e4.update_seq && (g2.openCursor(null, "prev").onsuccess = function(e5) {
      var t5 = e5.target.result, n4 = void 0;
      return t5 && t5.key && (n4 = t5.key), function(e6) {
        e6.target.result && e6.target.result.length > 0 && (y2 = e6.target.result[0]);
      }({ target: { result: [n4] } });
    }), o3 || f2 === 0 ? void 0 : u2 ? function(e5, t5, n4) {
      var r3 = new Array(e5.length), o4 = 0;
      e5.forEach(function(i3, s3) {
        t5.get(i3).onsuccess = function(t6) {
          t6.target.result ? r3[s3] = t6.target.result : r3[s3] = { key: i3, error: "not_found" }, ++o4 === e5.length && n4(e5, r3, {});
        };
      });
    }(e4.keys, _2, O2) : f2 === -1 ? function(e5, t5, n4) {
      if (typeof e5.getAll != "function") {
        var r3 = [];
        e5.openCursor(t5).onsuccess = function(e6) {
          var t6 = e6.target.result;
          t6 ? (r3.push(t6.value), t6.continue()) : n4({ target: { result: r3 } });
        };
      } else
        e5.getAll(t5).onsuccess = n4;
    }(_2, r2, function(t5) {
      var n4 = t5.target.result;
      e4.descending && (n4 = n4.reverse()), j2(n4);
    }) : void rn(_2, r2, e4.descending, f2 + c2, O2);
  }
  var sn = false, an = [];
  function un() {
    !sn && an.length && (sn = true, an.shift()());
  }
  var cn, fn = new a(), ln = new a();
  function dn(e4, n3) {
    var r2 = this;
    !function(n4, o3, i2) {
      an.push(function() {
        var n5;
        n5 = function(e5, n6) {
          !function(e6, t4, n7, r3) {
            try {
              e6(t4, n7);
            } catch (t5) {
              r3.emit("error", t5);
            }
          }(o3, e5, n6, i2), sn = false, t3()(function() {
            un();
          });
        }, function(e5, n6, r3) {
          var o4 = n6.name, i3 = null;
          function u2(e6) {
            var t4 = e6.createObjectStore(Tt, { keyPath: "id" });
            e6.createObjectStore(Mt, { autoIncrement: true }).createIndex("_doc_id_rev", "_doc_id_rev", { unique: true }), e6.createObjectStore(Nt, { keyPath: "digest" }), e6.createObjectStore(Ft, { keyPath: "id", autoIncrement: false }), e6.createObjectStore(Jt), t4.createIndex("deletedOrLocal", "deletedOrLocal", { unique: false }), e6.createObjectStore(Kt, { keyPath: "_id" });
            var n7 = e6.createObjectStore(Ut, { autoIncrement: true });
            n7.createIndex("seq", "seq"), n7.createIndex("digestSeq", "digestSeq", { unique: true });
          }
          function c2(e6, t4) {
            var n7 = e6.objectStore(Tt);
            n7.createIndex("deletedOrLocal", "deletedOrLocal", { unique: false }), n7.openCursor().onsuccess = function(e7) {
              var r4 = e7.target.result;
              if (r4) {
                var o5 = r4.value, i4 = ze(o5);
                o5.deletedOrLocal = i4 ? "1" : "0", n7.put(o5), r4.continue();
              } else
                t4();
            };
          }
          function f2(e6) {
            e6.createObjectStore(Kt, { keyPath: "_id" }).createIndex("_doc_id_rev", "_doc_id_rev", { unique: true });
          }
          function l2(e6, t4) {
            var n7 = e6.objectStore(Kt), r4 = e6.objectStore(Tt), o5 = e6.objectStore(Mt);
            r4.openCursor().onsuccess = function(e7) {
              var i4 = e7.target.result;
              if (i4) {
                var s2 = i4.value, a2 = s2.id, u3 = Ve(a2), c3 = Pe(s2);
                if (u3) {
                  var f3 = a2 + "::" + c3, l3 = a2 + "::", d3 = a2 + "::~", h3 = o5.index("_doc_id_rev"), p3 = IDBKeyRange.bound(l3, d3, false, false), v3 = h3.openCursor(p3);
                  v3.onsuccess = function(e8) {
                    if (v3 = e8.target.result) {
                      var t5 = v3.value;
                      t5._doc_id_rev === f3 && n7.put(t5), o5.delete(v3.primaryKey), v3.continue();
                    } else
                      r4.delete(i4.primaryKey), i4.continue();
                  };
                } else
                  i4.continue();
              } else
                t4 && t4();
            };
          }
          function d2(e6) {
            var t4 = e6.createObjectStore(Ut, { autoIncrement: true });
            t4.createIndex("seq", "seq"), t4.createIndex("digestSeq", "digestSeq", { unique: true });
          }
          function h2(e6, t4) {
            var n7 = e6.objectStore(Mt), r4 = e6.objectStore(Nt), o5 = e6.objectStore(Ut);
            r4.count().onsuccess = function(e7) {
              if (!e7.target.result)
                return t4();
              n7.openCursor().onsuccess = function(e8) {
                var n8 = e8.target.result;
                if (!n8)
                  return t4();
                for (var r5 = n8.value, i4 = n8.primaryKey, s2 = Object.keys(r5._attachments || {}), a2 = {}, u3 = 0; u3 < s2.length; u3++)
                  a2[r5._attachments[s2[u3]].digest] = true;
                var c3 = Object.keys(a2);
                for (u3 = 0; u3 < c3.length; u3++) {
                  var f3 = c3[u3];
                  o5.put({ seq: i4, digestSeq: f3 + "::" + i4 });
                }
                n8.continue();
              };
            };
          }
          function p2(e6) {
            function t4(e7) {
              return e7.data ? Qt(e7) : (e7.deleted = e7.deletedOrLocal === "1", e7);
            }
            var n7 = e6.objectStore(Mt), r4 = e6.objectStore(Tt);
            r4.openCursor().onsuccess = function(e7) {
              var o5 = e7.target.result;
              if (o5) {
                var i4 = t4(o5.value);
                if (i4.winningRev = i4.winningRev || Pe(i4), i4.seq)
                  return a2();
                s2();
              }
              function s2() {
                var e8 = i4.id + "::", t5 = i4.id + "::\uFFFF", r5 = n7.index("_doc_id_rev").openCursor(IDBKeyRange.bound(e8, t5)), o6 = 0;
                r5.onsuccess = function(e9) {
                  var t6 = e9.target.result;
                  if (!t6)
                    return i4.seq = o6, a2();
                  var n8 = t6.primaryKey;
                  n8 > o6 && (o6 = n8), t6.continue();
                };
              }
              function a2() {
                var e8 = Gt(i4, i4.winningRev, i4.deleted);
                r4.put(e8).onsuccess = function() {
                  o5.continue();
                };
              }
            };
          }
          e5._meta = null, e5._remote = false, e5.type = function() {
            return "idb";
          }, e5._id = q(function(t4) {
            t4(null, e5._meta.instanceId);
          }), e5._bulkDocs = function(t4, r4, o5) {
            nn(n6, t4, r4, e5, i3, o5);
          }, e5._get = function(e6, t4, n7) {
            var r4, o5, s2, a2 = t4.ctx;
            if (!a2) {
              var u3 = en(i3, [Tt, Mt, Nt], "readonly");
              if (u3.error)
                return n7(u3.error);
              a2 = u3.txn;
            }
            function c3() {
              n7(s2, { doc: r4, metadata: o5, ctx: a2 });
            }
            a2.objectStore(Tt).get(e6).onsuccess = function(e7) {
              if (!(o5 = Qt(e7.target.result)))
                return s2 = ee(N, "missing"), c3();
              var n8;
              if (t4.rev)
                n8 = t4.latest ? function(e8, t5) {
                  for (var n9, r5 = t5.rev_tree.slice(); n9 = r5.pop(); ) {
                    var o6 = n9.pos, i5 = n9.ids, s3 = i5[0], a3 = i5[1], u5 = i5[2], c4 = u5.length === 0, f3 = n9.history ? n9.history.slice() : [];
                    if (f3.push({ id: s3, pos: o6, opts: a3 }), c4)
                      for (var l3 = 0, d3 = f3.length; l3 < d3; l3++) {
                        var h3 = f3[l3];
                        if (h3.pos + "-" + h3.id === e8)
                          return o6 + "-" + s3;
                      }
                    for (var p3 = 0, v3 = u5.length; p3 < v3; p3++)
                      r5.push({ pos: o6 + 1, ids: u5[p3], history: f3 });
                  }
                  throw new Error("Unable to resolve latest revision for id " + t5.id + ", rev " + e8);
                }(t4.rev, o5) : t4.rev;
              else if (n8 = o5.winningRev, ze(o5))
                return s2 = ee(N, "deleted"), c3();
              var i4 = a2.objectStore(Mt), u4 = o5.id + "::" + n8;
              i4.index("_doc_id_rev").get(u4).onsuccess = function(e8) {
                if ((r4 = e8.target.result) && (r4 = Wt(r4)), !r4)
                  return s2 = ee(N, "missing"), c3();
                c3();
              };
            };
          }, e5._getAttachment = function(e6, t4, n7, r4, o5) {
            var s2;
            if (r4.ctx)
              s2 = r4.ctx;
            else {
              var a2 = en(i3, [Tt, Mt, Nt], "readonly");
              if (a2.error)
                return o5(a2.error);
              s2 = a2.txn;
            }
            var u3 = n7.digest, c3 = n7.content_type;
            s2.objectStore(Nt).get(u3).onsuccess = function(e7) {
              Yt(e7.target.result.body, c3, r4.binary, function(e8) {
                o5(null, e8);
              });
            };
          }, e5._info = function(t4) {
            var n7, r4, o5 = en(i3, [Ft, Mt], "readonly");
            if (o5.error)
              return t4(o5.error);
            var s2 = o5.txn;
            s2.objectStore(Ft).get(Ft).onsuccess = function(e6) {
              r4 = e6.target.result.docCount;
            }, s2.objectStore(Mt).openCursor(null, "prev").onsuccess = function(e6) {
              var t5 = e6.target.result;
              n7 = t5 ? t5.key : 0;
            }, s2.oncomplete = function() {
              t4(null, { doc_count: r4, update_seq: n7, idb_attachment_format: e5._meta.blobSupport ? "binary" : "base64" });
            };
          }, e5._allDocs = function(e6, t4) {
            on(e6, i3, t4);
          }, e5._changes = function(t4) {
            return function(e6, t5, n7, r4) {
              if ((e6 = O(e6)).continuous) {
                var o5 = n7 + ":" + Ce();
                return tn.addListener(n7, o5, t5, e6), tn.notify(n7), { cancel: function() {
                  tn.removeListener(n7, o5);
                } };
              }
              var i4 = e6.doc_ids && new s(e6.doc_ids);
              e6.since = e6.since || 0;
              var u3 = e6.since, c3 = "limit" in e6 ? e6.limit : -1;
              c3 === 0 && (c3 = 1);
              var f3, l3, d3, h3, p3 = [], v3 = 0, y3 = ne(e6), _2 = new a();
              function g2(e7, t6, n8, r5) {
                if (n8.seq !== t6)
                  return r5();
                if (n8.winningRev === e7._rev)
                  return r5(n8, e7);
                var o6 = e7._id + "::" + n8.winningRev;
                h3.get(o6).onsuccess = function(e8) {
                  r5(n8, Wt(e8.target.result));
                };
              }
              function m2() {
                e6.complete(null, { results: p3, last_seq: u3 });
              }
              var b2 = [Tt, Mt];
              e6.attachments && b2.push(Nt);
              var w2 = en(r4, b2, "readonly");
              if (w2.error)
                return e6.complete(w2.error);
              (f3 = w2.txn).onabort = Vt(e6.complete), f3.oncomplete = function() {
                !e6.continuous && e6.attachments ? Xt(p3).then(m2) : m2();
              }, l3 = f3.objectStore(Mt), d3 = f3.objectStore(Tt), h3 = l3.index("_doc_id_rev"), rn(l3, e6.since && !e6.descending ? IDBKeyRange.lowerBound(e6.since, true) : null, e6.descending, c3, function(t6, n8, r5) {
                if (r5 && t6.length) {
                  var o6 = new Array(t6.length), s2 = new Array(t6.length), a2 = 0;
                  n8.forEach(function(n9, u4) {
                    !function(e7, t7, n10) {
                      if (i4 && !i4.has(e7._id))
                        return n10();
                      var r6 = _2.get(e7._id);
                      if (r6)
                        return g2(e7, t7, r6, n10);
                      d3.get(e7._id).onsuccess = function(o7) {
                        r6 = Qt(o7.target.result), _2.set(e7._id, r6), g2(e7, t7, r6, n10);
                      };
                    }(Wt(n9), t6[u4], function(n10, i5) {
                      s2[u4] = n10, o6[u4] = i5, ++a2 === t6.length && function() {
                        for (var t7 = [], n11 = 0, i6 = o6.length; n11 < i6 && v3 !== c3; n11++) {
                          var a3 = o6[n11];
                          if (a3) {
                            var u5 = s2[n11];
                            t7.push(l4(u5, a3));
                          }
                        }
                        Promise.all(t7).then(function(t8) {
                          for (var n12 = 0, r6 = t8.length; n12 < r6; n12++)
                            t8[n12] && e6.onChange(t8[n12]);
                        }).catch(e6.complete), v3 !== c3 && r5.continue();
                      }();
                    });
                  });
                }
                function l4(t7, n9) {
                  var r6 = e6.processChange(n9, t7, e6);
                  u3 = r6.seq = t7.seq;
                  var o7 = y3(r6);
                  return typeof o7 == "object" ? Promise.reject(o7) : o7 ? (v3++, e6.return_docs && p3.push(r6), e6.attachments && e6.include_docs ? new Promise(function(t8) {
                    Ht(n9, e6, f3, function() {
                      Xt([r6], e6.binary).then(function() {
                        t8(r6);
                      });
                    });
                  }) : Promise.resolve(r6)) : Promise.resolve();
                }
              });
            }(t4, e5, o4, i3);
          }, e5._close = function(e6) {
            i3.close(), fn.delete(o4), e6();
          }, e5._getRevisionTree = function(e6, t4) {
            var n7 = en(i3, [Tt], "readonly");
            if (n7.error)
              return t4(n7.error);
            n7.txn.objectStore(Tt).get(e6).onsuccess = function(e7) {
              var n8 = Qt(e7.target.result);
              n8 ? t4(null, n8.rev_tree) : t4(ee(N));
            };
          }, e5._doCompaction = function(e6, t4, n7) {
            var r4 = en(i3, [Tt, Mt, Nt, Ut], "readwrite");
            if (r4.error)
              return n7(r4.error);
            var o5 = r4.txn;
            o5.objectStore(Tt).get(e6).onsuccess = function(n8) {
              var r5 = Qt(n8.target.result);
              Le(r5.rev_tree, function(e7, n9, r6, o6, i5) {
                var s3 = n9 + "-" + r6;
                t4.indexOf(s3) !== -1 && (i5.status = "missing");
              }), Zt(t4, e6, o5);
              var i4 = r5.winningRev, s2 = r5.deleted;
              o5.objectStore(Tt).put(Gt(r5, i4, s2));
            }, o5.onabort = Vt(n7), o5.oncomplete = function() {
              n7();
            };
          }, e5._getLocal = function(e6, t4) {
            var n7 = en(i3, [Kt], "readonly");
            if (n7.error)
              return t4(n7.error);
            var r4 = n7.txn.objectStore(Kt).get(e6);
            r4.onerror = Vt(t4), r4.onsuccess = function(e7) {
              var n8 = e7.target.result;
              n8 ? (delete n8._doc_id_rev, t4(null, n8)) : t4(ee(N));
            };
          }, e5._putLocal = function(e6, t4, n7) {
            typeof t4 == "function" && (n7 = t4, t4 = {}), delete e6._revisions;
            var r4 = e6._rev, o5 = e6._id;
            e6._rev = r4 ? "0-" + (parseInt(r4.split("-")[1], 10) + 1) : "0-1";
            var s2, a2 = t4.ctx;
            if (!a2) {
              var u3 = en(i3, [Kt], "readwrite");
              if (u3.error)
                return n7(u3.error);
              (a2 = u3.txn).onerror = Vt(n7), a2.oncomplete = function() {
                s2 && n7(null, s2);
              };
            }
            var c3, f3 = a2.objectStore(Kt);
            r4 ? (c3 = f3.get(o5)).onsuccess = function(o6) {
              var i4 = o6.target.result;
              i4 && i4._rev === r4 ? f3.put(e6).onsuccess = function() {
                s2 = { ok: true, id: e6._id, rev: e6._rev }, t4.ctx && n7(null, s2);
              } : n7(ee(U));
            } : ((c3 = f3.add(e6)).onerror = function(e7) {
              n7(ee(U)), e7.preventDefault(), e7.stopPropagation();
            }, c3.onsuccess = function() {
              s2 = { ok: true, id: e6._id, rev: e6._rev }, t4.ctx && n7(null, s2);
            });
          }, e5._removeLocal = function(e6, t4, n7) {
            typeof t4 == "function" && (n7 = t4, t4 = {});
            var r4, o5 = t4.ctx;
            if (!o5) {
              var s2 = en(i3, [Kt], "readwrite");
              if (s2.error)
                return n7(s2.error);
              (o5 = s2.txn).oncomplete = function() {
                r4 && n7(null, r4);
              };
            }
            var a2 = e6._id, u3 = o5.objectStore(Kt), c3 = u3.get(a2);
            c3.onerror = Vt(n7), c3.onsuccess = function(o6) {
              var i4 = o6.target.result;
              i4 && i4._rev === e6._rev ? (u3.delete(a2), r4 = { ok: true, id: a2, rev: "0-0" }, t4.ctx && n7(null, r4)) : n7(ee(N));
            };
          }, e5._destroy = function(e6, t4) {
            tn.removeAllListeners(o4);
            var n7 = ln.get(o4);
            n7 && n7.result && (n7.result.close(), fn.delete(o4));
            var r4 = indexedDB.deleteDatabase(o4);
            r4.onsuccess = function() {
              ln.delete(o4), L() && o4 in localStorage && delete localStorage[o4], t4(null, { ok: true });
            }, r4.onerror = Vt(t4);
          };
          var v2 = fn.get(o4);
          if (v2)
            return i3 = v2.idb, e5._meta = v2.global, t3()(function() {
              r3(null, e5);
            });
          var y2 = indexedDB.open(o4, 5);
          ln.set(o4, y2), y2.onupgradeneeded = function(e6) {
            var t4 = e6.target.result;
            if (e6.oldVersion < 1)
              return u2(t4);
            var n7 = e6.currentTarget.transaction;
            e6.oldVersion < 3 && f2(t4), e6.oldVersion < 4 && d2(t4);
            var r4 = [c2, l2, h2, p2], o5 = e6.oldVersion;
            function i4() {
              var e7 = r4[o5 - 1];
              o5++, e7 && e7(n7, i4);
            }
            i4();
          }, y2.onsuccess = function(t4) {
            (i3 = t4.target.result).onversionchange = function() {
              i3.close(), fn.delete(o4);
            }, i3.onabort = function(e6) {
              $("error", "Database has a global failure", e6.target.error), i3.close(), fn.delete(o4);
            };
            var n7, s2, a2, u3, c3 = i3.transaction([Ft, Jt, Tt], "readwrite"), f3 = false;
            function l3() {
              a2 !== void 0 && f3 && (e5._meta = { name: o4, instanceId: u3, blobSupport: a2 }, fn.set(o4, { idb: i3, global: e5._meta }), r3(null, e5));
            }
            function d3() {
              if (s2 !== void 0 && n7 !== void 0) {
                var e6 = o4 + "_id";
                e6 in n7 ? u3 = n7[e6] : n7[e6] = u3 = Ce(), n7.docCount = s2, c3.objectStore(Ft).put(n7);
              }
            }
            c3.objectStore(Ft).get(Ft).onsuccess = function(e6) {
              n7 = e6.target.result || { id: Ft }, d3();
            }, function(e6, t5) {
              e6.objectStore(Tt).index("deletedOrLocal").count(IDBKeyRange.only("0")).onsuccess = function(e7) {
                t5(e7.target.result);
              };
            }(c3, function(e6) {
              s2 = e6, d3();
            }), cn || (cn = function(e6) {
              return new Promise(function(t5) {
                var n8 = _e([""]), r4 = e6.objectStore(Jt).put(n8, "key");
                r4.onsuccess = function() {
                  var e7 = navigator.userAgent.match(/Chrome\/(\d+)/), n9 = navigator.userAgent.match(/Edge\//);
                  t5(n9 || !e7 || parseInt(e7[1], 10) >= 43);
                }, r4.onerror = e6.onabort = function(e7) {
                  e7.preventDefault(), e7.stopPropagation(), t5(false);
                };
              }).catch(function() {
                return false;
              });
            }(c3)), cn.then(function(e6) {
              a2 = e6, l3();
            }), c3.oncomplete = function() {
              f3 = true, l3();
            }, c3.onabort = Vt(r3);
          }, y2.onerror = function(e6) {
            var t4 = e6.target.error && e6.target.error.message;
            t4 ? t4.indexOf("stored database is a higher version") !== -1 && (t4 = new Error('This DB was created with the newer "indexeddb" adapter, but you are trying to open it with the older "idb" adapter')) : t4 = "Failed to open indexedDB, are you in private browsing mode?", $("error", t4), r3(ee(H, t4));
          };
        }(r2, e4, n5);
      }), un();
    }(0, n3, r2.constructor);
  }
  dn.valid = function() {
    try {
      return typeof indexedDB != "undefined" && typeof IDBKeyRange != "undefined";
    } catch (e4) {
      return false;
    }
  };
  var hn = 5e3, pn = {};
  function vn(e4) {
    var t4 = e4.doc || e4.ok, n3 = t4 && t4._attachments;
    n3 && Object.keys(n3).forEach(function(e5) {
      var t5 = n3[e5];
      t5.data = be(t5.data, t5.content_type);
    });
  }
  function yn(e4) {
    return /^_design/.test(e4) ? "_design/" + encodeURIComponent(e4.slice(8)) : /^_local/.test(e4) ? "_local/" + encodeURIComponent(e4.slice(7)) : encodeURIComponent(e4);
  }
  function _n(e4) {
    return e4._attachments && Object.keys(e4._attachments) ? Promise.all(Object.keys(e4._attachments).map(function(t4) {
      var n3 = e4._attachments[t4];
      if (n3.data && typeof n3.data != "string")
        return new Promise(function(e5) {
          je(n3.data, e5);
        }).then(function(e5) {
          n3.data = e5;
        });
    })) : Promise.resolve();
  }
  function gn(e4, t4) {
    return mn(e4, e4.db + "/" + t4);
  }
  function mn(e4, t4) {
    var n3 = e4.path ? "/" : "";
    return e4.protocol + "://" + e4.host + (e4.port ? ":" + e4.port : "") + "/" + e4.path + n3 + t4;
  }
  function bn(e4) {
    return "?" + Object.keys(e4).map(function(t4) {
      return t4 + "=" + encodeURIComponent(e4[t4]);
    }).join("&");
  }
  function wn(e4, n3) {
    var r2 = this, o3 = function(e5, t4) {
      if (function(e6) {
        if (!e6.prefix)
          return false;
        var t5 = de(e6.prefix).protocol;
        return t5 === "http" || t5 === "https";
      }(t4)) {
        var n4 = t4.name.substr(t4.prefix.length);
        e5 = t4.prefix.replace(/\/?$/, "/") + encodeURIComponent(n4);
      }
      var r3 = de(e5);
      (r3.user || r3.password) && (r3.auth = { username: r3.user, password: r3.password });
      var o4 = r3.path.replace(/(^\/|\/$)/g, "").split("/");
      return r3.db = o4.pop(), r3.db.indexOf("%") === -1 && (r3.db = encodeURIComponent(r3.db)), r3.path = o4.join("/"), r3;
    }(e4.name, e4), i2 = gn(o3, "");
    e4 = O(e4);
    var s2, a2 = function(t4, n4) {
      if ((n4 = n4 || {}).headers = n4.headers || new ot(), n4.credentials = "include", e4.auth || o3.auth) {
        var r3 = e4.auth || o3.auth, i3 = r3.username + ":" + r3.password, s3 = ye(unescape(encodeURIComponent(i3)));
        n4.headers.set("Authorization", "Basic " + s3);
      }
      var a3 = e4.headers || {};
      return Object.keys(a3).forEach(function(e5) {
        n4.headers.append(e5, a3[e5]);
      }), function(e5) {
        var t5 = typeof navigator != "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", n5 = t5.indexOf("msie") !== -1, r4 = t5.indexOf("trident") !== -1, o4 = t5.indexOf("edge") !== -1, i4 = !("method" in e5) || e5.method === "GET";
        return (n5 || r4 || o4) && i4;
      }(n4) && (t4 += (t4.indexOf("?") === -1 ? "?" : "&") + "_nonce=" + Date.now()), (e4.fetch || rt)(t4, n4);
    };
    function u2(e5, t4) {
      return S(e5, d()(function(e6) {
        f2().then(function() {
          return t4.apply(this, e6);
        }).catch(function(t5) {
          e6.pop()(t5);
        });
      })).bind(r2);
    }
    function c2(e5, t4, n4) {
      var r3 = {};
      return (t4 = t4 || {}).headers = t4.headers || new ot(), t4.headers.get("Content-Type") || t4.headers.set("Content-Type", "application/json"), t4.headers.get("Accept") || t4.headers.set("Accept", "application/json"), a2(e5, t4).then(function(e6) {
        return r3.ok = e6.ok, r3.status = e6.status, e6.json();
      }).then(function(e6) {
        if (r3.data = e6, !r3.ok) {
          r3.data.status = r3.status;
          var t5 = te(r3.data);
          if (n4)
            return n4(t5);
          throw t5;
        }
        if (Array.isArray(r3.data) && (r3.data = r3.data.map(function(e7) {
          return e7.error || e7.missing ? te(e7) : e7;
        })), !n4)
          return r3;
        n4(null, r3.data);
      });
    }
    function f2() {
      return e4.skip_setup ? Promise.resolve() : s2 || ((s2 = c2(i2).catch(function(e5) {
        return e5 && e5.status && e5.status === 404 ? (B(404, "PouchDB is just detecting if the remote exists."), c2(i2, { method: "PUT" })) : Promise.reject(e5);
      }).catch(function(e5) {
        return !(!e5 || !e5.status || e5.status !== 412) || Promise.reject(e5);
      })).catch(function() {
        s2 = null;
      }), s2);
    }
    function l2(e5) {
      return e5.split("/").map(encodeURIComponent).join("/");
    }
    t3()(function() {
      n3(null, r2);
    }), r2._remote = true, r2.type = function() {
      return "http";
    }, r2.id = u2("id", function(e5) {
      a2(mn(o3, "")).then(function(e6) {
        return e6.json();
      }).catch(function() {
        return {};
      }).then(function(t4) {
        var n4 = t4 && t4.uuid ? t4.uuid + o3.db : gn(o3, "");
        e5(null, n4);
      });
    }), r2.compact = u2("compact", function(e5, t4) {
      typeof e5 == "function" && (t4 = e5, e5 = {}), e5 = O(e5), c2(gn(o3, "_compact"), { method: "POST" }).then(function() {
        !function n4() {
          r2.info(function(r3, o4) {
            o4 && !o4.compact_running ? t4(null, { ok: true }) : setTimeout(n4, e5.interval || 200);
          });
        }();
      });
    }), r2.bulkGet = S("bulkGet", function(e5, t4) {
      var n4 = this;
      function r3(t5) {
        var n5 = {};
        e5.revs && (n5.revs = true), e5.attachments && (n5.attachments = true), e5.latest && (n5.latest = true), c2(gn(o3, "_bulk_get" + bn(n5)), { method: "POST", body: JSON.stringify({ docs: e5.docs }) }).then(function(n6) {
          e5.attachments && e5.binary && n6.data.results.forEach(function(e6) {
            e6.docs.forEach(vn);
          }), t5(null, n6.data);
        }).catch(t5);
      }
      function i3() {
        var r4 = Math.ceil(e5.docs.length / 50), o4 = 0, i4 = new Array(r4);
        function s4(e6) {
          return function(n5, s5) {
            i4[e6] = s5.results, ++o4 === r4 && t4(null, { results: re(i4) });
          };
        }
        for (var a4 = 0; a4 < r4; a4++) {
          var u3 = x(e5, ["revs", "attachments", "binary", "latest"]);
          u3.docs = e5.docs.slice(50 * a4, Math.min(e5.docs.length, 50 * (a4 + 1))), P(n4, u3, s4(a4));
        }
      }
      var s3 = mn(o3, ""), a3 = pn[s3];
      typeof a3 != "boolean" ? r3(function(e6, n5) {
        e6 ? (pn[s3] = false, B(e6.status, "PouchDB is just detecting if the remote supports the _bulk_get API."), i3()) : (pn[s3] = true, t4(null, n5));
      }) : a3 ? r3(t4) : i3();
    }), r2._info = function(e5) {
      f2().then(function() {
        return a2(gn(o3, ""));
      }).then(function(e6) {
        return e6.json();
      }).then(function(t4) {
        t4.host = gn(o3, ""), e5(null, t4);
      }).catch(e5);
    }, r2.fetch = function(e5, t4) {
      return f2().then(function() {
        var n4 = e5.substring(0, 1) === "/" ? mn(o3, e5.substring(1)) : gn(o3, e5);
        return a2(n4, t4);
      });
    }, r2.get = u2("get", function(e5, t4, n4) {
      typeof t4 == "function" && (n4 = t4, t4 = {});
      var r3 = {};
      function i3(e6) {
        var n5, r4 = e6._attachments, i4 = r4 && Object.keys(r4);
        if (r4 && i4.length)
          return n5 = i4.map(function(n6) {
            return function() {
              return function(n7) {
                var i5 = r4[n7], s3 = yn(e6._id) + "/" + l2(n7) + "?rev=" + e6._rev;
                return a2(gn(o3, s3)).then(function(e7) {
                  return "buffer" in e7 ? e7.buffer() : e7.blob();
                }).then(function(e7) {
                  if (t4.binary) {
                    var n8 = Object.getOwnPropertyDescriptor(e7.__proto__, "type");
                    return n8 && !n8.set || (e7.type = i5.content_type), e7;
                  }
                  return new Promise(function(t5) {
                    je(e7, t5);
                  });
                }).then(function(e7) {
                  delete i5.stub, delete i5.length, i5.data = e7;
                });
              }(n6);
            };
          }), new Promise(function(e7, t5) {
            var r5, o4 = 0, i5 = 0, s3 = 0, a3 = n5.length;
            function u3() {
              ++s3 === a3 ? r5 ? t5(r5) : e7() : l3();
            }
            function c3() {
              o4--, u3();
            }
            function f3(e8) {
              o4--, r5 = r5 || e8, u3();
            }
            function l3() {
              for (; o4 < 5 && i5 < a3; )
                o4++, n5[i5++]().then(c3, f3);
            }
            l3();
          });
      }
      (t4 = O(t4)).revs && (r3.revs = true), t4.revs_info && (r3.revs_info = true), t4.latest && (r3.latest = true), t4.open_revs && (t4.open_revs !== "all" && (t4.open_revs = JSON.stringify(t4.open_revs)), r3.open_revs = t4.open_revs), t4.rev && (r3.rev = t4.rev), t4.conflicts && (r3.conflicts = t4.conflicts), t4.update_seq && (r3.update_seq = t4.update_seq), e5 = yn(e5), c2(gn(o3, e5 + bn(r3))).then(function(e6) {
        return Promise.resolve().then(function() {
          if (t4.attachments)
            return n5 = e6.data, Array.isArray(n5) ? Promise.all(n5.map(function(e7) {
              if (e7.ok)
                return i3(e7.ok);
            })) : i3(n5);
          var n5;
        }).then(function() {
          n4(null, e6.data);
        });
      }).catch(function(t5) {
        t5.docId = e5, n4(t5);
      });
    }), r2.remove = u2("remove", function(e5, t4, n4, r3) {
      var i3;
      typeof t4 == "string" ? (i3 = { _id: e5, _rev: t4 }, typeof n4 == "function" && (r3 = n4, n4 = {})) : (i3 = e5, typeof t4 == "function" ? (r3 = t4, n4 = {}) : (r3 = n4, n4 = t4));
      var s3 = i3._rev || n4.rev;
      c2(gn(o3, yn(i3._id)) + "?rev=" + s3, { method: "DELETE" }, r3).catch(r3);
    }), r2.getAttachment = u2("getAttachment", function(e5, t4, n4, r3) {
      typeof n4 == "function" && (r3 = n4, n4 = {});
      var i3, s3 = n4.rev ? "?rev=" + n4.rev : "", u3 = gn(o3, yn(e5)) + "/" + l2(t4) + s3;
      a2(u3, { method: "GET" }).then(function(e6) {
        if (i3 = e6.headers.get("content-type"), e6.ok)
          return typeof process == "undefined" || process.browser || typeof e6.buffer != "function" ? e6.blob() : e6.buffer();
        throw e6;
      }).then(function(e6) {
        typeof process == "undefined" || process.browser || (e6.type = i3), r3(null, e6);
      }).catch(function(e6) {
        r3(e6);
      });
    }), r2.removeAttachment = u2("removeAttachment", function(e5, t4, n4, r3) {
      c2(gn(o3, yn(e5) + "/" + l2(t4)) + "?rev=" + n4, { method: "DELETE" }, r3).catch(r3);
    }), r2.putAttachment = u2("putAttachment", function(e5, t4, n4, r3, i3, s3) {
      typeof i3 == "function" && (s3 = i3, i3 = r3, r3 = n4, n4 = null);
      var a3 = yn(e5) + "/" + l2(t4), u3 = gn(o3, a3);
      if (n4 && (u3 += "?rev=" + n4), typeof r3 == "string") {
        var f3;
        try {
          f3 = ve(r3);
        } catch (e6) {
          return s3(ee(V, "Attachment is not a valid base64 string"));
        }
        r3 = f3 ? me(f3, i3) : "";
      }
      c2(u3, { headers: new ot({ "Content-Type": i3 }), method: "PUT", body: r3 }, s3).catch(s3);
    }), r2._bulkDocs = function(e5, t4, n4) {
      e5.new_edits = t4.new_edits, f2().then(function() {
        return Promise.all(e5.docs.map(_n));
      }).then(function() {
        return c2(gn(o3, "_bulk_docs"), { method: "POST", body: JSON.stringify(e5) }, n4);
      }).catch(n4);
    }, r2._put = function(e5, t4, n4) {
      f2().then(function() {
        return _n(e5);
      }).then(function() {
        return c2(gn(o3, yn(e5._id)), { method: "PUT", body: JSON.stringify(e5) });
      }).then(function(e6) {
        n4(null, e6.data);
      }).catch(function(t5) {
        t5.docId = e5 && e5._id, n4(t5);
      });
    }, r2.allDocs = u2("allDocs", function(e5, t4) {
      typeof e5 == "function" && (t4 = e5, e5 = {});
      var n4, r3 = {}, i3 = "GET";
      (e5 = O(e5)).conflicts && (r3.conflicts = true), e5.update_seq && (r3.update_seq = true), e5.descending && (r3.descending = true), e5.include_docs && (r3.include_docs = true), e5.attachments && (r3.attachments = true), e5.key && (r3.key = JSON.stringify(e5.key)), e5.start_key && (e5.startkey = e5.start_key), e5.startkey && (r3.startkey = JSON.stringify(e5.startkey)), e5.end_key && (e5.endkey = e5.end_key), e5.endkey && (r3.endkey = JSON.stringify(e5.endkey)), e5.inclusive_end !== void 0 && (r3.inclusive_end = !!e5.inclusive_end), e5.limit !== void 0 && (r3.limit = e5.limit), e5.skip !== void 0 && (r3.skip = e5.skip);
      var s3 = bn(r3);
      e5.keys !== void 0 && (i3 = "POST", n4 = { keys: e5.keys }), c2(gn(o3, "_all_docs" + s3), { method: i3, body: JSON.stringify(n4) }).then(function(n5) {
        e5.include_docs && e5.attachments && e5.binary && n5.data.rows.forEach(vn), t4(null, n5.data);
      }).catch(t4);
    }), r2._changes = function(e5) {
      var n4 = "batch_size" in e5 ? e5.batch_size : 25;
      (e5 = O(e5)).continuous && !("heartbeat" in e5) && (e5.heartbeat = 1e4);
      var r3 = "timeout" in e5 ? e5.timeout : 3e4;
      "timeout" in e5 && e5.timeout && r3 - e5.timeout < hn && (r3 = e5.timeout + hn), "heartbeat" in e5 && e5.heartbeat && r3 - e5.heartbeat < hn && (r3 = e5.heartbeat + hn);
      var i3 = {};
      "timeout" in e5 && e5.timeout && (i3.timeout = e5.timeout);
      var s3 = e5.limit !== void 0 && e5.limit, a3 = s3;
      if (e5.style && (i3.style = e5.style), (e5.include_docs || e5.filter && typeof e5.filter == "function") && (i3.include_docs = true), e5.attachments && (i3.attachments = true), e5.continuous && (i3.feed = "longpoll"), e5.seq_interval && (i3.seq_interval = e5.seq_interval), e5.conflicts && (i3.conflicts = true), e5.descending && (i3.descending = true), e5.update_seq && (i3.update_seq = true), "heartbeat" in e5 && e5.heartbeat && (i3.heartbeat = e5.heartbeat), e5.filter && typeof e5.filter == "string" && (i3.filter = e5.filter), e5.view && typeof e5.view == "string" && (i3.filter = "_view", i3.view = e5.view), e5.query_params && typeof e5.query_params == "object")
        for (var u3 in e5.query_params)
          e5.query_params.hasOwnProperty(u3) && (i3[u3] = e5.query_params[u3]);
      var l3, d2 = "GET";
      e5.doc_ids ? (i3.filter = "_doc_ids", d2 = "POST", l3 = { doc_ids: e5.doc_ids }) : e5.selector && (i3.filter = "_selector", d2 = "POST", l3 = { selector: e5.selector });
      var h2, p2 = new nt(), v2 = function(t4, r4) {
        if (!e5.aborted) {
          i3.since = t4, typeof i3.since == "object" && (i3.since = JSON.stringify(i3.since)), e5.descending ? s3 && (i3.limit = a3) : i3.limit = !s3 || a3 > n4 ? n4 : a3;
          var u4 = gn(o3, "_changes" + bn(i3)), v3 = { signal: p2.signal, method: d2, body: JSON.stringify(l3) };
          h2 = t4, e5.aborted || f2().then(function() {
            return c2(u4, v3, r4);
          }).catch(r4);
        }
      }, y2 = { results: [] }, _2 = function(r4, o4) {
        if (!e5.aborted) {
          var i4 = 0;
          if (o4 && o4.results) {
            i4 = o4.results.length, y2.last_seq = o4.last_seq;
            var u4 = null, c3 = null;
            typeof o4.pending == "number" && (u4 = o4.pending), typeof y2.last_seq != "string" && typeof y2.last_seq != "number" || (c3 = y2.last_seq), e5.query_params, o4.results = o4.results.filter(function(t4) {
              a3--;
              var n5 = ne(e5)(t4);
              return n5 && (e5.include_docs && e5.attachments && e5.binary && vn(t4), e5.return_docs && y2.results.push(t4), e5.onChange(t4, u4, c3)), n5;
            });
          } else if (r4)
            return e5.aborted = true, void e5.complete(r4);
          o4 && o4.last_seq && (h2 = o4.last_seq);
          var f3 = s3 && a3 <= 0 || o4 && i4 < n4 || e5.descending;
          (!e5.continuous || s3 && a3 <= 0) && f3 ? e5.complete(null, y2) : t3()(function() {
            v2(h2, _2);
          });
        }
      };
      return v2(e5.since || 0, _2), { cancel: function() {
        e5.aborted = true, p2.abort();
      } };
    }, r2.revsDiff = u2("revsDiff", function(e5, t4, n4) {
      typeof t4 == "function" && (n4 = t4, t4 = {}), c2(gn(o3, "_revs_diff"), { method: "POST", body: JSON.stringify(e5) }, n4).catch(n4);
    }), r2._close = function(e5) {
      e5();
    }, r2._destroy = function(e5, t4) {
      c2(gn(o3, ""), { method: "DELETE" }).then(function(e6) {
        t4(null, e6);
      }).catch(function(e6) {
        e6.status === 404 ? t4(null, { ok: true }) : t4(e6);
      });
    };
  }
  function kn(e4) {
    this.status = 400, this.name = "query_parse_error", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, kn);
    } catch (e5) {
    }
  }
  function jn(e4) {
    this.status = 404, this.name = "not_found", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, jn);
    } catch (e5) {
    }
  }
  function On(e4) {
    this.status = 500, this.name = "invalid_value", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, On);
    } catch (e5) {
    }
  }
  function An(e4, n3) {
    return n3 && e4.then(function(e5) {
      t3()(function() {
        n3(null, e5);
      });
    }, function(e5) {
      t3()(function() {
        n3(e5);
      });
    }), e4;
  }
  function qn(e4, t4) {
    return function() {
      var n3 = arguments, r2 = this;
      return e4.add(function() {
        return t4.apply(r2, n3);
      });
    };
  }
  function Sn(e4) {
    var t4 = new s(e4), n3 = new Array(t4.size), r2 = -1;
    return t4.forEach(function(e5) {
      n3[++r2] = e5;
    }), n3;
  }
  function xn(e4) {
    var t4 = new Array(e4.size), n3 = -1;
    return e4.forEach(function(e5, r2) {
      t4[++n3] = r2;
    }), t4;
  }
  function En(e4) {
    return new On("builtin " + e4 + " function requires map values to be numbers or number arrays");
  }
  function Cn(e4) {
    for (var t4 = 0, n3 = 0, r2 = e4.length; n3 < r2; n3++) {
      var o3 = e4[n3];
      if (typeof o3 != "number") {
        if (!Array.isArray(o3))
          throw En("_sum");
        t4 = typeof t4 == "number" ? [t4] : t4;
        for (var i2 = 0, s2 = o3.length; i2 < s2; i2++) {
          var a2 = o3[i2];
          if (typeof a2 != "number")
            throw En("_sum");
          t4[i2] === void 0 ? t4.push(a2) : t4[i2] += a2;
        }
      } else
        typeof t4 == "number" ? t4 += o3 : t4[0] += o3;
    }
    return t4;
  }
  wn.valid = function() {
    return true;
  }, p()(kn, Error), p()(jn, Error), p()(On, Error);
  var Pn = $.bind(null, "log"), Ln = Array.isArray, Dn = JSON.parse;
  function $n(e4, t4) {
    return he("return (" + e4.replace(/;\s*$/, "") + ");", { emit: t4, sum: Cn, log: Pn, isArray: Ln, toJSON: Dn });
  }
  function In() {
    this.promise = new Promise(function(e4) {
      e4();
    });
  }
  function Bn(e4) {
    if (!e4)
      return "undefined";
    switch (typeof e4) {
      case "function":
      case "string":
        return e4.toString();
      default:
        return JSON.stringify(e4);
    }
  }
  function Rn(e4, t4, n3, r2, o3, i2) {
    var s2, a2 = function(e5, t5) {
      return Bn(e5) + Bn(t5) + "undefined";
    }(n3, r2);
    if (!o3 && (s2 = e4._cachedViews = e4._cachedViews || {})[a2])
      return s2[a2];
    var u2 = e4.info().then(function(u3) {
      var c2 = u3.db_name + "-mrview-" + (o3 ? "temp" : xe(a2));
      return pe(e4, "_local/" + i2, function(e5) {
        e5.views = e5.views || {};
        var n4 = t4;
        n4.indexOf("/") === -1 && (n4 = t4 + "/" + t4);
        var r3 = e5.views[n4] = e5.views[n4] || {};
        if (!r3[c2])
          return r3[c2] = true, e5;
      }).then(function() {
        return e4.registerDependentDatabase(c2).then(function(t5) {
          var o4 = t5.db;
          o4.auto_compaction = true;
          var i3 = { name: c2, db: o4, sourceDB: e4, adapter: e4.adapter, mapFun: n3, reduceFun: r2 };
          return i3.db.get("_local/lastSeq").catch(function(e5) {
            if (e5.status !== 404)
              throw e5;
          }).then(function(e5) {
            return i3.seq = e5 ? e5.seq : 0, s2 && i3.db.once("destroyed", function() {
              delete s2[a2];
            }), i3;
          });
        });
      });
    });
    return s2 && (s2[a2] = u2), u2;
  }
  In.prototype.add = function(e4) {
    return this.promise = this.promise.catch(function() {
    }).then(function() {
      return e4();
    }), this.promise;
  }, In.prototype.finish = function() {
    return this.promise;
  };
  var Tn = {}, Mn = new In();
  function Nn(e4) {
    return e4.indexOf("/") === -1 ? [e4, e4] : e4.split("/");
  }
  function Un(e4, t4) {
    try {
      e4.emit("error", t4);
    } catch (e5) {
      $("error", "The user's map/reduce function threw an uncaught error.\nYou can debug this error by doing:\nmyDatabase.on('error', function (err) { debugger; });\nPlease double-check your map/reduce function."), $("error", t4);
    }
  }
  var Fn = function(e4, t4) {
    return Cn(t4);
  }, Kn = function(e4, t4) {
    return t4.length;
  }, Jn = function(e4, t4) {
    return { sum: Cn(t4), min: Math.min.apply(null, t4), max: Math.max.apply(null, t4), count: t4.length, sumsqr: function(e5) {
      for (var t5 = 0, n3 = 0, r2 = e5.length; n3 < r2; n3++) {
        var o3 = e5[n3];
        t5 += o3 * o3;
      }
      return t5;
    }(t4) };
  }, zn = function(e4, n3, r2, o3) {
    function i2(e5, t4, n4) {
      try {
        t4(n4);
      } catch (t5) {
        Un(e5, t5);
      }
    }
    function u2(e5, t4, n4, r3, o4) {
      try {
        return { output: t4(n4, r3, o4) };
      } catch (t5) {
        return Un(e5, t5), { error: t5 };
      }
    }
    function c2(e5, t4) {
      var n4 = vt(e5.key, t4.key);
      return n4 !== 0 ? n4 : vt(e5.value, t4.value);
    }
    function f2(e5, t4, n4) {
      return n4 = n4 || 0, typeof t4 == "number" ? e5.slice(n4, t4 + n4) : n4 > 0 ? e5.slice(n4) : e5;
    }
    function l2(e5) {
      var t4 = e5.value;
      return t4 && typeof t4 == "object" && t4._id || e5.id;
    }
    function h2(e5) {
      return function(t4) {
        return e5.include_docs && e5.attachments && e5.binary && function(e6) {
          e6.rows.forEach(function(e7) {
            var t5 = e7.doc && e7.doc._attachments;
            t5 && Object.keys(t5).forEach(function(e8) {
              var n4 = t5[e8];
              t5[e8].data = be(n4.data, n4.content_type);
            });
          });
        }(t4), t4;
      };
    }
    function p2(e5, t4, n4, r3) {
      var o4 = t4[e5];
      o4 !== void 0 && (r3 && (o4 = encodeURIComponent(JSON.stringify(o4))), n4.push(e5 + "=" + o4));
    }
    function v2(e5) {
      if (e5 !== void 0) {
        var t4 = Number(e5);
        return isNaN(t4) || t4 !== parseInt(e5, 10) ? e5 : t4;
      }
    }
    function y2(e5, t4) {
      var n4 = e5.descending ? "endkey" : "startkey", r3 = e5.descending ? "startkey" : "endkey";
      if (e5[n4] !== void 0 && e5[r3] !== void 0 && vt(e5[n4], e5[r3]) > 0)
        throw new kn("No rows can match your key range, reverse your start_key and end_key or set {descending : true}");
      if (t4.reduce && e5.reduce !== false) {
        if (e5.include_docs)
          throw new kn("{include_docs:true} is invalid for reduce");
        if (e5.keys && e5.keys.length > 1 && !e5.group && !e5.group_level)
          throw new kn("Multi-key fetches for reduce views must use {group: true}");
      }
      ["group_level", "limit", "skip"].forEach(function(t5) {
        var n5 = function(e6) {
          if (e6) {
            if (typeof e6 != "number")
              return new kn('Invalid value for integer: "' + e6 + '"');
            if (e6 < 0)
              return new kn('Invalid value for positive integer: "' + e6 + '"');
          }
        }(e5[t5]);
        if (n5)
          throw n5;
      });
    }
    function _2(e5) {
      return function(t4) {
        if (t4.status === 404)
          return e5;
        throw t4;
      };
    }
    function g2(e5) {
      var t4 = typeof e5 == "string" ? e5 : e5.name, n4 = Tn[t4];
      return n4 || (n4 = Tn[t4] = new In()), n4;
    }
    function m2(e5) {
      return qn(g2(e5), function() {
        return function(e6) {
          var t4, n4;
          var r3 = function(e7, t5) {
            if (typeof e7 == "function" && e7.length === 2) {
              var n5 = e7;
              return function(e8) {
                return n5(e8, t5);
              };
            }
            return $n(e7.toString(), t5);
          }(e6.mapFun, function(e7, r4) {
            var o5 = { id: n4._id, key: yt(e7) };
            r4 != null && (o5.value = yt(r4)), t4.push(o5);
          }), o4 = e6.seq || 0;
          function u3(t5, n5) {
            return function() {
              return function(e7, t6, n6) {
                var r4 = "_local/lastSeq";
                return e7.db.get(r4).catch(_2({ _id: r4, seq: 0 })).then(function(r5) {
                  var o5 = xn(t6);
                  return Promise.all(o5.map(function(n7) {
                    return function(e8, t7, n8) {
                      var r6 = "_local/doc_" + e8, o6 = { _id: r6, keys: [] }, i3 = n8.get(e8), a2 = i3[0];
                      return (function(e9) {
                        return e9.length === 1 && /^1-/.test(e9[0].rev);
                      }(i3[1]) ? Promise.resolve(o6) : t7.db.get(r6).catch(_2(o6))).then(function(e9) {
                        return function(e10) {
                          return e10.keys.length ? t7.db.allDocs({ keys: e10.keys, include_docs: true }) : Promise.resolve({ rows: [] });
                        }(e9).then(function(t8) {
                          return function(e10, t9) {
                            for (var n9 = [], r7 = new s(), o7 = 0, i4 = t9.rows.length; o7 < i4; o7++) {
                              var u4 = t9.rows[o7].doc;
                              if (u4 && (n9.push(u4), r7.add(u4._id), u4._deleted = !a2.has(u4._id), !u4._deleted)) {
                                var c3 = a2.get(u4._id);
                                "value" in c3 && (u4.value = c3.value);
                              }
                            }
                            var f4 = xn(a2);
                            return f4.forEach(function(e11) {
                              if (!r7.has(e11)) {
                                var t10 = { _id: e11 }, o8 = a2.get(e11);
                                "value" in o8 && (t10.value = o8.value), n9.push(t10);
                              }
                            }), e10.keys = Sn(f4.concat(e10.keys)), n9.push(e10), n9;
                          }(e9, t8);
                        });
                      });
                    }(n7, e7, t6);
                  })).then(function(t7) {
                    var o6 = re(t7);
                    return r5.seq = n6, o6.push(r5), e7.db.bulkDocs({ docs: o6 });
                  });
                });
              }(e6, t5, n5);
            };
          }
          var f3 = new In();
          function l3() {
            return e6.sourceDB.changes({ return_docs: true, conflicts: true, include_docs: true, style: "all_docs", since: o4, limit: 50 }).then(d2);
          }
          function d2(s2) {
            var d3 = s2.results;
            if (d3.length) {
              var p3 = function(s3) {
                for (var u4 = new a(), f4 = 0, l4 = s3.length; f4 < l4; f4++) {
                  var d4 = s3[f4];
                  if (d4.doc._id[0] !== "_") {
                    t4 = [], (n4 = d4.doc)._deleted || i2(e6.sourceDB, r3, n4), t4.sort(c2);
                    var p4 = h3(t4);
                    u4.set(d4.doc._id, [p4, d4.changes]);
                  }
                  o4 = d4.seq;
                }
                return u4;
              }(d3);
              if (f3.add(u3(p3, o4)), !(d3.length < 50))
                return l3();
            }
          }
          function h3(e7) {
            for (var t5, n5 = new a(), r4 = 0, o5 = e7.length; r4 < o5; r4++) {
              var i3 = e7[r4], s2 = [i3.key, i3.id];
              r4 > 0 && vt(i3.key, t5) === 0 && s2.push(r4), n5.set(_t(s2), i3), t5 = i3.key;
            }
            return n5;
          }
          return l3().then(function() {
            return f3.finish();
          }).then(function() {
            e6.seq = o4;
          });
        }(e5);
      })();
    }
    function b2(e5, t4) {
      return qn(g2(e5), function() {
        return function(e6, t5) {
          var n4, r3 = e6.reduceFun && t5.reduce !== false, o4 = t5.skip || 0;
          function i3(t6) {
            return t6.include_docs = true, e6.db.allDocs(t6).then(function(e7) {
              return n4 = e7.total_rows, e7.rows.map(function(e8) {
                if ("value" in e8.doc && typeof e8.doc.value == "object" && e8.doc.value !== null) {
                  var t7 = Object.keys(e8.doc.value).sort(), n5 = ["id", "key", "value"];
                  if (!(t7 < n5 || t7 > n5))
                    return e8.doc.value;
                }
                var r4 = function(e9) {
                  for (var t8 = [], n6 = [], r5 = 0; ; ) {
                    var o5 = e9[r5++];
                    if (o5 !== "\0")
                      switch (o5) {
                        case "1":
                          t8.push(null);
                          break;
                        case "2":
                          t8.push(e9[r5] === "1"), r5++;
                          break;
                        case "3":
                          var i4 = gt(e9, r5);
                          t8.push(i4.num), r5 += i4.length;
                          break;
                        case "4":
                          for (var s3 = ""; ; ) {
                            var a2 = e9[r5];
                            if (a2 === "\0")
                              break;
                            s3 += a2, r5++;
                          }
                          s3 = s3.replace(/\u0001\u0001/g, "\0").replace(/\u0001\u0002/g, "").replace(/\u0002\u0002/g, ""), t8.push(s3);
                          break;
                        case "5":
                          var u3 = { element: [], index: t8.length };
                          t8.push(u3.element), n6.push(u3);
                          break;
                        case "6":
                          var c4 = { element: {}, index: t8.length };
                          t8.push(c4.element), n6.push(c4);
                          break;
                        default:
                          throw new Error("bad collationIndex or unexpectedly reached end of input: " + o5);
                      }
                    else {
                      if (t8.length === 1)
                        return t8.pop();
                      mt(t8, n6);
                    }
                  }
                }(e8.doc._id);
                return { key: r4[0], id: r4[1], value: "value" in e8.doc ? e8.doc.value : null };
              });
            });
          }
          function s2(i4) {
            var s3;
            if (s3 = r3 ? function(e7, t6, n5) {
              n5.group_level === 0 && delete n5.group_level;
              var r4 = n5.group || n5.group_level, o5 = function(e8) {
                var t7 = e8.toString(), n6 = function(e9) {
                  if (/^_sum/.test(e9))
                    return Fn;
                  if (/^_count/.test(e9))
                    return Kn;
                  if (/^_stats/.test(e9))
                    return Jn;
                  if (/^_/.test(e9))
                    throw new Error(e9 + " is not a supported reduce function.");
                }(t7);
                return n6 || $n(t7);
              }(e7.reduceFun), i5 = [], s4 = isNaN(n5.group_level) ? Number.POSITIVE_INFINITY : n5.group_level;
              t6.forEach(function(e8) {
                var t7 = i5[i5.length - 1], n6 = r4 ? e8.key : null;
                if (r4 && Array.isArray(n6) && (n6 = n6.slice(0, s4)), t7 && vt(t7.groupKey, n6) === 0)
                  return t7.keys.push([e8.key, e8.id]), void t7.values.push(e8.value);
                i5.push({ keys: [[e8.key, e8.id]], values: [e8.value], groupKey: n6 });
              }), t6 = [];
              for (var a2 = 0, c5 = i5.length; a2 < c5; a2++) {
                var l3 = i5[a2], d3 = u2(e7.sourceDB, o5, l3.keys, l3.values, false);
                if (d3.error && d3.error instanceof On)
                  throw d3.error;
                t6.push({ value: d3.error ? null : d3.output, key: l3.groupKey });
              }
              return { rows: f2(t6, n5.limit, n5.skip) };
            }(e6, i4, t5) : { total_rows: n4, offset: o4, rows: i4 }, t5.update_seq && (s3.update_seq = e6.seq), t5.include_docs) {
              var c4 = Sn(i4.map(l2));
              return e6.sourceDB.allDocs({ keys: c4, include_docs: true, conflicts: t5.conflicts, attachments: t5.attachments, binary: t5.binary }).then(function(e7) {
                var t6 = new a();
                return e7.rows.forEach(function(e8) {
                  t6.set(e8.id, e8.doc);
                }), i4.forEach(function(e8) {
                  var n5 = l2(e8), r4 = t6.get(n5);
                  r4 && (e8.doc = r4);
                }), s3;
              });
            }
            return s3;
          }
          if (t5.keys === void 0 || t5.keys.length || (t5.limit = 0, delete t5.keys), t5.keys !== void 0) {
            var c3 = t5.keys.map(function(e7) {
              var n5 = { startkey: _t([e7]), endkey: _t([e7, {}]) };
              return t5.update_seq && (n5.update_seq = true), i3(n5);
            });
            return Promise.all(c3).then(re).then(s2);
          }
          var d2, h3, p3 = { descending: t5.descending };
          if (t5.update_seq && (p3.update_seq = true), "start_key" in t5 && (d2 = t5.start_key), "startkey" in t5 && (d2 = t5.startkey), "end_key" in t5 && (h3 = t5.end_key), "endkey" in t5 && (h3 = t5.endkey), d2 !== void 0 && (p3.startkey = t5.descending ? _t([d2, {}]) : _t([d2])), h3 !== void 0) {
            var v3 = t5.inclusive_end !== false;
            t5.descending && (v3 = !v3), p3.endkey = _t(v3 ? [h3, {}] : [h3]);
          }
          if (t5.key !== void 0) {
            var y3 = _t([t5.key]), _3 = _t([t5.key, {}]);
            p3.descending ? (p3.endkey = y3, p3.startkey = _3) : (p3.startkey = y3, p3.endkey = _3);
          }
          return r3 || (typeof t5.limit == "number" && (p3.limit = t5.limit), p3.skip = o4), i3(p3).then(s2);
        }(e5, t4);
      })();
    }
    function w2(n4, r3, o4) {
      if (typeof n4._query == "function")
        return function(e5, t4, n5) {
          return new Promise(function(r4, o5) {
            e5._query(t4, n5, function(e6, t5) {
              if (e6)
                return o5(e6);
              r4(t5);
            });
          });
        }(n4, r3, o4);
      if (ie(n4))
        return function(e5, t4, n5) {
          var r4, o5, i4, s3 = [], a3 = "GET";
          if (p2("reduce", n5, s3), p2("include_docs", n5, s3), p2("attachments", n5, s3), p2("limit", n5, s3), p2("descending", n5, s3), p2("group", n5, s3), p2("group_level", n5, s3), p2("skip", n5, s3), p2("stale", n5, s3), p2("conflicts", n5, s3), p2("startkey", n5, s3, true), p2("start_key", n5, s3, true), p2("endkey", n5, s3, true), p2("end_key", n5, s3, true), p2("inclusive_end", n5, s3), p2("key", n5, s3, true), p2("update_seq", n5, s3), s3 = (s3 = s3.join("&")) === "" ? "" : "?" + s3, n5.keys !== void 0) {
            var u4 = "keys=" + encodeURIComponent(JSON.stringify(n5.keys));
            u4.length + s3.length + 1 <= 2e3 ? s3 += (s3[0] === "?" ? "&" : "?") + u4 : (a3 = "POST", typeof t4 == "string" ? r4 = { keys: n5.keys } : t4.keys = n5.keys);
          }
          if (typeof t4 == "string") {
            var c3 = Nn(t4);
            return e5.fetch("_design/" + c3[0] + "/_view/" + c3[1] + s3, { headers: new ot({ "Content-Type": "application/json" }), method: a3, body: JSON.stringify(r4) }).then(function(e6) {
              return o5 = e6.ok, i4 = e6.status, e6.json();
            }).then(function(e6) {
              if (!o5)
                throw e6.status = i4, te(e6);
              return e6.rows.forEach(function(e7) {
                if (e7.value && e7.value.error && e7.value.error === "builtin_reduce_error")
                  throw new Error(e7.reason);
              }), e6;
            }).then(h2(n5));
          }
          return r4 = r4 || {}, Object.keys(t4).forEach(function(e6) {
            Array.isArray(t4[e6]) ? r4[e6] = t4[e6] : r4[e6] = t4[e6].toString();
          }), e5.fetch("_temp_view" + s3, { headers: new ot({ "Content-Type": "application/json" }), method: "POST", body: JSON.stringify(r4) }).then(function(e6) {
            return o5 = e6.ok, i4 = e6.status, e6.json();
          }).then(function(e6) {
            if (!o5)
              throw e6.status = i4, te(e6);
            return e6;
          }).then(h2(n5));
        }(n4, r3, o4);
      if (typeof r3 != "string")
        return y2(o4, r3), Mn.add(function() {
          return Rn(n4, "temp_view/temp_view", r3.map, r3.reduce, true, e4).then(function(e5) {
            return t4 = m2(e5).then(function() {
              return b2(e5, o4);
            }), n5 = function() {
              return e5.db.destroy();
            }, t4.then(function(e6) {
              return n5().then(function() {
                return e6;
              });
            }, function(e6) {
              return n5().then(function() {
                throw e6;
              });
            });
            var t4, n5;
          });
        }), Mn.finish();
      var i3 = r3, s2 = Nn(i3), a2 = s2[0], u3 = s2[1];
      return n4.get("_design/" + a2).then(function(r4) {
        var s3 = r4.views && r4.views[u3];
        if (!s3)
          throw new jn("ddoc " + r4._id + " has no view named " + u3);
        return function(e5, t4) {
          var n5 = e5.views && e5.views[t4];
          if (typeof n5.map != "string")
            throw new jn("ddoc " + e5._id + " has no string view named " + t4 + ", instead found object of type: " + typeof n5.map);
        }(r4, u3), y2(o4, s3), Rn(n4, i3, s3.map, s3.reduce, false, e4).then(function(e5) {
          return o4.stale === "ok" || o4.stale === "update_after" ? (o4.stale === "update_after" && t3()(function() {
            m2(e5);
          }), b2(e5, o4)) : m2(e5).then(function() {
            return b2(e5, o4);
          });
        });
      });
    }
    var k2;
    return { query: function(e5, t4, n4) {
      var r3 = this;
      typeof t4 == "function" && (n4 = t4, t4 = {}), t4 = t4 ? function(e6) {
        return e6.group_level = v2(e6.group_level), e6.limit = v2(e6.limit), e6.skip = v2(e6.skip), e6;
      }(t4) : {}, typeof e5 == "function" && (e5 = { map: e5 });
      var o4 = Promise.resolve().then(function() {
        return w2(r3, e5, t4);
      });
      return An(o4, n4), o4;
    }, viewCleanup: (k2 = function() {
      var e5 = this;
      return typeof e5._viewCleanup == "function" ? function(e6) {
        return new Promise(function(t4, n4) {
          e6._viewCleanup(function(e7, r3) {
            if (e7)
              return n4(e7);
            t4(r3);
          });
        });
      }(e5) : ie(e5) ? function(e6) {
        return e6.fetch("_view_cleanup", { headers: new ot({ "Content-Type": "application/json" }), method: "POST" }).then(function(e7) {
          return e7.json();
        });
      }(e5) : function(e6) {
        return e6.get("_local/mrviews").then(function(t4) {
          var n4 = new a();
          Object.keys(t4.views).forEach(function(e7) {
            var t5 = Nn(e7), r4 = "_design/" + t5[0], o4 = t5[1], i3 = n4.get(r4);
            i3 || (i3 = new s(), n4.set(r4, i3)), i3.add(o4);
          });
          var r3 = { keys: xn(n4), include_docs: true };
          return e6.allDocs(r3).then(function(r4) {
            var o4 = {};
            r4.rows.forEach(function(e7) {
              var r5 = e7.key.substring(8);
              n4.get(e7.key).forEach(function(n5) {
                var i4 = r5 + "/" + n5;
                t4.views[i4] || (i4 = n5);
                var s2 = Object.keys(t4.views[i4]), a2 = e7.doc && e7.doc.views && e7.doc.views[n5];
                s2.forEach(function(e8) {
                  o4[e8] = o4[e8] || a2;
                });
              });
            });
            var i3 = Object.keys(o4).filter(function(e7) {
              return !o4[e7];
            }).map(function(t5) {
              return qn(g2(t5), function() {
                return new e6.constructor(t5, e6.__opts).destroy();
              })();
            });
            return Promise.all(i3).then(function() {
              return { ok: true };
            });
          });
        }, _2({ ok: true }));
      }(e5);
    }, d()(function(e5) {
      var t4 = e5.pop(), n4 = k2.apply(this, e5);
      return typeof t4 == "function" && An(n4, t4), n4;
    })) };
  }("mrviews"), Vn = { query: function(e4, t4, n3) {
    return zn.query.call(this, e4, t4, n3);
  }, viewCleanup: function(e4) {
    return zn.viewCleanup.call(this, e4);
  } };
  function Gn(e4) {
    return /^1-/.test(e4);
  }
  function Qn(e4, t4) {
    var n3 = Object.keys(t4._attachments);
    return Promise.all(n3.map(function(n4) {
      return e4.getAttachment(t4._id, n4, { rev: t4._rev });
    }));
  }
  function Wn(e4, t4, n3, r2) {
    n3 = O(n3);
    var o3 = [], i2 = true;
    return Promise.resolve().then(function() {
      var t5 = Object.keys(n3).filter(function(e5) {
        var t6 = n3[e5].missing;
        return t6.length === 1 && Gn(t6[0]);
      });
      if (t5.length > 0)
        return function(t6) {
          return e4.allDocs({ keys: t6, include_docs: true, conflicts: true }).then(function(e5) {
            if (r2.cancelled)
              throw new Error("cancelled");
            e5.rows.forEach(function(e6) {
              var t7;
              e6.deleted || !e6.doc || !Gn(e6.value.rev) || (t7 = e6.doc)._attachments && Object.keys(t7._attachments).length > 0 || function(e7) {
                return e7._conflicts && e7._conflicts.length > 0;
              }(e6.doc) || (e6.doc._conflicts && delete e6.doc._conflicts, o3.push(e6.doc), delete n3[e6.id]);
            });
          });
        }(t5);
    }).then(function() {
      var s2 = function(e5) {
        var t5 = [];
        return Object.keys(e5).forEach(function(n4) {
          e5[n4].missing.forEach(function(e6) {
            t5.push({ id: n4, rev: e6 });
          });
        }), { docs: t5, revs: true, latest: true };
      }(n3);
      if (s2.docs.length)
        return e4.bulkGet(s2).then(function(n4) {
          if (r2.cancelled)
            throw new Error("cancelled");
          return Promise.all(n4.results.map(function(n5) {
            return Promise.all(n5.docs.map(function(n6) {
              var r3 = n6.ok;
              return n6.error && (i2 = false), r3 && r3._attachments ? function(e5, t5, n7) {
                var r4 = ie(t5) && !ie(e5), o4 = Object.keys(n7._attachments);
                return r4 ? e5.get(n7._id).then(function(r5) {
                  return Promise.all(o4.map(function(o5) {
                    return function(e6, t6, n8) {
                      return !e6._attachments || !e6._attachments[n8] || e6._attachments[n8].digest !== t6._attachments[n8].digest;
                    }(r5, n7, o5) ? t5.getAttachment(n7._id, o5) : e5.getAttachment(r5._id, o5);
                  }));
                }).catch(function(e6) {
                  if (e6.status !== 404)
                    throw e6;
                  return Qn(t5, n7);
                }) : Qn(t5, n7);
              }(t4, e4, r3).then(function(e5) {
                var t5 = Object.keys(r3._attachments);
                return e5.forEach(function(e6, n7) {
                  var o4 = r3._attachments[t5[n7]];
                  delete o4.stub, delete o4.length, o4.data = e6;
                }), r3;
              }) : r3;
            }));
          })).then(function(e5) {
            o3 = o3.concat(re(e5).filter(Boolean));
          });
        });
    }).then(function() {
      return { ok: i2, docs: o3 };
    });
  }
  var Yn = "pouchdb";
  function Hn(e4, t4, n3, r2, o3) {
    return e4.get(t4).catch(function(n4) {
      if (n4.status === 404)
        return e4.adapter !== "http" && e4.adapter !== "https" || B(404, "PouchDB is just checking if a remote checkpoint exists."), { session_id: r2, _id: t4, history: [], replicator: Yn, version: 1 };
      throw n4;
    }).then(function(i2) {
      if (!o3.cancelled && i2.last_seq !== n3)
        return i2.history = (i2.history || []).filter(function(e5) {
          return e5.session_id !== r2;
        }), i2.history.unshift({ last_seq: n3, session_id: r2 }), i2.history = i2.history.slice(0, 5), i2.version = 1, i2.replicator = Yn, i2.session_id = r2, i2.last_seq = n3, e4.put(i2).catch(function(i3) {
          if (i3.status === 409)
            return Hn(e4, t4, n3, r2, o3);
          throw i3;
        });
    });
  }
  function Xn(e4, t4, n3, r2, o3) {
    this.src = e4, this.target = t4, this.id = n3, this.returnValue = r2, this.opts = o3 || {};
  }
  Xn.prototype.writeCheckpoint = function(e4, t4) {
    var n3 = this;
    return this.updateTarget(e4, t4).then(function() {
      return n3.updateSource(e4, t4);
    });
  }, Xn.prototype.updateTarget = function(e4, t4) {
    return this.opts.writeTargetCheckpoint ? Hn(this.target, this.id, e4, t4, this.returnValue) : Promise.resolve(true);
  }, Xn.prototype.updateSource = function(e4, t4) {
    if (this.opts.writeSourceCheckpoint) {
      var n3 = this;
      return Hn(this.src, this.id, e4, t4, this.returnValue).catch(function(e5) {
        if (nr(e5))
          return n3.opts.writeSourceCheckpoint = false, true;
        throw e5;
      });
    }
    return Promise.resolve(true);
  };
  var Zn = { undefined: function(e4, t4) {
    return vt(e4.last_seq, t4.last_seq) === 0 ? t4.last_seq : 0;
  }, 1: function(e4, t4) {
    return (n3 = t4, r2 = e4, n3.session_id === r2.session_id ? { last_seq: n3.last_seq, history: n3.history } : er(n3.history, r2.history)).last_seq;
    var n3, r2;
  } };
  function er(e4, t4) {
    var n3 = e4[0], r2 = e4.slice(1), o3 = t4[0], i2 = t4.slice(1);
    return n3 && t4.length !== 0 ? tr(n3.session_id, t4) ? { last_seq: n3.last_seq, history: e4 } : tr(o3.session_id, r2) ? { last_seq: o3.last_seq, history: i2 } : er(r2, i2) : { last_seq: 0, history: [] };
  }
  function tr(e4, t4) {
    var n3 = t4[0], r2 = t4.slice(1);
    return !(!e4 || t4.length === 0) && (e4 === n3.session_id || tr(e4, r2));
  }
  function nr(e4) {
    return typeof e4.status == "number" && Math.floor(e4.status / 100) === 4;
  }
  function rr(e4, n3, r2, o3, i2) {
    var s2, a2, u2, c2 = [], f2 = { seq: 0, changes: [], docs: [] }, l2 = false, d2 = false, h2 = false, p2 = 0, v2 = r2.continuous || r2.live || false, y2 = r2.batch_size || 100, _2 = r2.batches_limit || 10, g2 = false, m2 = r2.doc_ids, b2 = r2.selector, w2 = [], k2 = Ce();
    i2 = i2 || { ok: true, start_time: new Date().toISOString(), docs_read: 0, docs_written: 0, doc_write_failures: 0, errors: [] };
    var j2 = {};
    function A2() {
      return u2 ? Promise.resolve() : function(e5, t4, n4) {
        var r3 = n4.doc_ids ? n4.doc_ids.sort(vt) : "", o4 = n4.filter ? n4.filter.toString() : "", i3 = "", s3 = "", a3 = "";
        return n4.selector && (a3 = JSON.stringify(n4.selector)), n4.filter && n4.query_params && (i3 = JSON.stringify(function(e6) {
          return Object.keys(e6).sort(vt).reduce(function(t5, n5) {
            return t5[n5] = e6[n5], t5;
          }, {});
        }(n4.query_params))), n4.filter && n4.filter === "_view" && (s3 = n4.view.toString()), Promise.all([e5.id(), t4.id()]).then(function(e6) {
          var t5 = e6[0] + e6[1] + o4 + s3 + i3 + r3 + a3;
          return new Promise(function(e7) {
            Se(t5, e7);
          });
        }).then(function(e6) {
          return "_local/" + e6.replace(/\//g, ".").replace(/\+/g, "_");
        });
      }(e4, n3, r2).then(function(t4) {
        a2 = t4;
        var i3;
        i3 = r2.checkpoint === false ? { writeSourceCheckpoint: false, writeTargetCheckpoint: false } : r2.checkpoint === "source" ? { writeSourceCheckpoint: true, writeTargetCheckpoint: false } : r2.checkpoint === "target" ? { writeSourceCheckpoint: false, writeTargetCheckpoint: true } : { writeSourceCheckpoint: true, writeTargetCheckpoint: true }, u2 = new Xn(e4, n3, a2, o3, i3);
      });
    }
    function q2() {
      if (w2 = [], s2.docs.length !== 0) {
        var e5 = s2.docs, t4 = { timeout: r2.timeout };
        return n3.bulkDocs({ docs: e5, new_edits: false }, t4).then(function(t5) {
          if (o3.cancelled)
            throw L2(), new Error("cancelled");
          var n4 = Object.create(null);
          t5.forEach(function(e6) {
            e6.error && (n4[e6.id] = e6);
          });
          var r3 = Object.keys(n4).length;
          i2.doc_write_failures += r3, i2.docs_written += e5.length - r3, e5.forEach(function(e6) {
            var t6 = n4[e6._id];
            if (t6) {
              i2.errors.push(t6);
              var r4 = (t6.name || "").toLowerCase();
              if (r4 !== "unauthorized" && r4 !== "forbidden")
                throw t6;
              o3.emit("denied", O(t6));
            } else
              w2.push(e6);
          });
        }, function(t5) {
          throw i2.doc_write_failures += e5.length, t5;
        });
      }
    }
    function S2() {
      if (s2.error)
        throw new Error("There was a problem getting docs.");
      i2.last_seq = p2 = s2.seq;
      var e5 = O(i2);
      return w2.length && (e5.docs = w2, typeof s2.pending == "number" && (e5.pending = s2.pending, delete s2.pending), o3.emit("change", e5)), l2 = true, u2.writeCheckpoint(s2.seq, k2).then(function() {
        if (l2 = false, o3.cancelled)
          throw L2(), new Error("cancelled");
        s2 = void 0, R2();
      }).catch(function(e6) {
        throw M2(e6), e6;
      });
    }
    function x2() {
      return Wn(e4, n3, s2.diffs, o3).then(function(e5) {
        s2.error = !e5.ok, e5.docs.forEach(function(e6) {
          delete s2.diffs[e6._id], i2.docs_read++, s2.docs.push(e6);
        });
      });
    }
    function E2() {
      var e5;
      o3.cancelled || s2 || (c2.length !== 0 ? (s2 = c2.shift(), (e5 = {}, s2.changes.forEach(function(t4) {
        t4.id !== "_user/" && (e5[t4.id] = t4.changes.map(function(e6) {
          return e6.rev;
        }));
      }), n3.revsDiff(e5).then(function(e6) {
        if (o3.cancelled)
          throw L2(), new Error("cancelled");
        s2.diffs = e6;
      })).then(x2).then(q2).then(S2).then(E2).catch(function(e6) {
        P2("batch processing terminated with error", e6);
      })) : C2(true));
    }
    function C2(e5) {
      f2.changes.length !== 0 ? (e5 || d2 || f2.changes.length >= y2) && (c2.push(f2), f2 = { seq: 0, changes: [], docs: [] }, o3.state !== "pending" && o3.state !== "stopped" || (o3.state = "active", o3.emit("active")), E2()) : c2.length !== 0 || s2 || ((v2 && j2.live || d2) && (o3.state = "pending", o3.emit("paused")), d2 && L2());
    }
    function P2(e5, t4) {
      h2 || (t4.message || (t4.message = e5), i2.ok = false, i2.status = "aborting", c2 = [], f2 = { seq: 0, changes: [], docs: [] }, L2(t4));
    }
    function L2(t4) {
      if (!(h2 || o3.cancelled && (i2.status = "cancelled", l2)))
        if (i2.status = i2.status || "complete", i2.end_time = new Date().toISOString(), i2.last_seq = p2, h2 = true, t4) {
          (t4 = ee(t4)).result = i2;
          var s3 = (t4.name || "").toLowerCase();
          s3 === "unauthorized" || s3 === "forbidden" ? (o3.emit("error", t4), o3.removeAllListeners()) : function(e5, t5, n4, r3) {
            if (e5.retry === false)
              return t5.emit("error", n4), void t5.removeAllListeners();
            if (typeof e5.back_off_function != "function" && (e5.back_off_function = I), t5.emit("requestError", n4), t5.state === "active" || t5.state === "pending") {
              t5.emit("paused", n4), t5.state = "stopped";
              var o4 = function() {
                e5.current_back_off = 0;
              };
              t5.once("paused", function() {
                t5.removeListener("active", o4);
              }), t5.once("active", o4);
            }
            e5.current_back_off = e5.current_back_off || 0, e5.current_back_off = e5.back_off_function(e5.current_back_off), setTimeout(r3, e5.current_back_off);
          }(r2, o3, t4, function() {
            rr(e4, n3, r2, o3);
          });
        } else
          o3.emit("complete", i2), o3.removeAllListeners();
    }
    function D2(e5, n4, i3) {
      if (o3.cancelled)
        return L2();
      typeof n4 == "number" && (f2.pending = n4), ne(r2)(e5) && (f2.seq = e5.seq || i3, f2.changes.push(e5), t3()(function() {
        C2(c2.length === 0 && j2.live);
      }));
    }
    function $2(e5) {
      if (g2 = false, o3.cancelled)
        return L2();
      if (e5.results.length > 0)
        j2.since = e5.results[e5.results.length - 1].seq, R2(), C2(true);
      else {
        var t4 = function() {
          v2 ? (j2.live = true, R2()) : d2 = true, C2(true);
        };
        s2 || e5.results.length !== 0 ? t4() : (l2 = true, u2.writeCheckpoint(e5.last_seq, k2).then(function() {
          l2 = false, i2.last_seq = p2 = e5.last_seq, t4();
        }).catch(M2));
      }
    }
    function B2(e5) {
      if (g2 = false, o3.cancelled)
        return L2();
      P2("changes rejected", e5);
    }
    function R2() {
      if (!g2 && !d2 && c2.length < _2) {
        g2 = true, o3._changes && (o3.removeListener("cancel", o3._abortChanges), o3._changes.cancel()), o3.once("cancel", n4);
        var t4 = e4.changes(j2).on("change", D2);
        t4.then(i3, i3), t4.then($2).catch(B2), r2.retry && (o3._changes = t4, o3._abortChanges = n4);
      }
      function n4() {
        t4.cancel();
      }
      function i3() {
        o3.removeListener("cancel", n4);
      }
    }
    function T2() {
      A2().then(function() {
        if (!o3.cancelled)
          return u2.getCheckpoint().then(function(e5) {
            j2 = { since: p2 = e5, limit: y2, batch_size: y2, style: "all_docs", doc_ids: m2, selector: b2, return_docs: true }, r2.filter && (typeof r2.filter != "string" ? j2.include_docs = true : j2.filter = r2.filter), "heartbeat" in r2 && (j2.heartbeat = r2.heartbeat), "timeout" in r2 && (j2.timeout = r2.timeout), r2.query_params && (j2.query_params = r2.query_params), r2.view && (j2.view = r2.view), R2();
          });
        L2();
      }).catch(function(e5) {
        P2("getCheckpoint rejected with ", e5);
      });
    }
    function M2(e5) {
      l2 = false, P2("writeCheckpoint completed with error", e5);
    }
    o3.ready(e4, n3), o3.cancelled ? L2() : (o3._addedListeners || (o3.once("cancel", L2), typeof r2.complete == "function" && (o3.once("error", r2.complete), o3.once("complete", function(e5) {
      r2.complete(null, e5);
    })), o3._addedListeners = true), r2.since === void 0 ? T2() : A2().then(function() {
      return l2 = true, u2.writeCheckpoint(r2.since, k2);
    }).then(function() {
      l2 = false, o3.cancelled ? L2() : (p2 = r2.since, T2());
    }).catch(M2));
  }
  function or() {
    y().call(this), this.cancelled = false, this.state = "pending";
    var e4 = this, t4 = new Promise(function(t5, n3) {
      e4.once("complete", t5), e4.once("error", n3);
    });
    e4.then = function(e5, n3) {
      return t4.then(e5, n3);
    }, e4.catch = function(e5) {
      return t4.catch(e5);
    }, e4.catch(function() {
    });
  }
  function ir(e4, t4) {
    var n3 = t4.PouchConstructor;
    return typeof e4 == "string" ? new n3(e4, t4) : e4;
  }
  function sr(e4, t4, n3, r2) {
    if (typeof n3 == "function" && (r2 = n3, n3 = {}), n3 === void 0 && (n3 = {}), n3.doc_ids && !Array.isArray(n3.doc_ids))
      throw ee(W, "`doc_ids` filter parameter is not a list.");
    n3.complete = r2, (n3 = O(n3)).continuous = n3.continuous || n3.live, n3.retry = "retry" in n3 && n3.retry, n3.PouchConstructor = n3.PouchConstructor || this;
    var o3 = new or(n3);
    return rr(ir(e4, n3), ir(t4, n3), n3, o3), o3;
  }
  function ar(e4, t4, n3, r2) {
    return typeof n3 == "function" && (r2 = n3, n3 = {}), n3 === void 0 && (n3 = {}), (n3 = O(n3)).PouchConstructor = n3.PouchConstructor || this, new ur(e4 = ir(e4, n3), t4 = ir(t4, n3), n3, r2);
  }
  function ur(e4, t4, n3, r2) {
    var o3 = this;
    this.canceled = false;
    var i2 = n3.push ? R({}, n3, n3.push) : n3, s2 = n3.pull ? R({}, n3, n3.pull) : n3;
    function a2(e5) {
      o3.emit("change", { direction: "pull", change: e5 });
    }
    function u2(e5) {
      o3.emit("change", { direction: "push", change: e5 });
    }
    function c2(e5) {
      o3.emit("denied", { direction: "push", doc: e5 });
    }
    function f2(e5) {
      o3.emit("denied", { direction: "pull", doc: e5 });
    }
    function l2() {
      o3.pushPaused = true, o3.pullPaused && o3.emit("paused");
    }
    function d2() {
      o3.pullPaused = true, o3.pushPaused && o3.emit("paused");
    }
    function h2() {
      o3.pushPaused = false, o3.pullPaused && o3.emit("active", { direction: "push" });
    }
    function p2() {
      o3.pullPaused = false, o3.pushPaused && o3.emit("active", { direction: "pull" });
    }
    this.push = sr(e4, t4, i2), this.pull = sr(t4, e4, s2), this.pushPaused = true, this.pullPaused = true;
    var v2 = {};
    function y2(e5) {
      return function(t5, n4) {
        (t5 === "change" && (n4 === a2 || n4 === u2) || t5 === "denied" && (n4 === f2 || n4 === c2) || t5 === "paused" && (n4 === d2 || n4 === l2) || t5 === "active" && (n4 === p2 || n4 === h2)) && (t5 in v2 || (v2[t5] = {}), v2[t5][e5] = true, Object.keys(v2[t5]).length === 2 && o3.removeAllListeners(t5));
      };
    }
    function _2(e5, t5, n4) {
      e5.listeners(t5).indexOf(n4) == -1 && e5.on(t5, n4);
    }
    n3.live && (this.push.on("complete", o3.pull.cancel.bind(o3.pull)), this.pull.on("complete", o3.push.cancel.bind(o3.push))), this.on("newListener", function(e5) {
      e5 === "change" ? (_2(o3.pull, "change", a2), _2(o3.push, "change", u2)) : e5 === "denied" ? (_2(o3.pull, "denied", f2), _2(o3.push, "denied", c2)) : e5 === "active" ? (_2(o3.pull, "active", p2), _2(o3.push, "active", h2)) : e5 === "paused" && (_2(o3.pull, "paused", d2), _2(o3.push, "paused", l2));
    }), this.on("removeListener", function(e5) {
      e5 === "change" ? (o3.pull.removeListener("change", a2), o3.push.removeListener("change", u2)) : e5 === "denied" ? (o3.pull.removeListener("denied", f2), o3.push.removeListener("denied", c2)) : e5 === "active" ? (o3.pull.removeListener("active", p2), o3.push.removeListener("active", h2)) : e5 === "paused" && (o3.pull.removeListener("paused", d2), o3.push.removeListener("paused", l2));
    }), this.pull.on("removeListener", y2("pull")), this.push.on("removeListener", y2("push"));
    var g2 = Promise.all([this.push, this.pull]).then(function(e5) {
      var t5 = { push: e5[0], pull: e5[1] };
      return o3.emit("complete", t5), r2 && r2(null, t5), o3.removeAllListeners(), t5;
    }, function(e5) {
      if (o3.cancel(), r2 ? r2(e5) : o3.emit("error", e5), o3.removeAllListeners(), r2)
        throw e5;
    });
    this.then = function(e5, t5) {
      return g2.then(e5, t5);
    }, this.catch = function(e5) {
      return g2.catch(e5);
    };
  }
  Xn.prototype.getCheckpoint = function() {
    var e4 = this;
    return e4.opts && e4.opts.writeSourceCheckpoint && !e4.opts.writeTargetCheckpoint ? e4.src.get(e4.id).then(function(e5) {
      return e5.last_seq || 0;
    }).catch(function(e5) {
      if (e5.status !== 404)
        throw e5;
      return 0;
    }) : e4.target.get(e4.id).then(function(t4) {
      return e4.opts && e4.opts.writeTargetCheckpoint && !e4.opts.writeSourceCheckpoint ? t4.last_seq || 0 : e4.src.get(e4.id).then(function(e5) {
        return t4.version !== e5.version ? 0 : (n3 = t4.version ? t4.version.toString() : "undefined") in Zn ? Zn[n3](t4, e5) : 0;
        var n3;
      }, function(n3) {
        if (n3.status === 404 && t4.last_seq)
          return e4.src.put({ _id: e4.id, last_seq: 0 }).then(function() {
            return 0;
          }, function(n4) {
            return nr(n4) ? (e4.opts.writeSourceCheckpoint = false, t4.last_seq) : 0;
          });
        throw n3;
      });
    }).catch(function(e5) {
      if (e5.status !== 404)
        throw e5;
      return 0;
    });
  }, p()(or, y()), or.prototype.cancel = function() {
    this.cancelled = true, this.state = "cancelled", this.emit("cancel");
  }, or.prototype.ready = function(e4, t4) {
    var n3 = this;
    function r2() {
      n3.cancel();
    }
    n3._readyCalled || (n3._readyCalled = true, e4.once("destroyed", r2), t4.once("destroyed", r2), n3.once("complete", function() {
      e4.removeListener("destroyed", r2), t4.removeListener("destroyed", r2);
    }));
  }, p()(ur, y()), ur.prototype.cancel = function() {
    this.canceled || (this.canceled = true, this.push.cancel(), this.pull.cancel());
  }, tt.plugin(function(e4) {
    e4.adapter("idb", dn, true);
  }).plugin(function(e4) {
    e4.adapter("http", wn, false), e4.adapter("https", wn, false);
  }).plugin(Vn).plugin(function(e4) {
    e4.replicate = sr, e4.sync = ar, Object.defineProperty(e4.prototype, "replicate", { get: function() {
      var e5 = this;
      return this.replicateMethods === void 0 && (this.replicateMethods = { from: function(t4, n3, r2) {
        return e5.constructor.replicate(t4, e5, n3, r2);
      }, to: function(t4, n3, r2) {
        return e5.constructor.replicate(e5, t4, n3, r2);
      } }), this.replicateMethods;
    } }), e4.prototype.sync = function(e5, t4, n3) {
      return this.constructor.sync(this, e5, t4, n3);
    };
  });
  const cr = tt;
})();
var o = r.o;

// node_modules/xxhash-wasm/esm/xxhash-wasm.js
var t2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 2, 127, 127, 0, 96, 3, 127, 127, 127, 1, 127, 3, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 23, 3, 3, 109, 101, 109, 2, 0, 5, 120, 120, 104, 51, 50, 0, 0, 5, 120, 120, 104, 54, 52, 0, 1, 10, 152, 9, 2, 242, 2, 1, 4, 127, 32, 0, 32, 1, 106, 33, 3, 32, 1, 32, 1, 65, 16, 79, 4, 127, 32, 3, 65, 16, 107, 33, 6, 32, 2, 65, 168, 136, 141, 161, 2, 106, 33, 1, 32, 2, 65, 137, 235, 208, 208, 7, 107, 33, 4, 32, 2, 65, 207, 140, 162, 142, 6, 106, 33, 5, 3, 64, 32, 1, 32, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 1, 32, 4, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 2, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 5, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 6, 32, 0, 65, 4, 106, 34, 0, 79, 13, 0, 11, 32, 2, 65, 12, 119, 32, 5, 65, 18, 119, 106, 32, 4, 65, 7, 119, 106, 32, 1, 65, 1, 119, 106, 5, 32, 2, 65, 177, 207, 217, 178, 1, 106, 11, 106, 33, 2, 3, 64, 32, 3, 32, 0, 65, 4, 106, 79, 4, 64, 32, 2, 32, 0, 40, 2, 0, 65, 189, 220, 202, 149, 124, 108, 106, 65, 17, 119, 65, 175, 214, 211, 190, 2, 108, 33, 2, 32, 0, 65, 4, 106, 33, 0, 12, 1, 11, 11, 3, 64, 32, 0, 32, 3, 73, 4, 64, 32, 2, 32, 0, 45, 0, 0, 65, 177, 207, 217, 178, 1, 108, 106, 65, 11, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 0, 65, 1, 106, 33, 0, 12, 1, 11, 11, 32, 2, 32, 2, 65, 15, 118, 115, 65, 247, 148, 175, 175, 120, 108, 34, 0, 65, 13, 118, 32, 0, 115, 65, 189, 220, 202, 149, 124, 108, 34, 0, 65, 16, 118, 32, 0, 115, 11, 161, 6, 2, 4, 126, 3, 127, 32, 0, 65, 4, 106, 53, 2, 0, 32, 0, 53, 2, 0, 66, 32, 134, 132, 33, 2, 32, 1, 32, 0, 65, 8, 106, 34, 6, 106, 33, 7, 32, 1, 65, 32, 79, 4, 126, 32, 7, 65, 32, 107, 33, 8, 32, 2, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 33, 3, 32, 2, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 33, 4, 32, 2, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 33, 5, 3, 64, 32, 3, 32, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 3, 32, 4, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 4, 32, 2, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 5, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 5, 32, 8, 32, 6, 65, 8, 106, 34, 6, 79, 13, 0, 11, 32, 2, 66, 12, 137, 32, 5, 66, 18, 137, 124, 32, 4, 66, 7, 137, 124, 32, 3, 66, 1, 137, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 2, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 1, 173, 124, 33, 2, 3, 64, 32, 7, 32, 6, 65, 8, 106, 79, 4, 64, 32, 2, 32, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 27, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 33, 2, 32, 6, 65, 8, 106, 33, 6, 12, 1, 11, 11, 32, 6, 65, 4, 106, 32, 7, 77, 4, 64, 32, 2, 32, 6, 53, 2, 0, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 23, 137, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 124, 33, 2, 32, 6, 65, 4, 106, 33, 6, 11, 3, 64, 32, 6, 32, 7, 73, 4, 64, 32, 2, 32, 6, 49, 0, 0, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 126, 133, 66, 11, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 6, 65, 1, 106, 33, 6, 12, 1, 11, 11, 32, 0, 32, 2, 32, 2, 66, 33, 136, 133, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 34, 2, 66, 29, 136, 32, 2, 133, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 126, 34, 2, 66, 32, 136, 32, 2, 133, 34, 2, 66, 32, 136, 62, 2, 0, 32, 0, 65, 4, 106, 32, 2, 62, 2, 0, 11]);
var e2;
function n2(t3, e3, n3) {
  if (e3.buffer.byteLength < t3.byteLength + n3) {
    const i = Math.ceil((t3.byteLength + n3 - e3.buffer.byteLength) / 65536);
    e3.grow(i);
  }
  new Uint8Array(e3.buffer, n3).set(t3);
}
function xxhash_wasm_default() {
  return __async(this, null, function* () {
    const { instance: { exports: { mem: i, xxh32: o2, xxh64: r2 } } } = yield WebAssembly.instantiate(t2);
    function h(t3) {
      let e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return n2(t3, i, 0), o2(0, t3.byteLength, e3) >>> 0;
    }
    function c(t3) {
      let e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      n2(t3, i, 8);
      const h2 = new DataView(i.buffer);
      return h2.setUint32(0, e3, true), h2.setUint32(4, o3, true), r2(0, t3.byteLength), h2;
    }
    return { h32: function(t3) {
      let n3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      e2 || (e2 = new TextEncoder());
      const i2 = e2.encode(t3);
      return h(i2, n3).toString(16);
    }, h32Raw: h, h64: function(t3) {
      let n3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      e2 || (e2 = new TextEncoder());
      const o3 = e2.encode(t3), r3 = c(o3, n3, i2), h2 = r3.getUint32(0, true).toString(16) + r3.getUint32(4, true).toString(16);
      return h2;
    }, h64Raw: function(t3) {
      let e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      return new Uint8Array(c(t3, e3, n3).buffer, 0, 8);
    } };
  });
}

// src/utils_couchdb.ts
var isValidRemoteCouchDBURI = (uri) => {
  if (uri.startsWith("https://"))
    return true;
  if (uri.startsWith("http://"))
    return true;
  return false;
};
var last_post_successed = false;
var getLastPostFailedBySize = () => {
  return !last_post_successed;
};
var connectRemoteCouchDB = (uri, auth) => __async(void 0, null, function* () {
  if (!isValidRemoteCouchDBURI(uri))
    return "Remote URI is not valid";
  const conf = {
    adapter: "http",
    auth,
    fetch: function(url, opts) {
      return __async(this, null, function* () {
        var _a;
        let size_ok = true;
        let size = "";
        const localURL = url.toString().substring(uri.length);
        const method = (_a = opts.method) != null ? _a : "GET";
        if (opts.body) {
          const opts_length = opts.body.toString().length;
          if (opts_length > 1024 * 1024 * 10) {
            size_ok = false;
            if (uri.contains(".cloudantnosqldb.")) {
              last_post_successed = false;
              Logger("This request should fail on IBM Cloudant.", LOG_LEVEL.VERBOSE);
              throw new Error("This request should fail on IBM Cloudant.");
            }
          }
          size = ` (${opts_length})`;
        }
        try {
          const responce = yield fetch(url, opts);
          if (method == "POST" || method == "PUT") {
            last_post_successed = responce.ok;
          } else {
            last_post_successed = true;
          }
          Logger(`HTTP:${method}${size} to:${localURL} -> ${responce.status}`, LOG_LEVEL.VERBOSE);
          return responce;
        } catch (ex) {
          Logger(`HTTP:${method}${size} to:${localURL} -> failed`, LOG_LEVEL.VERBOSE);
          if (!size_ok && (method == "POST" || method == "PUT")) {
            last_post_successed = false;
          }
          Logger(ex);
          throw ex;
        }
      });
    }
  };
  const db = new o(uri, conf);
  try {
    const info = yield db.info();
    return { db, info };
  } catch (ex) {
    let msg = `${ex.name}:${ex.message}`;
    if (ex.name == "TypeError" && ex.message == "Failed to fetch") {
      msg += "\n**Note** This error caused by many reasons. The only sure thing is you didn't touch the server.\nTo check details, open inspector.";
    }
    Logger(ex, LOG_LEVEL.VERBOSE);
    return msg;
  }
});
var checkRemoteVersion = (_0, _1, ..._2) => __async(void 0, [_0, _1, ..._2], function* (db, migrate, barrier = VER) {
  try {
    const versionInfo = yield db.get(VERSIONINFO_DOCID);
    if (versionInfo.type != "versioninfo") {
      return false;
    }
    const version = versionInfo.version;
    if (version < barrier) {
      const versionUpResult = yield migrate(version, barrier);
      if (versionUpResult) {
        yield bumpRemoteVersion(db);
        return true;
      }
    }
    if (version == barrier)
      return true;
    return false;
  } catch (ex) {
    if (ex.status && ex.status == 404) {
      if (yield bumpRemoteVersion(db)) {
        return true;
      }
      return false;
    }
    throw ex;
  }
});
var bumpRemoteVersion = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (db, barrier = VER) {
  const vi = {
    _id: VERSIONINFO_DOCID,
    version: barrier,
    type: "versioninfo"
  };
  const versionInfo = yield resolveWithIgnoreKnownError(db.get(VERSIONINFO_DOCID), vi);
  if (versionInfo.type != "versioninfo") {
    return false;
  }
  vi._rev = versionInfo._rev;
  yield db.put(vi);
  return true;
});

// src/e2ee.ts
var KeyBuffs = [];
var decKeyBuffs = [];
var KEY_RECYCLE_COUNT = 100;
var recycleCount = KEY_RECYCLE_COUNT;
var semiStaticFieldBuffer = null;
var nonceBuffer = new Uint32Array(1);
function getKeyForEncrypt(passphrase) {
  return __async(this, null, function* () {
    const f = KeyBuffs.find((e3) => e3.index == passphrase);
    if (f) {
      recycleCount--;
      if (recycleCount > 0) {
        return [f.key, f.salt];
      }
      KeyBuffs.remove(f);
      recycleCount = KEY_RECYCLE_COUNT;
    }
    const xpassphrase = new TextEncoder().encode(passphrase);
    const digest = yield crypto.subtle.digest({ name: "SHA-256" }, xpassphrase);
    const keyMaterial = yield crypto.subtle.importKey("raw", digest, { name: "PBKDF2" }, false, ["deriveKey"]);
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const key = yield crypto.subtle.deriveKey({
      name: "PBKDF2",
      salt,
      iterations: 1e5,
      hash: "SHA-256"
    }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt"]);
    KeyBuffs.push({
      index: passphrase,
      key,
      salt
    });
    while (KeyBuffs.length > 50) {
      KeyBuffs.shift();
    }
    return [key, salt];
  });
}
function getKeyForDecryption(passphrase, salt) {
  return __async(this, null, function* () {
    const bufKey = passphrase + uint8ArrayToHexString(salt);
    const f = decKeyBuffs.find((e3) => e3.index == bufKey);
    if (f) {
      return [f.key, f.salt];
    }
    const xpassphrase = new TextEncoder().encode(passphrase);
    const digest = yield crypto.subtle.digest({ name: "SHA-256" }, xpassphrase);
    const keyMaterial = yield crypto.subtle.importKey("raw", digest, { name: "PBKDF2" }, false, ["deriveKey"]);
    const key = yield crypto.subtle.deriveKey({
      name: "PBKDF2",
      salt,
      iterations: 1e5,
      hash: "SHA-256"
    }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["decrypt"]);
    decKeyBuffs.push({
      index: bufKey,
      key,
      salt
    });
    while (decKeyBuffs.length > 50) {
      decKeyBuffs.shift();
    }
    return [key, salt];
  });
}
function getSemiStaticField(reset) {
  if (semiStaticFieldBuffer != null && !reset) {
    return semiStaticFieldBuffer;
  }
  semiStaticFieldBuffer = crypto.getRandomValues(new Uint8Array(12));
  return semiStaticFieldBuffer;
}
function getNonce() {
  nonceBuffer[0]++;
  if (nonceBuffer[0] > 1e4) {
    getSemiStaticField(true);
  }
  return nonceBuffer;
}
function uint8ArrayToHexString(src) {
  return Array.from(src).map((e3) => `00${e3.toString(16)}`.slice(-2)).join("");
}
function hexStringToUint8Array(src) {
  const srcArr = [...src];
  const arr = srcArr.reduce((acc, _, i) => i % 2 ? acc : [...acc, srcArr.slice(i, i + 2).join("")], []).map((e3) => parseInt(e3, 16));
  return Uint8Array.from(arr);
}
function encrypt(input, passphrase) {
  return __async(this, null, function* () {
    const [key, salt] = yield getKeyForEncrypt(passphrase);
    const fixedPart = getSemiStaticField();
    const invocationPart = getNonce();
    const iv = Uint8Array.from([...fixedPart, ...new Uint8Array(invocationPart.buffer)]);
    const plainStringified = JSON.stringify(input);
    const plainStringBuffer = new TextEncoder().encode(plainStringified);
    const encryptedDataArrayBuffer = yield crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plainStringBuffer);
    const encryptedData = window.btoa(Array.from(new Uint8Array(encryptedDataArrayBuffer), (char) => String.fromCharCode(char)).join(""));
    const response = [encryptedData, uint8ArrayToHexString(iv), uint8ArrayToHexString(salt)];
    const ret = JSON.stringify(response);
    return ret;
  });
}
function decrypt(encryptedResult, passphrase) {
  return __async(this, null, function* () {
    try {
      const [encryptedData, ivString, salt] = JSON.parse(encryptedResult);
      const [key] = yield getKeyForDecryption(passphrase, hexStringToUint8Array(salt));
      const iv = hexStringToUint8Array(ivString);
      const encryptedDataBin = window.atob(encryptedData);
      const encryptedDataArrayBuffer = Uint8Array.from(encryptedDataBin.split(""), (char) => char.charCodeAt(0));
      const plainStringBuffer = yield crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encryptedDataArrayBuffer);
      const plainStringified = new TextDecoder().decode(plainStringBuffer);
      const plain = JSON.parse(plainStringified);
      return plain;
    } catch (ex) {
      Logger("Couldn't decode! You should wrong the passphrases", LOG_LEVEL.VERBOSE);
      Logger(ex, LOG_LEVEL.VERBOSE);
      throw ex;
    }
  });
}
function testCrypt() {
  return __async(this, null, function* () {
    const src = "supercalifragilisticexpialidocious";
    const encoded = yield encrypt(src, "passwordTest");
    const decrypted = yield decrypt(encoded, "passwordTest");
    if (src != decrypted) {
      Logger("WARNING! Your device would not support encryption.", LOG_LEVEL.VERBOSE);
      return false;
    } else {
      Logger("CRYPT LOGIC OK", LOG_LEVEL.VERBOSE);
      return true;
    }
  });
}

// src/LocalPouchDB.ts
var LocalPouchDB = class {
  constructor(settings, dbname) {
    this.nodeid = "";
    this.isReady = false;
    this.recentModifiedDocs = [];
    this.hashCache = {};
    this.hashCacheRev = {};
    this.corruptedEntries = {};
    this.remoteLocked = false;
    this.remoteLockedAndDeviceNotAccepted = false;
    this.changeHandler = null;
    this.syncHandler = null;
    this.leafArrivedCallbacks = {};
    this.syncStatus = "NOT_CONNECTED";
    this.docArrived = 0;
    this.docSent = 0;
    this.docSeq = "";
    this.updateInfo = () => {
      console.log("default updinfo");
    };
    this.originalSetting = null;
    this.gcRunning = false;
    this.auth = {
      username: "",
      password: ""
    };
    this.dbname = dbname;
    this.settings = settings;
    this.cancelHandler = this.cancelHandler.bind(this);
  }
  cancelHandler(handler) {
    if (handler != null) {
      handler.removeAllListeners();
      handler.cancel();
      handler = null;
    }
    return null;
  }
  onunload() {
    this.recentModifiedDocs = [];
    this.leafArrivedCallbacks;
    this.changeHandler = this.cancelHandler(this.changeHandler);
    this.syncHandler = this.cancelHandler(this.syncHandler);
    this.localDatabase.removeAllListeners();
  }
  close() {
    Logger("Database closed (by close)");
    this.isReady = false;
    this.changeHandler = this.cancelHandler(this.changeHandler);
    if (this.localDatabase != null) {
      this.localDatabase.close();
    }
  }
  disposeHashCache() {
    this.hashCache = {};
    this.hashCacheRev = {};
  }
  updateRecentModifiedDocs(id, rev, deleted) {
    const idrev = id + rev;
    if (deleted) {
      this.recentModifiedDocs = this.recentModifiedDocs.filter((e3) => e3 != idrev);
    } else {
      this.recentModifiedDocs.push(idrev);
      this.recentModifiedDocs = this.recentModifiedDocs.slice(0 - RECENT_MOFIDIED_DOCS_QTY);
    }
  }
  isSelfModified(id, rev) {
    const idrev = id + rev;
    return this.recentModifiedDocs.indexOf(idrev) !== -1;
  }
  initializeDatabase() {
    return __async(this, null, function* () {
      yield this.prepareHashFunctions();
      if (this.localDatabase != null)
        this.localDatabase.close();
      this.changeHandler = this.cancelHandler(this.changeHandler);
      this.localDatabase = null;
      this.localDatabase = new o(this.dbname + "-livesync", {
        auto_compaction: this.settings.useHistory ? false : true,
        revs_limit: 100,
        deterministic_revs: true
      });
      Logger("Database Info");
      Logger(yield this.localDatabase.info(), LOG_LEVEL.VERBOSE);
      const nodeinfo = yield resolveWithIgnoreKnownError(this.localDatabase.get(NODEINFO_DOCID), {
        _id: NODEINFO_DOCID,
        type: "nodeinfo",
        nodeid: ""
      });
      if (nodeinfo.nodeid == "") {
        nodeinfo.nodeid = Math.random().toString(36).slice(-10);
        yield this.localDatabase.put(nodeinfo);
      }
      this.localDatabase.on("close", () => {
        Logger("Database closed.");
        this.isReady = false;
        this.localDatabase.removeAllListeners();
      });
      this.nodeid = nodeinfo.nodeid;
      const changes = this.localDatabase.changes({
        since: "now",
        live: true,
        filter: (doc) => doc.type == "leaf"
      }).on("change", (e3) => {
        if (e3.deleted)
          return;
        this.leafArrived(e3.id);
        this.docSeq = `${e3.seq}`;
      });
      this.changeHandler = changes;
      this.isReady = true;
      Logger("Database is now ready.");
    });
  }
  prepareHashFunctions() {
    return __async(this, null, function* () {
      if (this.h32 != null)
        return;
      const { h32, h64, h32Raw } = yield xxhash_wasm_default();
      this.h32 = h32;
      this.h64 = h64;
      this.h32Raw = h32Raw;
    });
  }
  leafArrived(id) {
    if (typeof this.leafArrivedCallbacks[id] !== "undefined") {
      for (const func of this.leafArrivedCallbacks[id]) {
        func();
      }
      delete this.leafArrivedCallbacks[id];
    }
  }
  waitForLeafReady(id) {
    return new Promise((res, rej) => {
      const timer = setTimeout(() => rej(new Error(`Leaf timed out:${id}`)), LEAF_WAIT_TIMEOUT);
      if (typeof this.leafArrivedCallbacks[id] == "undefined") {
        this.leafArrivedCallbacks[id] = [];
      }
      this.leafArrivedCallbacks[id].push(() => {
        clearTimeout(timer);
        res(true);
      });
    });
  }
  getDBLeaf(id, waitForReady) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      if (this.hashCacheRev[id]) {
        return this.hashCacheRev[id];
      }
      try {
        const w = yield this.localDatabase.get(id);
        if (w.type == "leaf") {
          if (id.startsWith("h:+")) {
            try {
              w.data = yield decrypt(w.data, this.settings.passphrase);
            } catch (e3) {
              Logger("The element of the document has been encrypted, but decryption failed.", LOG_LEVEL.NOTICE);
              throw e3;
            }
          }
          this.hashCache[w.data] = id;
          this.hashCacheRev[id] = w.data;
          return w.data;
        }
        throw new Error(`retrive leaf, but it was not leaf.`);
      } catch (ex) {
        if (ex.status && ex.status == 404 && waitForReady) {
          if ((yield this.waitForLeafReady(id)) === false) {
            throw new Error(`time out (waiting leaf)`);
          }
          try {
            const w = yield this.localDatabase.get(id);
            if (w.type == "leaf") {
              if (id.startsWith("h:+")) {
                try {
                  w.data = yield decrypt(w.data, this.settings.passphrase);
                } catch (e3) {
                  Logger("The element of the document has been encrypted, but decryption failed.", LOG_LEVEL.NOTICE);
                  throw e3;
                }
              }
              this.hashCache[w.data] = id;
              this.hashCacheRev[id] = w.data;
              return w.data;
            }
            throw new Error(`retrive leaf, but it was not leaf.`);
          } catch (ex2) {
            if (ex2.status && ex2.status == 404) {
              throw new Error("leaf is not found");
            }
            Logger(`Something went wrong on retriving leaf`);
            throw ex2;
          }
        } else {
          Logger(`Something went wrong on retriving leaf`);
          throw ex;
        }
      }
    });
  }
  getDBEntryMeta(path, opt) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      const id = path2id(path);
      try {
        let obj = null;
        if (opt) {
          obj = yield this.localDatabase.get(id, opt);
        } else {
          obj = yield this.localDatabase.get(id);
        }
        if (obj.type && obj.type == "leaf") {
          return false;
        }
        if (!obj.type || obj.type && obj.type == "notes" || obj.type == "newnote" || obj.type == "plain") {
          const note = obj;
          let children2 = [];
          if (obj.type == "newnote" || obj.type == "plain") {
            children2 = obj.children;
          }
          const doc = {
            data: "",
            _id: note._id,
            ctime: note.ctime,
            mtime: note.mtime,
            size: note.size,
            _deleted: obj._deleted,
            _rev: obj._rev,
            _conflicts: obj._conflicts,
            children: children2,
            datatype: "newnote"
          };
          return doc;
        }
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          return false;
        }
        throw ex;
      }
      return false;
    });
  }
  getDBEntry(path, opt, dump = false, waitForReady = true) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      const id = path2id(path);
      try {
        let obj = null;
        if (opt) {
          obj = yield this.localDatabase.get(id, opt);
        } else {
          obj = yield this.localDatabase.get(id);
        }
        if (obj.type && obj.type == "leaf") {
          return false;
        }
        if (!obj.type || obj.type && obj.type == "notes") {
          const note = obj;
          const doc = {
            data: note.data,
            _id: note._id,
            ctime: note.ctime,
            mtime: note.mtime,
            size: note.size,
            _deleted: obj._deleted,
            _rev: obj._rev,
            _conflicts: obj._conflicts,
            children: [],
            datatype: "newnote"
          };
          if (typeof this.corruptedEntries[doc._id] != "undefined") {
            delete this.corruptedEntries[doc._id];
          }
          if (dump) {
            Logger(`Simple doc`);
            Logger(doc);
          }
          return doc;
        }
        if (obj.type == "newnote" || obj.type == "plain") {
          try {
            if (dump) {
              Logger(`Enhanced doc`);
              Logger(obj);
            }
            let childrens;
            try {
              childrens = yield Promise.all(obj.children.map((e3) => this.getDBLeaf(e3, waitForReady)));
              if (dump) {
                Logger(`childrens:`);
                Logger(childrens);
              }
            } catch (ex) {
              Logger(`Something went wrong on reading elements of ${obj._id} from database:`, LOG_LEVEL.NOTICE);
              Logger(ex, LOG_LEVEL.VERBOSE);
              this.corruptedEntries[obj._id] = obj;
              return false;
            }
            const data = childrens.join("");
            const doc = {
              data,
              _id: obj._id,
              ctime: obj.ctime,
              mtime: obj.mtime,
              size: obj.size,
              _deleted: obj._deleted,
              _rev: obj._rev,
              children: obj.children,
              datatype: obj.type,
              _conflicts: obj._conflicts
            };
            if (dump) {
              Logger(`therefore:`);
              Logger(doc);
            }
            if (typeof this.corruptedEntries[doc._id] != "undefined") {
              delete this.corruptedEntries[doc._id];
            }
            return doc;
          } catch (ex) {
            if (ex.status && ex.status == 404) {
              Logger(`Missing document content!, could not read ${obj._id} from database.`, LOG_LEVEL.NOTICE);
              return false;
            }
            Logger(`Something went wrong on reading ${obj._id} from database:`, LOG_LEVEL.NOTICE);
            Logger(ex);
          }
        }
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          return false;
        }
        throw ex;
      }
      return false;
    });
  }
  deleteDBEntry(path, opt) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      const id = path2id(path);
      try {
        let obj = null;
        return yield runWithLock("file:" + id, false, () => __async(this, null, function* () {
          if (opt) {
            obj = yield this.localDatabase.get(id, opt);
          } else {
            obj = yield this.localDatabase.get(id);
          }
          if (obj.type && obj.type == "leaf") {
            return false;
          }
          if (!obj.type || obj.type && obj.type == "notes") {
            obj._deleted = true;
            const r2 = yield this.localDatabase.put(obj);
            this.updateRecentModifiedDocs(r2.id, r2.rev, true);
            if (typeof this.corruptedEntries[obj._id] != "undefined") {
              delete this.corruptedEntries[obj._id];
            }
            return true;
          }
          if (obj.type == "newnote" || obj.type == "plain") {
            obj._deleted = true;
            const r2 = yield this.localDatabase.put(obj);
            Logger(`entry removed:${obj._id}-${r2.rev}`);
            this.updateRecentModifiedDocs(r2.id, r2.rev, true);
            if (typeof this.corruptedEntries[obj._id] != "undefined") {
              delete this.corruptedEntries[obj._id];
            }
            return true;
          } else {
            return false;
          }
        }));
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          return false;
        }
        throw ex;
      }
    });
  }
  deleteDBEntryPrefix(prefixSrc) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      let c = 0;
      let readCount = 0;
      const delDocs = [];
      const prefix = path2id(prefixSrc);
      do {
        const result = yield this.localDatabase.allDocs({ include_docs: false, skip: c, limit: 100, conflicts: true });
        readCount = result.rows.length;
        if (readCount > 0) {
          for (const v of result.rows) {
            if (v.id.startsWith(prefix) || v.id.startsWith("/" + prefix)) {
              delDocs.push(v.id);
            } else {
              if (!v.id.startsWith("h:")) {
              }
            }
          }
        }
        c += readCount;
      } while (readCount != 0);
      let deleteCount = 0;
      let notfound = 0;
      for (const v of delDocs) {
        try {
          yield runWithLock("file:" + v, false, () => __async(this, null, function* () {
            const item = yield this.localDatabase.get(v);
            item._deleted = true;
            yield this.localDatabase.put(item);
            this.updateRecentModifiedDocs(item._id, item._rev, true);
          }));
          deleteCount++;
        } catch (ex) {
          if (ex.status && ex.status == 404) {
            notfound++;
          } else {
            throw ex;
          }
        }
      }
      Logger(`deleteDBEntryPrefix:deleted ${deleteCount} items, skipped ${notfound}`);
      return true;
    });
  }
  putDBEntry(note) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      let leftData = note.data;
      const savenNotes = [];
      let processed = 0;
      let made = 0;
      let skiped = 0;
      let pieceSize = MAX_DOC_SIZE_BIN;
      let plainSplit = false;
      let cacheUsed = 0;
      const userpasswordHash = this.h32Raw(new TextEncoder().encode(this.settings.passphrase));
      if (isPlainText(note._id)) {
        pieceSize = MAX_DOC_SIZE;
        plainSplit = true;
      }
      const newLeafs = [];
      do {
        let cPieceSize = pieceSize;
        if (plainSplit) {
          let minimumChunkSize = this.settings.minimumChunkSize;
          if (minimumChunkSize < 10)
            minimumChunkSize = 10;
          let longLineThreshold = this.settings.longLineThreshold;
          if (longLineThreshold < 100)
            longLineThreshold = 100;
          cPieceSize = 0;
          do {
            const n1 = leftData.indexOf("\n", cPieceSize + 1);
            const n22 = leftData.indexOf("\n\n", cPieceSize + 1);
            const n3 = leftData.indexOf("\r\n\r\n", cPieceSize + 1);
            const n4 = leftData.indexOf("\n#", cPieceSize + 1);
            if (n1 == -1 && n22 == -1 && n3 == -1 && n4 == -1) {
              cPieceSize = MAX_DOC_SIZE;
              break;
            }
            if (n1 > longLineThreshold) {
              cPieceSize = n1;
            } else {
              if (n1 > 0 && cPieceSize < n1)
                cPieceSize = n1;
              if (n22 > 0 && cPieceSize < n22)
                cPieceSize = n22 + 1;
              if (n3 > 0 && cPieceSize < n3)
                cPieceSize = n3 + 3;
              if (n4 > 0 && cPieceSize > n4)
                cPieceSize = n4 + 0;
              cPieceSize++;
            }
          } while (cPieceSize < minimumChunkSize);
        }
        const piece = leftData.substring(0, cPieceSize);
        leftData = leftData.substring(cPieceSize);
        processed++;
        let leafid = "";
        let hashedPiece = "";
        let hashQ = 0;
        let tryNextHash = false;
        let needMake = true;
        if (typeof this.hashCache[piece] !== "undefined") {
          hashedPiece = "";
          leafid = this.hashCache[piece];
          needMake = false;
          skiped++;
          cacheUsed++;
        } else {
          if (this.settings.encrypt) {
            hashedPiece = "+" + (this.h32Raw(new TextEncoder().encode(piece)) ^ userpasswordHash).toString(16);
          } else {
            hashedPiece = this.h32(piece);
          }
          leafid = "h:" + hashedPiece;
          do {
            let nleafid = leafid;
            try {
              nleafid = `${leafid}${hashQ}`;
              const pieceData = yield this.localDatabase.get(nleafid);
              if (pieceData._id.startsWith("h:+")) {
                try {
                  pieceData.data = yield decrypt(pieceData.data, this.settings.passphrase);
                } catch (e3) {
                  Logger("Decode failed!");
                  throw e3;
                }
              }
              if (pieceData.type == "leaf" && pieceData.data == piece) {
                leafid = nleafid;
                needMake = false;
                tryNextHash = false;
                this.hashCache[piece] = leafid;
                this.hashCacheRev[leafid] = piece;
              } else if (pieceData.type == "leaf") {
                Logger("hash:collision!!");
                hashQ++;
                tryNextHash = true;
              } else {
                leafid = nleafid;
                tryNextHash = false;
              }
            } catch (ex) {
              if (ex.status && ex.status == 404) {
                leafid = nleafid;
                needMake = true;
                tryNextHash = false;
              } else {
                needMake = false;
                tryNextHash = false;
                throw ex;
              }
            }
          } while (tryNextHash);
          if (needMake) {
            let savePiece = piece;
            if (this.settings.encrypt) {
              const passphrase = this.settings.passphrase;
              savePiece = yield encrypt(piece, passphrase);
            }
            const d = {
              _id: leafid,
              data: savePiece,
              type: "leaf"
            };
            newLeafs.push(d);
            this.hashCache[piece] = leafid;
            this.hashCacheRev[leafid] = piece;
            made++;
          } else {
            skiped++;
          }
        }
        savenNotes.push(leafid);
      } while (leftData != "");
      let saved = true;
      if (newLeafs.length > 0) {
        try {
          const result = yield this.localDatabase.bulkDocs(newLeafs);
          for (const item of result) {
            if (item.ok) {
              this.updateRecentModifiedDocs(item.id, item.rev, false);
              Logger(`save ok:id:${item.id} rev:${item.rev}`, LOG_LEVEL.VERBOSE);
            } else {
              if (item.status && item.status == 409) {
              } else {
                Logger(`save failed:id:${item.id} rev:${item.rev}`, LOG_LEVEL.NOTICE);
                Logger(item);
                saved = false;
              }
            }
          }
        } catch (ex) {
          Logger("ERROR ON SAVING LEAVES:", LOG_LEVEL.NOTICE);
          Logger(ex, LOG_LEVEL.NOTICE);
          saved = false;
        }
      }
      if (saved) {
        Logger(`note content saven, pieces:${processed} new:${made}, skip:${skiped}, cache:${cacheUsed}`);
        const newDoc = {
          NewNote: true,
          children: savenNotes,
          _id: note._id,
          ctime: note.ctime,
          mtime: note.mtime,
          size: note.size,
          type: plainSplit ? "plain" : "newnote"
        };
        yield runWithLock("file:" + newDoc._id, false, () => __async(this, null, function* () {
          try {
            const old = yield this.localDatabase.get(newDoc._id);
            if (!old.type || old.type == "notes" || old.type == "newnote" || old.type == "plain") {
              newDoc._rev = old._rev;
            }
          } catch (ex) {
            if (ex.status && ex.status == 404) {
            } else {
              throw ex;
            }
          }
          const r2 = yield this.localDatabase.put(newDoc, { force: true });
          this.updateRecentModifiedDocs(r2.id, r2.rev, newDoc._deleted);
          if (typeof this.corruptedEntries[note._id] != "undefined") {
            delete this.corruptedEntries[note._id];
          }
          if (this.settings.checkIntegrityOnSave) {
            if (!this.sanCheck(yield this.localDatabase.get(r2.id))) {
              Logger("note save failed!", LOG_LEVEL.NOTICE);
            } else {
              Logger(`note has been surely saved:${newDoc._id}:${r2.rev}`);
            }
          } else {
            Logger(`note saved:${newDoc._id}:${r2.rev}`);
          }
        }));
      } else {
        Logger(`note coud not saved:${note._id}`);
      }
    });
  }
  migrate(from, to) {
    return __async(this, null, function* () {
      Logger(`Database updated from ${from} to ${to}`, LOG_LEVEL.NOTICE);
      return true;
    });
  }
  replicateAllToServer(setting, showingNotice) {
    return new Promise((res, rej) => __async(this, null, function* () {
      yield this.waitForGCComplete();
      this.closeReplication();
      Logger("send all data to server", LOG_LEVEL.NOTICE);
      let notice = null;
      if (showingNotice) {
        notice = new import_obsidian2.Notice("Initializing", 0);
      }
      this.syncStatus = "STARTED";
      this.updateInfo();
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      const auth = {
        username: setting.couchDB_USER,
        password: setting.couchDB_PASSWORD
      };
      const dbret = yield connectRemoteCouchDB(uri, auth);
      if (typeof dbret === "string") {
        Logger(`could not connect to ${uri}:${dbret}`, LOG_LEVEL.NOTICE);
        if (notice != null)
          notice.hide();
        return rej(`could not connect to ${uri}:${dbret}`);
      }
      const syncOptionBase = {
        pull: {
          checkpoint: "target"
        },
        push: {
          checkpoint: "source"
        },
        batches_limit: setting.batches_limit,
        batch_size: setting.batch_size
      };
      const db = dbret.db;
      const totalCount = (yield this.localDatabase.info()).doc_count;
      const replicate = this.localDatabase.replicate.to(db, __spreadValues({ checkpoint: "source" }, syncOptionBase));
      replicate.on("active", () => {
        this.syncStatus = "CONNECTED";
        this.updateInfo();
        if (notice) {
          notice.setMessage("CONNECTED");
        }
      }).on("change", (e3) => {
        this.docSent += e3.docs.length;
        this.updateInfo();
        notice.setMessage(`SENDING:${e3.docs_written}/${totalCount}`);
        Logger(`replicateAllToServer: sending..:${e3.docs.length}`);
      }).on("complete", (info) => {
        this.syncStatus = "COMPLETED";
        this.updateInfo();
        Logger("replicateAllToServer: Completed", LOG_LEVEL.NOTICE);
        this.cancelHandler(replicate);
        if (notice != null)
          notice.hide();
        res(true);
      }).on("error", (e3) => {
        this.syncStatus = "ERRORED";
        this.updateInfo();
        Logger("replicateAllToServer: Pulling Replication error", LOG_LEVEL.INFO);
        Logger(e3);
        this.cancelHandler(replicate);
        if (notice != null)
          notice.hide();
        rej(e3);
      });
    }));
  }
  checkReplicationConnectivity(setting, keepAlive, skipCheck) {
    return __async(this, null, function* () {
      if (!this.isReady) {
        Logger("Database is not ready.");
        return false;
      }
      yield this.waitForGCComplete();
      if (setting.versionUpFlash != "") {
        new import_obsidian2.Notice("Open settings and check message, please.");
        return false;
      }
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      const auth = {
        username: setting.couchDB_USER,
        password: setting.couchDB_PASSWORD
      };
      if (this.syncHandler != null) {
        Logger("Another replication running.");
        return false;
      }
      const dbret = yield connectRemoteCouchDB(uri, auth);
      if (typeof dbret === "string") {
        Logger(`could not connect to ${uri}: ${dbret}`, LOG_LEVEL.NOTICE);
        return false;
      }
      if (!skipCheck) {
        if (!(yield checkRemoteVersion(dbret.db, this.migrate.bind(this), VER))) {
          Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL.NOTICE);
          return false;
        }
        const defMilestonePoint = {
          _id: MILSTONE_DOCID,
          type: "milestoneinfo",
          created: new Date() / 1,
          locked: false,
          accepted_nodes: [this.nodeid]
        };
        const remoteMilestone = yield resolveWithIgnoreKnownError(dbret.db.get(MILSTONE_DOCID), defMilestonePoint);
        this.remoteLocked = remoteMilestone.locked;
        this.remoteLockedAndDeviceNotAccepted = remoteMilestone.locked && remoteMilestone.accepted_nodes.indexOf(this.nodeid) == -1;
        if (remoteMilestone.locked && remoteMilestone.accepted_nodes.indexOf(this.nodeid) == -1) {
          Logger("Remote database marked as 'Auto Sync Locked'. And this devide does not marked as resolved device. see settings dialog.", LOG_LEVEL.NOTICE);
          return false;
        }
        if (typeof remoteMilestone._rev == "undefined") {
          yield dbret.db.put(remoteMilestone);
        }
      }
      const syncOptionBase = {
        batches_limit: setting.batches_limit,
        batch_size: setting.batch_size
      };
      const syncOption = keepAlive ? __spreadValues({ live: true, retry: true, heartbeat: 3e4 }, syncOptionBase) : __spreadValues({}, syncOptionBase);
      return { db: dbret.db, info: dbret.info, syncOptionBase, syncOption };
    });
  }
  openReplication(setting, keepAlive, showResult, callback) {
    return __async(this, null, function* () {
      return yield runWithLock("replicate", false, () => {
        return this._openReplication(setting, keepAlive, showResult, callback, false);
      });
    });
  }
  _openReplication(setting, keepAlive, showResult, callback, retrying) {
    return __async(this, null, function* () {
      const ret = yield this.checkReplicationConnectivity(setting, keepAlive, retrying);
      if (ret === false)
        return false;
      let notice = null;
      if (showResult) {
        notice = new import_obsidian2.Notice("Looking for the point last synchronized point.", 0);
      }
      const { db, syncOptionBase, syncOption } = ret;
      this.syncStatus = "STARTED";
      this.updateInfo();
      let resolved = false;
      const docArrivedOnStart = this.docArrived;
      const docSentOnStart = this.docSent;
      const _openReplicationSync = () => {
        Logger("Sync Main Started");
        if (!retrying) {
          this.originalSetting = setting;
        }
        this.syncHandler = this.cancelHandler(this.syncHandler);
        this.syncHandler = this.localDatabase.sync(db, __spreadProps(__spreadValues({}, syncOption), {
          pull: {
            checkpoint: "target"
          },
          push: {
            checkpoint: "source"
          }
        }));
        this.syncHandler.on("active", () => {
          this.syncStatus = "CONNECTED";
          this.updateInfo();
          Logger("Replication activated");
          if (notice != null)
            notice.setMessage(`Activated..`);
        }).on("change", (e3) => __async(this, null, function* () {
          try {
            if (e3.direction == "pull") {
              yield callback(e3.change.docs);
              Logger(`replicated ${e3.change.docs_read} doc(s)`);
              this.docArrived += e3.change.docs.length;
            } else {
              this.docSent += e3.change.docs.length;
            }
            if (notice != null) {
              notice.setMessage(`\u2191${this.docSent - docSentOnStart} \u2193${this.docArrived - docArrivedOnStart}`);
            }
            this.updateInfo();
          } catch (ex) {
            Logger("Replication callback error", LOG_LEVEL.NOTICE);
            Logger(ex, LOG_LEVEL.NOTICE);
          }
          if (retrying) {
            if (this.docSent - docSentOnStart + (this.docArrived - docArrivedOnStart) > this.originalSetting.batch_size * 2) {
              Logger("Back into original settings once.");
              if (notice != null)
                notice.hide();
              this.syncHandler = this.cancelHandler(this.syncHandler);
              this._openReplication(this.originalSetting, keepAlive, showResult, callback, false);
            }
          }
        })).on("complete", (e3) => {
          this.syncStatus = "COMPLETED";
          this.updateInfo();
          Logger("Replication completed", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
          if (notice != null)
            notice.hide();
          if (!keepAlive) {
            this.syncHandler = this.cancelHandler(this.syncHandler);
          }
        }).on("denied", (e3) => {
          this.syncStatus = "ERRORED";
          this.updateInfo();
          this.syncHandler = this.cancelHandler(this.syncHandler);
          if (notice != null)
            notice.hide();
          Logger("Replication denied", LOG_LEVEL.NOTICE);
          Logger(e3);
        }).on("error", (e3) => {
          this.syncStatus = "ERRORED";
          this.syncHandler = this.cancelHandler(this.syncHandler);
          this.updateInfo();
          if (notice != null)
            notice.hide();
          if (getLastPostFailedBySize()) {
            if (keepAlive) {
              Logger("Replication stopped.", LOG_LEVEL.NOTICE);
            } else {
              const xsetting = JSON.parse(JSON.stringify(setting));
              xsetting.batch_size = Math.ceil(xsetting.batch_size / 2);
              xsetting.batches_limit = Math.ceil(xsetting.batches_limit / 2);
              if (xsetting.batch_size <= 3 || xsetting.batches_limit <= 3) {
                Logger("We can't replicate more lower value.", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
              } else {
                Logger(`Retry with lower batch size:${xsetting.batch_size}/${xsetting.batches_limit}`, showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
                this._openReplication(xsetting, keepAlive, showResult, callback, true);
              }
            }
          } else {
            Logger("Replication error", LOG_LEVEL.NOTICE);
            Logger(e3);
          }
        }).on("paused", (e3) => {
          this.syncStatus = "PAUSED";
          this.updateInfo();
          if (notice != null)
            notice.hide();
          Logger("replication paused", LOG_LEVEL.VERBOSE);
          if (keepAlive && !resolved) {
            resolved = true;
          }
        });
        return this.syncHandler;
      };
      if (!keepAlive) {
        yield _openReplicationSync();
        return true;
      }
      this.syncHandler = this.cancelHandler(this.syncHandler);
      Logger("Pull before replicate.");
      Logger(yield this.localDatabase.info(), LOG_LEVEL.VERBOSE);
      Logger(yield db.info(), LOG_LEVEL.VERBOSE);
      let replicate;
      try {
        replicate = this.localDatabase.replicate.from(db, __spreadValues({ checkpoint: "target" }, syncOptionBase));
        replicate.on("active", () => {
          this.syncStatus = "CONNECTED";
          this.updateInfo();
          Logger("Replication pull activated.");
        }).on("change", (e3) => __async(this, null, function* () {
          try {
            yield callback(e3.docs);
            this.docArrived += e3.docs.length;
            this.updateInfo();
            Logger(`pulled ${e3.docs.length} doc(s)`);
            if (notice != null) {
              notice.setMessage(`Replication pulled:${e3.docs_read}`);
            }
          } catch (ex) {
            Logger("Replication callback error", LOG_LEVEL.NOTICE);
            Logger(ex, LOG_LEVEL.NOTICE);
          }
        }));
        this.syncStatus = "COMPLETED";
        this.updateInfo();
        this.cancelHandler(replicate);
        this.syncHandler = this.cancelHandler(this.syncHandler);
        Logger("Replication pull completed.");
        _openReplicationSync();
        return true;
      } catch (ex) {
        this.syncStatus = "ERRORED";
        this.updateInfo();
        Logger("Pulling Replication error:", LOG_LEVEL.NOTICE);
        Logger(ex, LOG_LEVEL.NOTICE);
        this.cancelHandler(replicate);
        this.syncHandler = this.cancelHandler(this.syncHandler);
        if (notice != null)
          notice.hide();
        throw ex;
      }
    });
  }
  closeReplication() {
    this.syncStatus = "CLOSED";
    this.updateInfo();
    this.syncHandler = this.cancelHandler(this.syncHandler);
    Logger("Replication closed");
  }
  resetDatabase() {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      this.changeHandler = this.cancelHandler(this.changeHandler);
      yield this.closeReplication();
      Logger("Database closed for reset Database.");
      this.isReady = false;
      yield this.localDatabase.destroy();
      this.localDatabase = null;
      yield this.initializeDatabase();
      this.disposeHashCache();
      Logger("Local Database Reset", LOG_LEVEL.NOTICE);
    });
  }
  tryResetRemoteDatabase(setting) {
    return __async(this, null, function* () {
      yield this.closeReplication();
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      const auth = {
        username: setting.couchDB_USER,
        password: setting.couchDB_PASSWORD
      };
      const con = yield connectRemoteCouchDB(uri, auth);
      if (typeof con == "string")
        return;
      try {
        yield con.db.destroy();
        Logger("Remote Database Destroyed", LOG_LEVEL.NOTICE);
        yield this.tryCreateRemoteDatabase(setting);
      } catch (ex) {
        Logger("Something happened on Remote Database Destory:", LOG_LEVEL.NOTICE);
        Logger(ex, LOG_LEVEL.NOTICE);
      }
    });
  }
  tryCreateRemoteDatabase(setting) {
    return __async(this, null, function* () {
      yield this.closeReplication();
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      const auth = {
        username: setting.couchDB_USER,
        password: setting.couchDB_PASSWORD
      };
      const con2 = yield connectRemoteCouchDB(uri, auth);
      if (typeof con2 === "string")
        return;
      Logger("Remote Database Created or Connected", LOG_LEVEL.NOTICE);
    });
  }
  markRemoteLocked(setting, locked) {
    return __async(this, null, function* () {
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      const auth = {
        username: setting.couchDB_USER,
        password: setting.couchDB_PASSWORD
      };
      const dbret = yield connectRemoteCouchDB(uri, auth);
      if (typeof dbret === "string") {
        Logger(`could not connect to ${uri}:${dbret}`, LOG_LEVEL.NOTICE);
        return;
      }
      if (!(yield checkRemoteVersion(dbret.db, this.migrate.bind(this), VER))) {
        Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL.NOTICE);
        return;
      }
      const defInitPoint = {
        _id: MILSTONE_DOCID,
        type: "milestoneinfo",
        created: new Date() / 1,
        locked,
        accepted_nodes: [this.nodeid]
      };
      const remoteMilestone = yield resolveWithIgnoreKnownError(dbret.db.get(MILSTONE_DOCID), defInitPoint);
      remoteMilestone.accepted_nodes = [this.nodeid];
      remoteMilestone.locked = locked;
      if (locked) {
        Logger("Lock remote database to prevent data corruption", LOG_LEVEL.NOTICE);
      } else {
        Logger("Unlock remote database to prevent data corruption", LOG_LEVEL.NOTICE);
      }
      yield dbret.db.put(remoteMilestone);
    });
  }
  markRemoteResolved(setting) {
    return __async(this, null, function* () {
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      const auth = {
        username: setting.couchDB_USER,
        password: setting.couchDB_PASSWORD
      };
      const dbret = yield connectRemoteCouchDB(uri, auth);
      if (typeof dbret === "string") {
        Logger(`could not connect to ${uri}:${dbret}`, LOG_LEVEL.NOTICE);
        return;
      }
      if (!(yield checkRemoteVersion(dbret.db, this.migrate.bind(this), VER))) {
        Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL.NOTICE);
        return;
      }
      const defInitPoint = {
        _id: MILSTONE_DOCID,
        type: "milestoneinfo",
        created: new Date() / 1,
        locked: false,
        accepted_nodes: [this.nodeid]
      };
      const remoteMilestone = yield resolveWithIgnoreKnownError(dbret.db.get(MILSTONE_DOCID), defInitPoint);
      remoteMilestone.accepted_nodes = Array.from(new Set([...remoteMilestone.accepted_nodes, this.nodeid]));
      Logger("Mark this device as 'resolved'.", LOG_LEVEL.NOTICE);
      yield dbret.db.put(remoteMilestone);
    });
  }
  waitForGCComplete() {
    return __async(this, null, function* () {
      while (this.gcRunning) {
        Logger("Waiting for Garbage Collection completed.");
        yield delay(1e3);
      }
    });
  }
  sanCheck(entry) {
    return __async(this, null, function* () {
      if (entry.type == "plain" || entry.type == "newnote") {
        const children2 = entry.children;
        Logger(`sancheck:checking:${entry._id} : ${children2.length}`, LOG_LEVEL.VERBOSE);
        try {
          const dc = yield this.localDatabase.allDocs({ keys: [...children2] });
          if (dc.rows.some((e3) => "error" in e3)) {
            this.corruptedEntries[entry._id] = entry;
            this.disposeHashCache();
            Logger(`sancheck:corrupted:${entry._id} : ${children2.length}`, LOG_LEVEL.VERBOSE);
            return false;
          }
          return true;
        } catch (ex) {
          Logger(ex);
        }
      }
      return false;
    });
  }
  garbageCollect() {
    return __async(this, null, function* () {
      yield runWithLock("replicate", true, () => __async(this, null, function* () {
        if (this.gcRunning)
          return;
        this.gcRunning = true;
        try {
          this.disposeHashCache();
          let c = 0;
          let readCount = 0;
          let hashPieces = [];
          let usedPieces = [];
          Logger("Collecting Garbage");
          do {
            const result = yield this.localDatabase.allDocs({ include_docs: false, skip: c, limit: 2e3, conflicts: true });
            readCount = result.rows.length;
            Logger("checked:" + readCount);
            if (readCount > 0) {
              for (const v of result.rows) {
                if (v.id.startsWith("h:")) {
                  hashPieces = Array.from(new Set([...hashPieces, v.id]));
                } else {
                  const docT = yield this.localDatabase.get(v.id, { revs_info: true });
                  const revs = docT._revs_info;
                  for (const rev of revs) {
                    if (rev.status != "available")
                      continue;
                    const doc = yield this.localDatabase.get(v.id, { rev: rev.rev });
                    if ("children" in doc) {
                      usedPieces = Array.from(new Set([...usedPieces, ...doc.children]));
                      if (doc._conflicts) {
                        for (const cid of doc._conflicts) {
                          const p = yield this.localDatabase.get(doc._id, { rev: cid });
                          if (p.type == "newnote" || p.type == "plain") {
                            usedPieces = Array.from(new Set([...usedPieces, ...p.children]));
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            c += readCount;
          } while (readCount != 0);
          Logger("Finding unused pieces");
          this.disposeHashCache();
          const garbages = hashPieces.filter((e3) => usedPieces.indexOf(e3) == -1);
          let deleteCount = 0;
          Logger("we have to delete:" + garbages.length);
          let deleteDoc = [];
          for (const v of garbages) {
            try {
              const item = yield this.localDatabase.get(v);
              item._deleted = true;
              deleteDoc.push(item);
              if (deleteDoc.length > 50) {
                yield this.localDatabase.bulkDocs(deleteDoc);
                deleteDoc = [];
                Logger("delete:" + deleteCount);
              }
              deleteCount++;
            } catch (ex) {
              if (ex.status && ex.status == 404) {
              } else {
                throw ex;
              }
            }
          }
          if (deleteDoc.length > 0) {
            yield this.localDatabase.bulkDocs(deleteDoc);
          }
          Logger(`GC:deleted ${deleteCount} items.`);
        } finally {
          this.gcRunning = false;
        }
      }));
      this.disposeHashCache();
    });
  }
};

// src/LogDisplayModal.ts
var import_obsidian3 = __toModule(require("obsidian"));
var LogDisplayModal = class extends import_obsidian3.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  updateLog() {
    let msg = "";
    for (const v of this.plugin.logMessage) {
      msg += escapeStringToHTML(v) + "<br>";
    }
    this.logEl.innerHTML = msg;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Sync Status" });
    const div = contentEl.createDiv("");
    div.addClass("op-scrollable");
    div.addClass("op-pre");
    this.logEl = div;
    this.updateLog = this.updateLog.bind(this);
    this.plugin.addLogHook = this.updateLog;
    this.updateLog();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.plugin.addLogHook = null;
  }
};

// src/ConflictResolveModal.ts
var import_obsidian4 = __toModule(require("obsidian"));
var import_diff_match_patch = __toModule(require_diff_match_patch());
var ConflictResolveModal = class extends import_obsidian4.Modal {
  constructor(app, diff, callback) {
    super(app);
    this.result = diff;
    this.callback = callback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "This document has conflicted changes." });
    const div = contentEl.createDiv("");
    div.addClass("op-scrollable");
    let diff = "";
    for (const v of this.result.diff) {
      const x1 = v[0];
      const x2 = v[1];
      if (x1 == import_diff_match_patch.DIFF_DELETE) {
        diff += "<span class='deleted'>" + escapeStringToHTML(x2) + "</span>";
      } else if (x1 == import_diff_match_patch.DIFF_EQUAL) {
        diff += "<span class='normal'>" + escapeStringToHTML(x2) + "</span>";
      } else if (x1 == import_diff_match_patch.DIFF_INSERT) {
        diff += "<span class='added'>" + escapeStringToHTML(x2) + "</span>";
      }
    }
    diff = diff.replace(/\n/g, "<br>");
    div.innerHTML = diff;
    const div2 = contentEl.createDiv("");
    const date1 = new Date(this.result.left.mtime).toLocaleString();
    const date2 = new Date(this.result.right.mtime).toLocaleString();
    div2.innerHTML = `
<span class='deleted'>A:${date1}</span><br /><span class='added'>B:${date2}</span><br> 
        `;
    contentEl.createEl("button", { text: "Keep A" }, (e3) => {
      e3.addEventListener("click", () => __async(this, null, function* () {
        yield this.callback(this.result.right.rev);
        this.callback = null;
        this.close();
      }));
    });
    contentEl.createEl("button", { text: "Keep B" }, (e3) => {
      e3.addEventListener("click", () => __async(this, null, function* () {
        yield this.callback(this.result.left.rev);
        this.callback = null;
        this.close();
      }));
    });
    contentEl.createEl("button", { text: "Concat both" }, (e3) => {
      e3.addEventListener("click", () => __async(this, null, function* () {
        yield this.callback("");
        this.callback = null;
        this.close();
      }));
    });
    contentEl.createEl("button", { text: "Not now" }, (e3) => {
      e3.addEventListener("click", () => {
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.callback != null) {
      this.callback(null);
    }
  }
};

// src/ObsidianLiveSyncSettingTab.ts
var import_obsidian5 = __toModule(require("obsidian"));
var ObsidianLiveSyncSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  testConnection() {
    return __async(this, null, function* () {
      const db = yield connectRemoteCouchDB(this.plugin.settings.couchDB_URI + (this.plugin.settings.couchDB_DBNAME == "" ? "" : "/" + this.plugin.settings.couchDB_DBNAME), {
        username: this.plugin.settings.couchDB_USER,
        password: this.plugin.settings.couchDB_PASSWORD
      });
      if (typeof db === "string") {
        this.plugin.addLog(`could not connect to ${this.plugin.settings.couchDB_URI} : ${this.plugin.settings.couchDB_DBNAME} 
(${db})`, LOG_LEVEL.NOTICE);
        return;
      }
      this.plugin.addLog(`Connected to ${db.info.db_name}`, LOG_LEVEL.NOTICE);
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Self-hosted LiveSync." });
    const w = containerEl.createDiv("");
    const screenElements = {};
    const addScreenElement = (key, element2) => {
      if (!(key in screenElements)) {
        screenElements[key] = [];
      }
      screenElements[key].push(element2);
    };
    w.addClass("sls-setting-menu");
    w.innerHTML = `
<label class='sls-setting-label selected'><input type='radio' name='disp' value='0' class='sls-setting-tab' checked><div class='sls-setting-menu-btn'>\u{1F6F0}\uFE0F</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='10' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F4E6}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='20' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u2699\uFE0F</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='30' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F501}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='40' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F527}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='50' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F9F0}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='60' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F50C}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='70' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F691}</div></label>
        `;
    const menutabs = w.querySelectorAll(".sls-setting-label");
    const changeDisplay = (screen) => {
      for (const k in screenElements) {
        if (k == screen) {
          screenElements[k].forEach((element2) => element2.removeClass("setting-collapsed"));
        } else {
          screenElements[k].forEach((element2) => element2.addClass("setting-collapsed"));
        }
      }
    };
    menutabs.forEach((element2) => {
      const e3 = element2.querySelector(".sls-setting-tab");
      if (!e3)
        return;
      e3.addEventListener("change", (event) => {
        menutabs.forEach((element3) => element3.removeClass("selected"));
        changeDisplay(event.currentTarget.value);
        element2.addClass("selected");
      });
    });
    const containerRemoteDatabaseEl = containerEl.createDiv();
    containerRemoteDatabaseEl.createEl("h3", { text: "Remote Database configuration" });
    const syncWarn = containerRemoteDatabaseEl.createEl("div", { text: `These settings are kept locked while automatic synchronization options are enabled. Disable these options in the "Sync Settings" tab to unlock.` });
    syncWarn.addClass("op-warn");
    syncWarn.addClass("sls-hidden");
    const isAnySyncEnabled = () => {
      if (this.plugin.settings.liveSync)
        return true;
      if (this.plugin.settings.periodicReplication)
        return true;
      if (this.plugin.settings.syncOnFileOpen)
        return true;
      if (this.plugin.settings.syncOnSave)
        return true;
      if (this.plugin.settings.syncOnStart)
        return true;
      if (this.plugin.localDatabase.syncStatus == "CONNECTED")
        return true;
      if (this.plugin.localDatabase.syncStatus == "PAUSED")
        return true;
      return false;
    };
    const applyDisplayEnabled = () => {
      if (isAnySyncEnabled()) {
        dbsettings.forEach((e3) => {
          e3.setDisabled(true).setTooltip("When any sync is enabled, It cound't be changed.");
        });
        syncWarn.removeClass("sls-hidden");
      } else {
        dbsettings.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
        syncWarn.addClass("sls-hidden");
      }
      if (this.plugin.settings.liveSync) {
        syncNonLive.forEach((e3) => {
          e3.setDisabled(true).setTooltip("");
        });
        syncLive.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
      } else if (this.plugin.settings.syncOnFileOpen || this.plugin.settings.syncOnSave || this.plugin.settings.syncOnStart || this.plugin.settings.periodicReplication) {
        syncNonLive.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
        syncLive.forEach((e3) => {
          e3.setDisabled(true).setTooltip("");
        });
      } else {
        syncNonLive.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
        syncLive.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
      }
    };
    const dbsettings = [];
    dbsettings.push(new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("URI").addText((text2) => text2.setPlaceholder("https://........").setValue(this.plugin.settings.couchDB_URI).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.couchDB_URI = value;
      yield this.plugin.saveSettings();
    }))), new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Username").setDesc("username").addText((text2) => text2.setPlaceholder("").setValue(this.plugin.settings.couchDB_USER).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.couchDB_USER = value;
      yield this.plugin.saveSettings();
    }))), new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Password").setDesc("password").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.couchDB_PASSWORD).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.couchDB_PASSWORD = value;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "password");
    }), new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Database name").addText((text2) => text2.setPlaceholder("").setValue(this.plugin.settings.couchDB_DBNAME).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.couchDB_DBNAME = value;
      yield this.plugin.saveSettings();
    }))));
    new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Test Database Connection").setDesc("Open database connection. If the remote database is not found and you have the privilege to create a database, the database will be created.").addButton((button) => button.setButtonText("Test").setDisabled(false).onClick(() => __async(this, null, function* () {
      yield this.testConnection();
    })));
    addScreenElement("0", containerRemoteDatabaseEl);
    const containerLocalDatabaseEl = containerEl.createDiv();
    containerLocalDatabaseEl.createEl("h3", { text: "Local Database configuration" });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Batch database update").setDesc("Delay all changes, save once before replication or opening another file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.batchSave).onChange((value) => __async(this, null, function* () {
      if (value && this.plugin.settings.liveSync) {
        Logger("LiveSync and Batch database update cannot be used at the same time.", LOG_LEVEL.NOTICE);
        toggle.setValue(false);
        return;
      }
      this.plugin.settings.batchSave = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Auto Garbage Collection delay").setDesc("(seconds), if you set zero, you have to run manually.").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.gcDelay + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v > 5e3) {
          v = 0;
        }
        this.plugin.settings.gcDelay = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Manual Garbage Collect").addButton((button) => button.setButtonText("Collect now").setDisabled(false).onClick(() => __async(this, null, function* () {
      yield this.plugin.garbageCollect();
    })));
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("End to End Encryption").setDesc("Encrypting contents on the database.").addToggle((toggle) => toggle.setValue(this.plugin.settings.workingEncrypt).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.workingEncrypt = value;
      phasspharase.setDisabled(!value);
      yield this.plugin.saveSettings();
    })));
    const phasspharase = new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Passphrase").setDesc("Encrypting passphrase").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.workingPassphrase).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.workingPassphrase = value;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "password");
    });
    phasspharase.setDisabled(!this.plugin.settings.workingEncrypt);
    containerLocalDatabaseEl.createEl("div", {
      text: "When you change any encryption enabled or passphrase, you have to reset all databases to make sure that the last password is unused and erase encrypted data from anywhere. This operation will not lost your vault if you are fully synced."
    });
    const applyEncryption = (sendToServer) => __async(this, null, function* () {
      if (this.plugin.settings.workingEncrypt && this.plugin.settings.workingPassphrase == "") {
        Logger("If you enable encryption, you have to set the passphrase", LOG_LEVEL.NOTICE);
        return;
      }
      if (this.plugin.settings.workingEncrypt && !(yield testCrypt())) {
        Logger("WARNING! Your device would not support encryption.", LOG_LEVEL.NOTICE);
        return;
      }
      if (!this.plugin.settings.workingEncrypt) {
        this.plugin.settings.workingPassphrase = "";
      }
      this.plugin.settings.liveSync = false;
      this.plugin.settings.periodicReplication = false;
      this.plugin.settings.syncOnSave = false;
      this.plugin.settings.syncOnStart = false;
      this.plugin.settings.syncOnFileOpen = false;
      this.plugin.settings.encrypt = this.plugin.settings.workingEncrypt;
      this.plugin.settings.passphrase = this.plugin.settings.workingPassphrase;
      yield this.plugin.saveSettings();
      yield this.plugin.resetLocalDatabase();
      if (sendToServer) {
        yield this.plugin.initializeDatabase(true);
        yield this.plugin.markRemoteLocked();
        yield this.plugin.tryResetRemoteDatabase();
        yield this.plugin.markRemoteLocked();
        yield this.plugin.replicateAllToServer(true);
      } else {
        yield this.plugin.markRemoteResolved();
        yield this.plugin.replicate(true);
      }
    });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Apply").setDesc("apply encryption settinngs, and re-initialize database").addButton((button) => button.setButtonText("Apply and send").setWarning().setDisabled(false).setClass("sls-btn-left").onClick(() => __async(this, null, function* () {
      yield applyEncryption(true);
    }))).addButton((button) => button.setButtonText("Apply and receive").setWarning().setDisabled(false).setClass("sls-btn-right").onClick(() => __async(this, null, function* () {
      yield applyEncryption(false);
    })));
    containerLocalDatabaseEl.createEl("div", {
      text: (0, import_obsidian5.sanitizeHTMLToDom)(`Advanced settings<br>
                Configuration of how LiveSync makes chunks from the file.`)
    });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Minimum chunk size").setDesc("(letters), minimum chunk size.").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.minimumChunkSize + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v < 10 || v > 1e3) {
          v = 10;
        }
        this.plugin.settings.minimumChunkSize = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("LongLine Threshold").setDesc("(letters), If the line is longer than this, make the line to chunk").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.longLineThreshold + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v < 10 || v > 1e3) {
          v = 10;
        }
        this.plugin.settings.longLineThreshold = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    addScreenElement("10", containerLocalDatabaseEl);
    const containerGeneralSettingsEl = containerEl.createDiv();
    containerGeneralSettingsEl.createEl("h3", { text: "General Settings" });
    new import_obsidian5.Setting(containerGeneralSettingsEl).setName("Do not show low-priority Log").setDesc("Reduce log infomations").addToggle((toggle) => toggle.setValue(this.plugin.settings.lessInformationInLog).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.lessInformationInLog = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerGeneralSettingsEl).setName("Verbose Log").setDesc("Show verbose log ").addToggle((toggle) => toggle.setValue(this.plugin.settings.showVerboseLog).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.showVerboseLog = value;
      yield this.plugin.saveSettings();
    })));
    addScreenElement("20", containerGeneralSettingsEl);
    const containerSyncSettingEl = containerEl.createDiv();
    containerSyncSettingEl.createEl("h3", { text: "Sync setting" });
    if (this.plugin.settings.versionUpFlash != "") {
      const c = containerSyncSettingEl.createEl("div", { text: this.plugin.settings.versionUpFlash });
      c.createEl("button", { text: "I got it and updated." }, (e3) => {
        e3.addClass("mod-cta");
        e3.addEventListener("click", () => __async(this, null, function* () {
          this.plugin.settings.versionUpFlash = "";
          yield this.plugin.saveSettings();
          applyDisplayEnabled();
          c.remove();
        }));
      });
      c.addClass("op-warn");
    }
    const syncLive = [];
    const syncNonLive = [];
    syncLive.push(new import_obsidian5.Setting(containerSyncSettingEl).setName("LiveSync").setDesc("Sync realtime").addToggle((toggle) => toggle.setValue(this.plugin.settings.liveSync).onChange((value) => __async(this, null, function* () {
      if (value && this.plugin.settings.batchSave) {
        Logger("LiveSync and Batch database update cannot be used at the same time.", LOG_LEVEL.NOTICE);
        toggle.setValue(false);
        return;
      }
      this.plugin.settings.liveSync = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
      yield this.plugin.realizeSettingSyncMode();
    }))));
    syncNonLive.push(new import_obsidian5.Setting(containerSyncSettingEl).setName("Periodic Sync").setDesc("Sync periodically").addToggle((toggle) => toggle.setValue(this.plugin.settings.periodicReplication).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.periodicReplication = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
    }))), new import_obsidian5.Setting(containerSyncSettingEl).setName("Periodic sync intreval").setDesc("Interval (sec)").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.periodicReplicationInterval + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v > 5e3) {
          v = 0;
        }
        this.plugin.settings.periodicReplicationInterval = v;
        yield this.plugin.saveSettings();
        applyDisplayEnabled();
      }));
      text2.inputEl.setAttribute("type", "number");
    }), new import_obsidian5.Setting(containerSyncSettingEl).setName("Sync on Save").setDesc("When you save file, sync automatically").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnSave).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.syncOnSave = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
    }))), new import_obsidian5.Setting(containerSyncSettingEl).setName("Sync on File Open").setDesc("When you open file, sync automatically").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnFileOpen).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.syncOnFileOpen = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
    }))), new import_obsidian5.Setting(containerSyncSettingEl).setName("Sync on Start").setDesc("Start synchronization on Obsidian started.").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnStart).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.syncOnStart = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
    }))));
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Use Trash for deleted files").setDesc("Do not delete files that deleted in remote, just move to trash.").addToggle((toggle) => toggle.setValue(this.plugin.settings.trashInsteadDelete).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.trashInsteadDelete = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Do not delete empty folder").setDesc("Normally, folder is deleted When the folder became empty by replication. enable this, leave it as is").addToggle((toggle) => toggle.setValue(this.plugin.settings.doNotDeleteFolder).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.doNotDeleteFolder = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Use newer file if conflicted (beta)").setDesc("Resolve conflicts by newer files automatically.").addToggle((toggle) => toggle.setValue(this.plugin.settings.resolveConflictsByNewerFile).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.resolveConflictsByNewerFile = value;
      yield this.plugin.saveSettings();
    })));
    containerSyncSettingEl.createEl("div", {
      text: (0, import_obsidian5.sanitizeHTMLToDom)(`Advanced settings<br>
            If you reached the payload size limit when using IBM Cloudant, please set batch size and batch limit to a lower value.`)
    });
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Batch size").setDesc("Number of change feed items to process at a time. Defaults to 250.").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.batch_size + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v < 10) {
          v = 10;
        }
        this.plugin.settings.batch_size = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Batch limit").setDesc("Number of batches to process at a time. Defaults to 40. This along with batch size controls how many docs are kept in memory at a time.").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.batches_limit + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v < 10) {
          v = 10;
        }
        this.plugin.settings.batches_limit = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    addScreenElement("30", containerSyncSettingEl);
    const containerMiscellaneousEl = containerEl.createDiv();
    containerMiscellaneousEl.createEl("h3", { text: "Miscellaneous" });
    new import_obsidian5.Setting(containerMiscellaneousEl).setName("Show status inside editor").setDesc("").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStatusOnEditor).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.showStatusOnEditor = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerMiscellaneousEl).setName("Check integrity on saving").setDesc("Check database integrity on saving to database").addToggle((toggle) => toggle.setValue(this.plugin.settings.checkIntegrityOnSave).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.checkIntegrityOnSave = value;
      yield this.plugin.saveSettings();
    })));
    let currentPrest = "NONE";
    new import_obsidian5.Setting(containerMiscellaneousEl).setName("Presets").setDesc("Apply preset configuration").addDropdown((dropdown) => dropdown.addOptions({ NONE: "", LIVESYNC: "LiveSync", PERIODIC: "Periodic w/ batch", DISABLE: "Disable all sync" }).setValue(currentPrest).onChange((value) => currentPrest = value)).addButton((button) => button.setButtonText("Apply").setDisabled(false).setCta().onClick(() => __async(this, null, function* () {
      if (currentPrest == "") {
        Logger("Select any preset.", LOG_LEVEL.NOTICE);
        return;
      }
      this.plugin.settings.batchSave = false;
      this.plugin.settings.liveSync = false;
      this.plugin.settings.periodicReplication = false;
      this.plugin.settings.syncOnSave = false;
      this.plugin.settings.syncOnStart = false;
      this.plugin.settings.syncOnFileOpen = false;
      if (currentPrest == "LIVESYNC") {
        this.plugin.settings.liveSync = true;
        Logger("Synchronization setting configured as LiveSync.", LOG_LEVEL.NOTICE);
      } else if (currentPrest == "PERIODIC") {
        this.plugin.settings.batchSave = true;
        this.plugin.settings.periodicReplication = true;
        this.plugin.settings.syncOnSave = false;
        this.plugin.settings.syncOnStart = true;
        this.plugin.settings.syncOnFileOpen = true;
        Logger("Synchronization setting configured as Periodic sync with batch database update.", LOG_LEVEL.NOTICE);
      } else {
        Logger("All synchronization disabled.", LOG_LEVEL.NOTICE);
      }
      this.plugin.saveSettings();
      yield this.plugin.realizeSettingSyncMode();
    })));
    new import_obsidian5.Setting(containerMiscellaneousEl).setName("Use history (beta)").setDesc("Use history dialog (Restart required, auto compaction would be disabled, and more storage will be consumed)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useHistory).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.useHistory = value;
      yield this.plugin.saveSettings();
    })));
    addScreenElement("40", containerMiscellaneousEl);
    const containerHatchEl = containerEl.createDiv();
    containerHatchEl.createEl("h3", { text: "Hatch" });
    if (this.plugin.localDatabase.remoteLockedAndDeviceNotAccepted) {
      const c = containerHatchEl.createEl("div", {
        text: "To prevent unwanted vault corruption, the remote database has been locked for synchronization, and this device was not marked as 'resolved'. it caused by some operations like this. re-initialized. Local database initialization should be required. please back your vault up, reset local database, and press 'Mark this device as resolved'. "
      });
      c.createEl("button", { text: "I'm ready, mark this device 'resolved'" }, (e3) => {
        e3.addClass("mod-warning");
        e3.addEventListener("click", () => __async(this, null, function* () {
          yield this.plugin.markRemoteResolved();
          c.remove();
        }));
      });
      c.addClass("op-warn");
    } else {
      if (this.plugin.localDatabase.remoteLocked) {
        const c = containerHatchEl.createEl("div", {
          text: "To prevent unwanted vault corruption, the remote database has been locked for synchronization. (This device is marked 'resolved') When all your devices are marked 'resolved', unlock the database."
        });
        c.createEl("button", { text: "I'm ready, unlock the database" }, (e3) => {
          e3.addClass("mod-warning");
          e3.addEventListener("click", () => __async(this, null, function* () {
            yield this.plugin.markRemoteUnlocked();
            c.remove();
          }));
        });
        c.addClass("op-warn");
      }
    }
    const hatchWarn = containerHatchEl.createEl("div", { text: `To stop the bootup sequence for fixing problems on databases, you can put redflag.md on top of your vault (Rebooting obsidian is required).` });
    hatchWarn.addClass("op-warn");
    const dropHistory = (sendToServer) => __async(this, null, function* () {
      this.plugin.settings.liveSync = false;
      this.plugin.settings.periodicReplication = false;
      this.plugin.settings.syncOnSave = false;
      this.plugin.settings.syncOnStart = false;
      this.plugin.settings.syncOnFileOpen = false;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
      yield this.plugin.resetLocalDatabase();
      if (sendToServer) {
        yield this.plugin.initializeDatabase(true);
        yield this.plugin.markRemoteLocked();
        yield this.plugin.tryResetRemoteDatabase();
        yield this.plugin.markRemoteLocked();
        yield this.plugin.replicateAllToServer(true);
      } else {
        yield this.plugin.markRemoteResolved();
        yield this.plugin.replicate(true);
      }
    });
    new import_obsidian5.Setting(containerHatchEl).setName("Verify and repair all files").setDesc("Verify and repair all files and update database without dropping history").addButton((button) => button.setButtonText("Verify and repair").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      const files = this.app.vault.getFiles();
      Logger("Verify and repair all files started", LOG_LEVEL.NOTICE);
      const notice = new import_obsidian5.Notice("", 0);
      let i = 0;
      for (const file of files) {
        i++;
        Logger(`Update into ${file.path}`);
        notice.setMessage(`${i}/${files.length}
${file.path}`);
        try {
          yield this.plugin.updateIntoDB(file);
        } catch (ex) {
          Logger("could not update:");
          Logger(ex);
        }
      }
      notice.hide();
      Logger("done", LOG_LEVEL.NOTICE);
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Sanity check").setDesc("Verify").addButton((button) => button.setButtonText("Sanity check").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      const notice = new import_obsidian5.Notice("", 0);
      Logger(`Begin sanity check`, LOG_LEVEL.INFO);
      notice.setMessage(`Begin sanity check`);
      yield runWithLock("sancheck", true, () => __async(this, null, function* () {
        const db = this.plugin.localDatabase.localDatabase;
        const wf = yield db.allDocs();
        const filesDatabase = wf.rows.filter((e3) => !e3.id.startsWith("h:") && !e3.id.startsWith("ps:") && e3.id != "obsydian_livesync_version").map((e3) => e3.id);
        let count = 0;
        for (const id of filesDatabase) {
          count++;
          notice.setMessage(`${count}/${filesDatabase.length}
${id2path(id)}`);
          const w2 = yield db.get(id);
          if (!(yield this.plugin.localDatabase.sanCheck(w2))) {
            Logger(`The file ${id2path(id)} missing child(ren)`, LOG_LEVEL.NOTICE);
          }
        }
      }));
      notice.hide();
      Logger(`Done`, LOG_LEVEL.NOTICE);
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Drop History").setDesc("Initialize local and remote database, and send all or retrieve all again.").addButton((button) => button.setButtonText("Drop and send").setWarning().setDisabled(false).setClass("sls-btn-left").onClick(() => __async(this, null, function* () {
      yield dropHistory(true);
    }))).addButton((button) => button.setButtonText("Drop and receive").setWarning().setDisabled(false).setClass("sls-btn-right").onClick(() => __async(this, null, function* () {
      yield dropHistory(false);
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Lock remote database").setDesc("Lock remote database for synchronize").addButton((button) => button.setButtonText("Lock").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      yield this.plugin.markRemoteLocked();
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Suspend file watching").setDesc("if enables it, all file operations are ignored.").addToggle((toggle) => toggle.setValue(this.plugin.settings.suspendFileWatching).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.suspendFileWatching = value;
      yield this.plugin.saveSettings();
    })));
    containerHatchEl.createEl("div", {
      text: (0, import_obsidian5.sanitizeHTMLToDom)(`Advanced buttons<br>
                These buttons could break your database easily.`)
    });
    new import_obsidian5.Setting(containerHatchEl).setName("Reset remote database").setDesc("Reset remote database, this affects only database. If you replicate again, remote database will restored by local database.").addButton((button) => button.setButtonText("Reset").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      yield this.plugin.tryResetRemoteDatabase();
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Reset local database").setDesc("Reset local database, this affects only database. If you replicate again, local database will restored by remote database.").addButton((button) => button.setButtonText("Reset").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      yield this.plugin.resetLocalDatabase();
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Initialize local database again").setDesc("WARNING: Reset local database and reconstruct by storage data. It affects local database, but if you replicate remote as is, remote data will be merged or corrupted.").addButton((button) => button.setButtonText("INITIALIZE").setWarning().setDisabled(false).onClick(() => __async(this, null, function* () {
      yield this.plugin.resetLocalDatabase();
      yield this.plugin.initializeDatabase();
    })));
    addScreenElement("50", containerHatchEl);
    const containerPluginSettings = containerEl.createDiv();
    containerPluginSettings.createEl("h3", { text: "Plugins and settings (beta)" });
    const updateDisabledOfDeviceAndVaultName = () => {
      vaultName.setDisabled(this.plugin.settings.autoSweepPlugins || this.plugin.settings.autoSweepPluginsPeriodic);
      vaultName.setTooltip(this.plugin.settings.autoSweepPlugins || this.plugin.settings.autoSweepPluginsPeriodic ? "You could not change when you enabling auto sweep." : "");
    };
    new import_obsidian5.Setting(containerPluginSettings).setName("Enable plugin synchronization").addToggle((toggle) => toggle.setValue(this.plugin.settings.usePluginSync).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.usePluginSync = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerPluginSettings).setName("Show own plugins and settings").addToggle((toggle) => toggle.setValue(this.plugin.settings.showOwnPlugins).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.showOwnPlugins = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerPluginSettings).setName("Sweep plugins automatically").setDesc("Sweep plugins before replicating.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSweepPlugins).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoSweepPlugins = value;
      updateDisabledOfDeviceAndVaultName();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerPluginSettings).setName("Sweep plugins periodically").setDesc("Sweep plugins each 1 minutes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSweepPluginsPeriodic).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoSweepPluginsPeriodic = value;
      updateDisabledOfDeviceAndVaultName();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerPluginSettings).setName("Notify updates").setDesc("Notify when any device has a newer plugin or its setting.").addToggle((toggle) => toggle.setValue(this.plugin.settings.notifyPluginOrSettingUpdated).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.notifyPluginOrSettingUpdated = value;
      yield this.plugin.saveSettings();
    })));
    const vaultName = new import_obsidian5.Setting(containerPluginSettings).setName("Device and Vault name").setDesc("").addText((text2) => {
      text2.setPlaceholder("desktop-main").setValue(this.plugin.deviceAndVaultName).onChange((value) => __async(this, null, function* () {
        this.plugin.deviceAndVaultName = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian5.Setting(containerPluginSettings).setName("Open").setDesc("Open the plugin dialog").addButton((button) => {
      button.setButtonText("Open").setDisabled(false).onClick(() => {
        this.plugin.showPluginSyncModal();
      });
    });
    updateDisabledOfDeviceAndVaultName();
    addScreenElement("60", containerPluginSettings);
    const containerCorruptedDataEl = containerEl.createDiv();
    containerCorruptedDataEl.createEl("h3", { text: "Corrupted data" });
    if (Object.keys(this.plugin.localDatabase.corruptedEntries).length > 0) {
      const cx = containerCorruptedDataEl.createEl("div", { text: "If you have copy of these items on any device, simply edit once or twice. Or not, delete this. sorry.." });
      for (const k in this.plugin.localDatabase.corruptedEntries) {
        const xx = cx.createEl("div", { text: `${k}` });
        const ba = xx.createEl("button", { text: `Delete this` }, (e3) => {
          e3.addEventListener("click", () => __async(this, null, function* () {
            yield this.plugin.localDatabase.deleteDBEntry(k);
            xx.remove();
          }));
        });
        ba.addClass("mod-warning");
        xx.createEl("button", { text: `Restore from file` }, (e3) => {
          e3.addEventListener("click", () => __async(this, null, function* () {
            const f = yield this.app.vault.getFiles().filter((e4) => path2id(e4.path) == k);
            if (f.length == 0) {
              Logger("Not found in vault", LOG_LEVEL.NOTICE);
              return;
            }
            yield this.plugin.updateIntoDB(f[0]);
            xx.remove();
          }));
        });
        xx.addClass("mod-warning");
      }
    } else {
      containerCorruptedDataEl.createEl("div", { text: "There is no corrupted data." });
    }
    applyDisplayEnabled();
    addScreenElement("70", containerCorruptedDataEl);
    changeDisplay("0");
  }
};

// src/DocumentHistoryModal.ts
var import_obsidian6 = __toModule(require("obsidian"));
var import_diff_match_patch2 = __toModule(require_diff_match_patch());
var DocumentHistoryModal = class extends import_obsidian6.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.showDiff = false;
    this.revs_info = [];
    this.plugin = plugin;
    this.file = file.path;
    if (localStorage.getItem("ols-history-highlightdiff") == "1") {
      this.showDiff = true;
    }
  }
  loadFile() {
    return __async(this, null, function* () {
      const db = this.plugin.localDatabase;
      const w = yield db.localDatabase.get(path2id(this.file), { revs_info: true });
      this.revs_info = w._revs_info.filter((e3) => e3.status == "available");
      this.range.max = `${this.revs_info.length - 1}`;
      this.range.value = this.range.max;
      this.fileInfo.setText(`${this.file} / ${this.revs_info.length} revisions`);
      yield this.loadRevs();
    });
  }
  loadRevs() {
    return __async(this, null, function* () {
      const db = this.plugin.localDatabase;
      const index = this.revs_info.length - 1 - this.range.value / 1;
      const rev = this.revs_info[index];
      const w = yield db.getDBEntry(path2id(this.file), { rev: rev.rev }, false, false);
      if (w === false) {
        this.info.innerHTML = "";
        this.contentView.innerHTML = `Could not read this revision<br>(${rev.rev})`;
      } else {
        this.info.innerHTML = `Modified:${new Date(w.mtime).toLocaleString()}`;
        let result = "";
        if (this.showDiff) {
          const prevRevIdx = this.revs_info.length - 1 - (this.range.value / 1 - 1);
          if (prevRevIdx >= 0 && prevRevIdx < this.revs_info.length) {
            const oldRev = this.revs_info[prevRevIdx].rev;
            const w2 = yield db.getDBEntry(path2id(this.file), { rev: oldRev }, false, false);
            if (w2 != false) {
              const dmp = new import_diff_match_patch2.diff_match_patch();
              const diff = dmp.diff_main(w2.data, w.data);
              dmp.diff_cleanupSemantic(diff);
              for (const v of diff) {
                const x1 = v[0];
                const x2 = v[1];
                if (x1 == import_diff_match_patch2.DIFF_DELETE) {
                  result += "<span class='history-deleted'>" + escapeStringToHTML(x2) + "</span>";
                } else if (x1 == import_diff_match_patch2.DIFF_EQUAL) {
                  result += "<span class='history-normal'>" + escapeStringToHTML(x2) + "</span>";
                } else if (x1 == import_diff_match_patch2.DIFF_INSERT) {
                  result += "<span class='history-added'>" + escapeStringToHTML(x2) + "</span>";
                }
              }
              result = result.replace(/\n/g, "<br>");
            } else {
              result = escapeStringToHTML(w.data);
            }
          } else {
            result = escapeStringToHTML(w.data);
          }
        } else {
          result = escapeStringToHTML(w.data);
        }
        this.contentView.innerHTML = result;
      }
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Document History" });
    this.fileInfo = contentEl.createDiv("");
    this.fileInfo.addClass("op-info");
    const divView = contentEl.createDiv("");
    divView.addClass("op-flex");
    divView.createEl("input", { type: "range" }, (e3) => {
      this.range = e3;
      e3.addEventListener("change", (e4) => {
        this.loadRevs();
      });
      e3.addEventListener("input", (e4) => {
        this.loadRevs();
      });
    });
    contentEl.createDiv("", (e3) => {
      e3.createEl("label", {}, (label) => {
        label.appendChild(createEl("input", { type: "checkbox" }, (checkbox) => {
          if (this.showDiff) {
            checkbox.checked = true;
          }
          checkbox.addEventListener("input", (evt) => {
            this.showDiff = checkbox.checked;
            localStorage.setItem("ols-history-highlightdiff", this.showDiff == true ? "1" : "");
            this.loadRevs();
          });
        }));
        label.appendText("Highlight diff");
      });
    }).addClass("op-info");
    this.info = contentEl.createDiv("");
    this.info.addClass("op-info");
    this.loadFile();
    const div = contentEl.createDiv({ text: "Loading old revisions..." });
    this.contentView = div;
    div.addClass("op-scrollable");
    div.addClass("op-pre");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/tslib/modules/index.js
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// src/PluginPane.svelte
function add_css(target) {
  append_styles(target, "svelte-1907s6a", ".ols-plugins-div-buttons.svelte-1907s6a{display:flex;flex-direction:row;justify-content:flex-end;margin-top:8px}.wrapToggle.svelte-1907s6a{display:flex;justify-content:center;align-content:center}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i][0];
  child_ctx[26] = list[i][1];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block_2(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="3" class="sls-table-tail tcenter">Retrieving...</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_else_block_1(ctx) {
  let div1;
  let div0;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[20](ctx[0]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "checkbox-container");
      toggle_class(div0, "is-enabled", ctx[3][ctx[0].deviceVaultName + "---" + ctx[0].manifest.id + "---plugin"]);
      attr(div1, "class", "wrapToggle svelte-1907s6a");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(div0, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 12) {
        toggle_class(div0, "is-enabled", ctx[3][ctx[0].deviceVaultName + "---" + ctx[0].manifest.id + "---plugin"]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1(ctx) {
  let t3;
  return {
    c() {
      t3 = text("-");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_else_block(ctx) {
  let div1;
  let div0;
  let mounted;
  let dispose;
  function click_handler_2() {
    return ctx[21](ctx[0]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "checkbox-container");
      toggle_class(div0, "is-enabled", ctx[3][ctx[0].deviceVaultName + "---" + ctx[0].manifest.id + "---setting"]);
      attr(div1, "class", "wrapToggle svelte-1907s6a");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(div0, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 12) {
        toggle_class(div0, "is-enabled", ctx[3][ctx[0].deviceVaultName + "---" + ctx[0].manifest.id + "---setting"]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block(ctx) {
  let t3;
  return {
    c() {
      t3 = text("-");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_1(ctx) {
  let tr0;
  let td0;
  let t0_value = ctx[0].manifest.name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[0].versionInfo + "";
  let t22;
  let t3_value = getDispString(ctx[0].versionFlag) + "";
  let t3;
  let t4;
  let td2;
  let t5;
  let tr1;
  let td3;
  let t7;
  let td4;
  let t8_value = ctx[0].mtimeInfo + "";
  let t8;
  let t9_value = getDispString(ctx[0].mtimeFlag) + "";
  let t9;
  let t10;
  let td5;
  let t11;
  let tr2;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].versionFlag === "EVEN" || ctx2[0].versionFlag === "")
      return create_if_block_1;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].mtimeFlag === "EVEN" || ctx2[0].mtimeFlag === "")
      return create_if_block;
    return create_else_block;
  }
  let current_block_type_1 = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type_1(ctx);
  return {
    c() {
      tr0 = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t22 = text(t2_value);
      t3 = text(t3_value);
      t4 = space();
      td2 = element("td");
      if_block0.c();
      t5 = space();
      tr1 = element("tr");
      td3 = element("td");
      td3.textContent = "Settings";
      t7 = space();
      td4 = element("td");
      t8 = text(t8_value);
      t9 = text(t9_value);
      t10 = space();
      td5 = element("td");
      if_block1.c();
      t11 = space();
      tr2 = element("tr");
      tr2.innerHTML = `<th colspan="3"></th> 
                    `;
      attr(td0, "class", "sls-table-head");
      attr(td1, "class", "sls-table-tail tcenter");
      attr(td2, "class", "sls-table-tail tcenter");
      attr(td3, "class", "sls-table-head");
      attr(td4, "class", "sls-table-tail tcenter");
      attr(td5, "class", "sls-table-tail tcenter");
      attr(tr2, "class", "divider");
    },
    m(target, anchor) {
      insert(target, tr0, anchor);
      append(tr0, td0);
      append(td0, t0);
      append(tr0, t1);
      append(tr0, td1);
      append(td1, t22);
      append(td1, t3);
      append(tr0, t4);
      append(tr0, td2);
      if_block0.m(td2, null);
      insert(target, t5, anchor);
      insert(target, tr1, anchor);
      append(tr1, td3);
      append(tr1, t7);
      append(tr1, td4);
      append(td4, t8);
      append(td4, t9);
      append(tr1, t10);
      append(tr1, td5);
      if_block1.m(td5, null);
      insert(target, t11, anchor);
      insert(target, tr2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[0].manifest.name + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && t2_value !== (t2_value = ctx2[0].versionInfo + ""))
        set_data(t22, t2_value);
      if (dirty & 4 && t3_value !== (t3_value = getDispString(ctx2[0].versionFlag) + ""))
        set_data(t3, t3_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(td2, null);
        }
      }
      if (dirty & 4 && t8_value !== (t8_value = ctx2[0].mtimeInfo + ""))
        set_data(t8, t8_value);
      if (dirty & 4 && t9_value !== (t9_value = getDispString(ctx2[0].mtimeFlag) + ""))
        set_data(t9, t9_value);
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(td5, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr0);
      if_block0.d();
      if (detaching)
        detach(t5);
      if (detaching)
        detach(tr1);
      if_block1.d();
      if (detaching)
        detach(t11);
      if (detaching)
        detach(tr2);
    }
  };
}
function create_each_block(ctx) {
  let tr;
  let th0;
  let t0_value = ctx[25] + "";
  let t0;
  let t1;
  let th1;
  let button;
  let t3;
  let each_1_anchor;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[19](ctx[25]);
  }
  let each_value_1 = ctx[26];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      tr = element("tr");
      th0 = element("th");
      t0 = text(t0_value);
      t1 = space();
      th1 = element("th");
      button = element("button");
      button.textContent = "\u2714";
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      attr(th0, "colspan", "2");
      attr(th0, "class", "sls-plugins-tbl-device-head");
      attr(button, "class", "mod-cta");
      attr(th1, "class", "sls-plugins-tbl-device-head");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, th0);
      append(th0, t0);
      append(tr, t1);
      append(tr, th1);
      append(th1, button);
      insert(target, t3, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t0_value !== (t0_value = ctx[25] + ""))
        set_data(t0, t0_value);
      if (dirty & 76) {
        each_value_1 = ctx[26];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div5;
  let h1;
  let t1;
  let div1;
  let t22;
  let div0;
  let t3;
  let div2;
  let table;
  let tr;
  let t9;
  let t10;
  let t11;
  let div3;
  let button0;
  let t13;
  let button1;
  let t15;
  let div4;
  let button2;
  let t17;
  let button3;
  let t19;
  let button4;
  let mounted;
  let dispose;
  let if_block = ctx[2].length == 0 && create_if_block_2(ctx);
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div5 = element("div");
      h1 = element("h1");
      h1.textContent = "Plugins and their settings";
      t1 = space();
      div1 = element("div");
      t22 = text("Show own items\r\n        ");
      div0 = element("div");
      t3 = space();
      div2 = element("div");
      table = element("table");
      tr = element("tr");
      tr.innerHTML = `<th class="sls-plugins-tbl-device-head">Name</th> 
                <th class="sls-plugins-tbl-device-head">Info</th> 
                <th class="sls-plugins-tbl-device-head">Target</th>`;
      t9 = space();
      if (if_block)
        if_block.c();
      t10 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t11 = space();
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Replicate and refresh";
      t13 = space();
      button1 = element("button");
      button1.textContent = "Clear Selection";
      t15 = space();
      div4 = element("div");
      button2 = element("button");
      button2.textContent = "Check Updates";
      t17 = space();
      button3 = element("button");
      button3.textContent = "Sweep installed";
      t19 = space();
      button4 = element("button");
      button4.textContent = "Apply all";
      attr(div0, "class", "checkbox-container");
      toggle_class(div0, "is-enabled", ctx[1]);
      attr(div1, "class", "ols-plugins-div-buttons svelte-1907s6a");
      set_style(tr, "position", "sticky");
      attr(table, "class", "sls-plugins-tbl");
      attr(div2, "class", "sls-plugins-wrap");
      attr(button0, "class", "");
      attr(button1, "class", "");
      attr(div3, "class", "ols-plugins-div-buttons svelte-1907s6a");
      attr(button2, "class", "mod-cta");
      attr(button3, "class", "mod-cta");
      attr(button4, "class", "mod-cta");
      attr(div4, "class", "ols-plugins-div-buttons svelte-1907s6a");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, h1);
      append(div5, t1);
      append(div5, div1);
      append(div1, t22);
      append(div1, div0);
      append(div5, t3);
      append(div5, div2);
      append(div2, table);
      append(table, tr);
      append(table, t9);
      if (if_block)
        if_block.m(table, null);
      append(table, t10);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      append(div5, t11);
      append(div5, div3);
      append(div3, button0);
      append(div3, t13);
      append(div3, button1);
      append(div5, t15);
      append(div5, div4);
      append(div4, button2);
      append(div4, t17);
      append(div4, button3);
      append(div4, t19);
      append(div4, button4);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[5]),
          listen(button0, "click", ctx[11]),
          listen(button1, "click", ctx[4]),
          listen(button2, "click", ctx[10]),
          listen(button3, "click", ctx[8]),
          listen(button4, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        toggle_class(div0, "is-enabled", ctx2[1]);
      }
      if (ctx2[2].length == 0) {
        if (if_block) {
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          if_block.m(table, t10);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 204) {
        each_value = ctx2[2];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function getDispString(stat) {
  if (stat == "")
    return "";
  if (stat == "NEWER")
    return " (Newer)";
  if (stat == "OLDER")
    return " (Older)";
  if (stat == "EVEN")
    return " (Even)";
  if (stat == "EVEN_BUT_DIFFERENT")
    return " (Even but different)";
  if (stat == "REMOTE_ONLY")
    return " (Remote Only)";
  return "";
}
function instance($$self, $$props, $$invalidate) {
  var _a, _b, _c, _d;
  let { plugin } = $$props;
  let plugins = [];
  let deviceAndPlugins = {};
  let devicePluginList = [];
  let ownPlugins = null;
  let showOwnPlugins = false;
  let targetList = {};
  function saveTargetList() {
    window.localStorage.setItem("ols-plugin-targetlist", JSON.stringify(targetList));
  }
  function loadTargetList() {
    let e3 = window.localStorage.getItem("ols-plugin-targetlist") || "{}";
    try {
      $$invalidate(3, targetList = JSON.parse(e3));
    } catch (_) {
    }
  }
  function clearSelection() {
    $$invalidate(3, targetList = {});
  }
  function updateList() {
    return __awaiter(this, void 0, void 0, function* () {
      let x = yield plugin.getPluginList();
      $$invalidate(18, ownPlugins = x.thisDevicePlugins);
      $$invalidate(16, plugins = Object.values(x.allPlugins));
      let targetListItems = Array.from(new Set(plugins.map((e3) => e3.deviceVaultName + "---" + e3.manifest.id)));
      let newTargetList = {};
      for (const id of targetListItems) {
        for (const tag of ["---plugin", "---setting"]) {
          newTargetList[id + tag] = id + tag in targetList && targetList[id + tag];
        }
      }
      $$invalidate(3, targetList = newTargetList);
      saveTargetList();
    });
  }
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    loadTargetList();
    yield updateList();
  }));
  function toggleShowOwnPlugins() {
    $$invalidate(1, showOwnPlugins = !showOwnPlugins);
  }
  function toggleTarget(key) {
    $$invalidate(3, targetList[key] = !targetList[key], targetList);
    saveTargetList();
  }
  function toggleAll(devicename) {
    for (const c in targetList) {
      if (c.startsWith(devicename)) {
        $$invalidate(3, targetList[c] = true, targetList);
      }
    }
  }
  function sweepPlugins() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.app.plugins.loadManifests();
      yield plugin.sweepPlugin(true);
      updateList();
    });
  }
  function applyPlugins() {
    return __awaiter(this, void 0, void 0, function* () {
      for (const c in targetList) {
        if (targetList[c] == true) {
          const [deviceAndVault, id, opt] = c.split("---");
          if (deviceAndVault in deviceAndPlugins) {
            const entry = deviceAndPlugins[deviceAndVault].find((e3) => e3.manifest.id == id);
            if (entry) {
              if (opt == "plugin") {
                if (entry.versionFlag != "EVEN")
                  yield plugin.applyPlugin(entry);
              } else if (opt == "setting") {
                if (entry.mtimeFlag != "EVEN")
                  yield plugin.applyPluginData(entry);
              }
            }
          }
        }
      }
      yield plugin.app.plugins.loadManifests();
      yield plugin.sweepPlugin(true);
      updateList();
    });
  }
  function checkUpdates() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.checkPluginUpdate();
    });
  }
  function replicateAndRefresh() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.replicate(true);
      updateList();
    });
  }
  const click_handler = (deviceName) => toggleAll(deviceName);
  const click_handler_1 = (plugin2) => toggleTarget(plugin2.deviceVaultName + "---" + plugin2.manifest.id + "---plugin");
  const click_handler_2 = (plugin2) => toggleTarget(plugin2.deviceVaultName + "---" + plugin2.manifest.id + "---setting");
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 520195) {
      $: {
        $$invalidate(17, deviceAndPlugins = {});
        for (const p of plugins) {
          if (p.deviceVaultName == plugin.deviceAndVaultName && !showOwnPlugins) {
            continue;
          }
          if (!(p.deviceVaultName in deviceAndPlugins)) {
            $$invalidate(17, deviceAndPlugins[p.deviceVaultName] = [], deviceAndPlugins);
          }
          let dispInfo = Object.assign(Object.assign({}, p), {
            versionInfo: "",
            mtimeInfo: "",
            versionFlag: "",
            mtimeFlag: ""
          });
          dispInfo.versionInfo = p.manifest.version;
          let x = new Date().getTime() / 1e3;
          let mtime = p.mtime / 1e3;
          let diff = (x - mtime) / 60;
          if (p.mtime == 0) {
            dispInfo.mtimeInfo = `-`;
          } else if (diff < 60) {
            dispInfo.mtimeInfo = `${diff | 0} Mins ago`;
          } else if (diff < 60 * 24) {
            dispInfo.mtimeInfo = `${diff / 60 | 0} Hours ago`;
          } else if (diff < 60 * 24 * 10) {
            dispInfo.mtimeInfo = `${diff / (60 * 24) | 0} Days ago`;
          } else {
            dispInfo.mtimeInfo = new Date(dispInfo.mtime).toLocaleString();
          }
          let id = p.manifest.id;
          if (id in ownPlugins) {
            const ownPlugin = ownPlugins[id];
            let localVer = versionNumberString2Number(ownPlugin.manifest.version);
            let pluginVer = versionNumberString2Number(p.manifest.version);
            if (localVer > pluginVer) {
              dispInfo.versionFlag = "OLDER";
            } else if (localVer == pluginVer) {
              if (ownPlugin.manifestJson + ($$invalidate(12, _a = ownPlugin.styleCss) !== null && _a !== void 0 ? _a : "") + ownPlugin.mainJs != p.manifestJson + ($$invalidate(13, _b = p.styleCss) !== null && _b !== void 0 ? _b : "") + p.mainJs) {
                dispInfo.versionFlag = "EVEN_BUT_DIFFERENT";
              } else {
                dispInfo.versionFlag = "EVEN";
              }
            } else if (localVer < pluginVer) {
              dispInfo.versionFlag = "NEWER";
            }
            if (($$invalidate(14, _c = ownPlugin.dataJson) !== null && _c !== void 0 ? _c : "") == ($$invalidate(15, _d = p.dataJson) !== null && _d !== void 0 ? _d : "")) {
              if (ownPlugin.mtime == 0 && p.mtime == 0) {
                dispInfo.mtimeFlag = "";
              } else {
                dispInfo.mtimeFlag = "EVEN";
              }
            } else {
              if ((ownPlugin.mtime / 1e3 | 0) > (p.mtime / 1e3 | 0)) {
                dispInfo.mtimeFlag = "OLDER";
              } else if ((ownPlugin.mtime / 1e3 | 0) == (p.mtime / 1e3 | 0)) {
                dispInfo.mtimeFlag = "EVEN_BUT_DIFFERENT";
              } else if ((ownPlugin.mtime / 1e3 | 0) < (p.mtime / 1e3 | 0)) {
                dispInfo.mtimeFlag = "NEWER";
              }
            }
          } else {
            dispInfo.versionFlag = "REMOTE_ONLY";
            dispInfo.mtimeFlag = "REMOTE_ONLY";
          }
          deviceAndPlugins[p.deviceVaultName].push(dispInfo);
        }
        $$invalidate(2, devicePluginList = Object.entries(deviceAndPlugins));
      }
    }
  };
  return [
    plugin,
    showOwnPlugins,
    devicePluginList,
    targetList,
    clearSelection,
    toggleShowOwnPlugins,
    toggleTarget,
    toggleAll,
    sweepPlugins,
    applyPlugins,
    checkUpdates,
    replicateAndRefresh,
    _a,
    _b,
    _c,
    _d,
    plugins,
    deviceAndPlugins,
    ownPlugins,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var PluginPane = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { plugin: 0 }, add_css);
  }
};
var PluginPane_default = PluginPane;

// src/main.ts
var PluginDialogModal = class extends import_obsidian7.Modal {
  constructor(app, plugin) {
    super(app);
    this.component = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    if (this.component == null) {
      this.component = new PluginPane_default({
        target: contentEl,
        props: { plugin: this.plugin }
      });
    }
  }
  onClose() {
    if (this.component != null) {
      this.component.$destroy();
      this.component = null;
    }
  }
};
var ObsidianLiveSyncPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.logMessage = [];
    this.pluginDialog = null;
    this.gcTimerHandler = null;
    this.batchFileChange = [];
    this.addLogHook = null;
    this.notifies = {};
    this.periodicSyncHandler = null;
    this.periodicPluginSweepHandler = null;
    this.lastMessage = "";
    this.conflictedCheckFiles = [];
  }
  setInterval(handler, timeout) {
    const timer = window.setInterval(handler, timeout);
    this.registerInterval(timer);
    return timer;
  }
  isRedFlagRaised() {
    const redflag = this.app.vault.getAbstractFileByPath((0, import_obsidian7.normalizePath)(FLAGMD_REDFLAG));
    if (redflag != null) {
      return true;
    }
    return false;
  }
  showHistory(file) {
    if (!this.settings.useHistory) {
      Logger("You have to enable Use History in misc.", LOG_LEVEL.NOTICE);
    } else {
      new DocumentHistoryModal(this.app, this, file).open();
    }
  }
  onload() {
    return __async(this, null, function* () {
      setLogger(this.addLog.bind(this));
      Logger("loading plugin");
      const lsname = "obsidian-live-sync-ver" + this.app.vault.getName();
      const last_version = localStorage.getItem(lsname);
      yield this.loadSettings();
      if (last_version && Number(last_version) < VER) {
        this.settings.liveSync = false;
        this.settings.syncOnSave = false;
        this.settings.syncOnStart = false;
        this.settings.syncOnFileOpen = false;
        this.settings.periodicReplication = false;
        this.settings.versionUpFlash = "I changed specifications incompatiblly, so when you enable sync again, be sure to made version up all nother devides.";
        this.saveSettings();
      }
      localStorage.setItem(lsname, `${VER}`);
      yield this.openDatabase();
      (0, import_obsidian7.addIcon)("replicate", `<g transform="matrix(1.15 0 0 1.15 -8.31 -9.52)" fill="currentColor" fill-rule="evenodd">
            <path d="m85 22.2c-0.799-4.74-4.99-8.37-9.88-8.37-0.499 0-1.1 0.101-1.6 0.101-2.4-3.03-6.09-4.94-10.3-4.94-6.09 0-11.2 4.14-12.8 9.79-5.59 1.11-9.78 6.05-9.78 12 0 6.76 5.39 12.2 12 12.2h29.9c5.79 0 10.1-4.74 10.1-10.6 0-4.84-3.29-8.88-7.68-10.2zm-2.99 14.7h-29.5c-2.3-0.202-4.29-1.51-5.29-3.53-0.899-2.12-0.699-4.54 0.698-6.46 1.2-1.61 2.99-2.52 4.89-2.52 0.299 0 0.698 0 0.998 0.101l1.8 0.303v-2.02c0-3.63 2.4-6.76 5.89-7.57 0.599-0.101 1.2-0.202 1.8-0.202 2.89 0 5.49 1.62 6.79 4.24l0.598 1.21 1.3-0.504c0.599-0.202 1.3-0.303 2-0.303 1.3 0 2.5 0.404 3.59 1.11 1.6 1.21 2.6 3.13 2.6 5.15v1.61h2c2.6 0 4.69 2.12 4.69 4.74-0.099 2.52-2.2 4.64-4.79 4.64z"/>
            <path d="m53.2 49.2h-41.6c-1.8 0-3.2 1.4-3.2 3.2v28.6c0 1.8 1.4 3.2 3.2 3.2h15.8v4h-7v6h24v-6h-7v-4h15.8c1.8 0 3.2-1.4 3.2-3.2v-28.6c0-1.8-1.4-3.2-3.2-3.2zm-2.8 29h-36v-23h36z"/>
            <path d="m73 49.2c1.02 1.29 1.53 2.97 1.53 4.56 0 2.97-1.74 5.65-4.39 7.04v-4.06l-7.46 7.33 7.46 7.14v-4.06c7.66-1.98 12.2-9.61 10-17-0.102-0.297-0.205-0.595-0.307-0.892z"/>
            <path d="m24.1 43c-0.817-0.991-1.53-2.97-1.53-4.56 0-2.97 1.74-5.65 4.39-7.04v4.06l7.46-7.33-7.46-7.14v4.06c-7.66 1.98-12.2 9.61-10 17 0.102 0.297 0.205 0.595 0.307 0.892z"/>
           </g>`);
      (0, import_obsidian7.addIcon)("view-log", `<g transform="matrix(1.28 0 0 1.28 -131 -411)" fill="currentColor" fill-rule="evenodd">
        <path d="m103 330h76v12h-76z"/>
        <path d="m106 346v44h70v-44zm45 16h-20v-8h20z"/>
       </g>`);
      this.addRibbonIcon("replicate", "Replicate", () => __async(this, null, function* () {
        yield this.replicate(true);
      }));
      this.addRibbonIcon("view-log", "Show log", () => {
        new LogDisplayModal(this.app, this).open();
      });
      this.statusBar = this.addStatusBarItem();
      this.statusBar.addClass("syncstatusbar");
      this.refreshStatusText = this.refreshStatusText.bind(this);
      this.statusBar2 = this.addStatusBarItem();
      this.watchVaultChange = this.watchVaultChange.bind(this);
      this.watchVaultCreate = this.watchVaultCreate.bind(this);
      this.watchVaultDelete = this.watchVaultDelete.bind(this);
      this.watchVaultRename = this.watchVaultRename.bind(this);
      this.watchWorkspaceOpen = (0, import_obsidian7.debounce)(this.watchWorkspaceOpen.bind(this), 1e3, false);
      this.watchWindowVisiblity = (0, import_obsidian7.debounce)(this.watchWindowVisiblity.bind(this), 1e3, false);
      this.parseReplicationResult = this.parseReplicationResult.bind(this);
      this.periodicSync = this.periodicSync.bind(this);
      this.setPeriodicSync = this.setPeriodicSync.bind(this);
      this.getPluginList = this.getPluginList.bind(this);
      this.addSettingTab(new ObsidianLiveSyncSettingTab(this.app, this));
      this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
        try {
          if (this.isRedFlagRaised()) {
            this.settings.batchSave = false;
            this.settings.liveSync = false;
            this.settings.periodicReplication = false;
            this.settings.syncOnSave = false;
            this.settings.syncOnStart = false;
            this.settings.syncOnFileOpen = false;
            this.settings.autoSweepPlugins = false;
            this.settings.usePluginSync = false;
            this.settings.suspendFileWatching = true;
            yield this.saveSettings();
            yield this.openDatabase();
            const warningMessage = "The red flag is raised! The whole initialize steps are skipped, and any file changes are not captured.";
            Logger(warningMessage, LOG_LEVEL.NOTICE);
            this.setStatusBarText(warningMessage);
          } else {
            if (this.settings.suspendFileWatching) {
              Logger("'Suspend file watching' turned on. Are you sure this is what you intended? Every modification on the vault will be ignored.", LOG_LEVEL.NOTICE);
            }
            yield this.initializeDatabase();
          }
          yield this.realizeSettingSyncMode();
          this.registerWatchEvents();
          if (this.settings.syncOnStart) {
            yield this.localDatabase.openReplication(this.settings, false, false, this.parseReplicationResult);
          }
        } catch (ex) {
          Logger("Error while loading Self-hosted LiveSync", LOG_LEVEL.NOTICE);
          Logger(ex, LOG_LEVEL.VERBOSE);
        }
      }));
      this.addCommand({
        id: "livesync-replicate",
        name: "Replicate now",
        callback: () => {
          this.replicate();
        }
      });
      this.addCommand({
        id: "livesync-dump",
        name: "Dump informations of this doc ",
        editorCallback: (editor, view) => {
          this.localDatabase.disposeHashCache();
          this.localDatabase.getDBEntry(view.file.path, {}, true, false);
        }
      });
      this.addCommand({
        id: "livesync-checkdoc-conflicted",
        name: "Resolve if conflicted.",
        editorCallback: (editor, view) => __async(this, null, function* () {
          yield this.showIfConflicted(view.file);
        })
      });
      this.addCommand({
        id: "livesync-gc",
        name: "garbage collect now",
        callback: () => {
          this.garbageCollect();
        }
      });
      this.addCommand({
        id: "livesync-toggle",
        name: "Toggle LiveSync",
        callback: () => __async(this, null, function* () {
          if (this.settings.liveSync) {
            this.settings.liveSync = false;
            Logger("LiveSync Disabled.", LOG_LEVEL.NOTICE);
          } else {
            this.settings.liveSync = true;
            Logger("LiveSync Enabled.", LOG_LEVEL.NOTICE);
          }
          yield this.realizeSettingSyncMode();
          this.saveSettings();
        })
      });
      this.addCommand({
        id: "livesync-suspendall",
        name: "Toggle All Sync.",
        callback: () => __async(this, null, function* () {
          if (this.suspended) {
            this.suspended = false;
            Logger("Self-hosted LiveSync resumed", LOG_LEVEL.NOTICE);
          } else {
            this.suspended = true;
            Logger("Self-hosted LiveSync suspended", LOG_LEVEL.NOTICE);
          }
          yield this.realizeSettingSyncMode();
          this.saveSettings();
        })
      });
      this.addCommand({
        id: "livesync-history",
        name: "Show history",
        editorCallback: (editor, view) => {
          this.showHistory(view.file);
        }
      });
      this.triggerRealizeSettingSyncMode = (0, import_obsidian7.debounce)(this.triggerRealizeSettingSyncMode.bind(this), 1e3);
      this.triggerCheckPluginUpdate = (0, import_obsidian7.debounce)(this.triggerCheckPluginUpdate.bind(this), 3e3);
      setLockNotifier(() => {
        this.refreshStatusText();
      });
      this.addCommand({
        id: "livesync-plugin-dialog",
        name: "Show Plugins and their settings",
        callback: () => {
          this.showPluginSyncModal();
        }
      });
    });
  }
  showPluginSyncModal() {
    if (this.pluginDialog != null) {
      this.pluginDialog.open();
    } else {
      this.pluginDialog = new PluginDialogModal(this.app, this);
      this.pluginDialog.open();
    }
  }
  hidePluginSyncModal() {
    if (this.pluginDialog != null) {
      this.pluginDialog.close();
      this.pluginDialog = null;
    }
  }
  onunload() {
    this.hidePluginSyncModal();
    this.localDatabase.onunload();
    if (this.gcTimerHandler != null) {
      clearTimeout(this.gcTimerHandler);
      this.gcTimerHandler = null;
    }
    this.clearPeriodicSync();
    this.clearPluginSweep();
    this.localDatabase.closeReplication();
    this.localDatabase.close();
    window.removeEventListener("visibilitychange", this.watchWindowVisiblity);
    Logger("unloading plugin");
  }
  openDatabase() {
    return __async(this, null, function* () {
      if (this.localDatabase != null) {
        this.localDatabase.close();
      }
      const vaultName = this.app.vault.getName();
      Logger("Open Database...");
      this.localDatabase = new LocalPouchDB(this.settings, vaultName);
      this.localDatabase.updateInfo = () => {
        this.refreshStatusText();
      };
      yield this.localDatabase.initializeDatabase();
    });
  }
  garbageCollect() {
    return __async(this, null, function* () {
      yield this.localDatabase.garbageCollect();
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      this.settings.workingEncrypt = this.settings.encrypt;
      this.settings.workingPassphrase = this.settings.passphrase;
      const lsname = "obsidian-live-sync-vaultanddevicename-" + this.app.vault.getName();
      if (this.settings.deviceAndVaultName != "") {
        if (!localStorage.getItem(lsname)) {
          this.deviceAndVaultName = this.settings.deviceAndVaultName;
          localStorage.setItem(lsname, this.deviceAndVaultName);
          this.settings.deviceAndVaultName = "";
        }
      }
      this.deviceAndVaultName = localStorage.getItem(lsname) || "";
    });
  }
  triggerRealizeSettingSyncMode() {
    (() => __async(this, null, function* () {
      return yield this.realizeSettingSyncMode();
    }))();
  }
  saveSettings() {
    return __async(this, null, function* () {
      const lsname = "obsidian-live-sync-vaultanddevicename-" + this.app.vault.getName();
      localStorage.setItem(lsname, this.deviceAndVaultName || "");
      yield this.saveData(this.settings);
      this.localDatabase.settings = this.settings;
      this.triggerRealizeSettingSyncMode();
    });
  }
  gcHook() {
    if (this.settings.gcDelay == 0)
      return;
    if (this.settings.useHistory)
      return;
    const GC_DELAY = this.settings.gcDelay * 1e3;
    if (this.gcTimerHandler != null) {
      clearTimeout(this.gcTimerHandler);
      this.gcTimerHandler = null;
    }
    this.gcTimerHandler = setTimeout(() => {
      this.gcTimerHandler = null;
      this.garbageCollect();
    }, GC_DELAY);
  }
  registerWatchEvents() {
    this.registerEvent(this.app.vault.on("modify", this.watchVaultChange));
    this.registerEvent(this.app.vault.on("delete", this.watchVaultDelete));
    this.registerEvent(this.app.vault.on("rename", this.watchVaultRename));
    this.registerEvent(this.app.vault.on("create", this.watchVaultChange));
    this.registerEvent(this.app.workspace.on("file-open", this.watchWorkspaceOpen));
    window.addEventListener("visibilitychange", this.watchWindowVisiblity);
  }
  watchWindowVisiblity() {
    this.watchWindowVisiblityAsync();
  }
  watchWindowVisiblityAsync() {
    return __async(this, null, function* () {
      if (this.settings.suspendFileWatching)
        return;
      const isHidden = document.hidden;
      yield this.applyBatchChange();
      if (isHidden) {
        this.localDatabase.closeReplication();
        this.clearPeriodicSync();
      } else {
        if (this.suspended)
          return;
        if (this.settings.autoSweepPlugins) {
          yield this.sweepPlugin(false);
        }
        if (this.settings.liveSync) {
          yield this.localDatabase.openReplication(this.settings, true, false, this.parseReplicationResult);
        }
        if (this.settings.syncOnStart) {
          yield this.localDatabase.openReplication(this.settings, false, false, this.parseReplicationResult);
        }
        if (this.settings.periodicReplication) {
          this.setPeriodicSync();
        }
      }
      this.gcHook();
    });
  }
  watchWorkspaceOpen(file) {
    if (this.settings.suspendFileWatching)
      return;
    this.watchWorkspaceOpenAsync(file);
  }
  watchWorkspaceOpenAsync(file) {
    return __async(this, null, function* () {
      yield this.applyBatchChange();
      if (file == null)
        return;
      if (this.settings.syncOnFileOpen && !this.suspended) {
        yield this.replicate();
      }
      this.localDatabase.disposeHashCache();
      yield this.showIfConflicted(file);
      this.gcHook();
    });
  }
  watchVaultCreate(file, ...args) {
    if (this.settings.suspendFileWatching)
      return;
    this.watchVaultChangeAsync(file, ...args);
  }
  watchVaultChange(file, ...args) {
    if (!(file instanceof import_obsidian7.TFile)) {
      return;
    }
    if (this.settings.suspendFileWatching)
      return;
    if (this.settings.batchSave) {
      this.batchFileChange = Array.from(new Set([...this.batchFileChange, file.path]));
      this.refreshStatusText();
      return;
    }
    this.watchVaultChangeAsync(file, ...args);
  }
  applyBatchChange() {
    return __async(this, null, function* () {
      if (!this.settings.batchSave || this.batchFileChange.length == 0) {
        return [];
      }
      return yield runWithLock("batchSave", false, () => __async(this, null, function* () {
        const batchItems = JSON.parse(JSON.stringify(this.batchFileChange));
        this.batchFileChange = [];
        const promises = batchItems.map((e3) => __async(this, null, function* () {
          try {
            const f = this.app.vault.getAbstractFileByPath((0, import_obsidian7.normalizePath)(e3));
            if (f && f instanceof import_obsidian7.TFile) {
              yield this.updateIntoDB(f);
              Logger(`Batch save:${e3}`);
            }
          } catch (ex) {
            Logger(`Batch save error:${e3}`, LOG_LEVEL.NOTICE);
            Logger(ex, LOG_LEVEL.VERBOSE);
          }
        }));
        this.refreshStatusText();
        return yield Promise.all(promises);
      }));
    });
  }
  watchVaultChangeAsync(file, ...args) {
    return __async(this, null, function* () {
      if (file instanceof import_obsidian7.TFile) {
        yield this.updateIntoDB(file);
        this.gcHook();
      }
    });
  }
  watchVaultDelete(file) {
    this.batchFileChange = this.batchFileChange.filter((e3) => e3 == file.path);
    if (this.settings.suspendFileWatching)
      return;
    this.watchVaultDeleteAsync(file).then(() => {
    });
  }
  watchVaultDeleteAsync(file) {
    return __async(this, null, function* () {
      if (file instanceof import_obsidian7.TFile) {
        yield this.deleteFromDB(file);
      } else if (file instanceof import_obsidian7.TFolder) {
        yield this.deleteFolderOnDB(file);
      }
      this.gcHook();
    });
  }
  GetAllFilesRecursively(file) {
    if (file instanceof import_obsidian7.TFile) {
      return [file];
    } else if (file instanceof import_obsidian7.TFolder) {
      const result = [];
      for (const v of file.children) {
        result.push(...this.GetAllFilesRecursively(v));
      }
      return result;
    } else {
      Logger(`Filetype error:${file.path}`, LOG_LEVEL.NOTICE);
      throw new Error(`Filetype error:${file.path}`);
    }
  }
  watchVaultRename(file, oldFile) {
    if (this.settings.suspendFileWatching)
      return;
    this.watchVaultRenameAsync(file, oldFile).then(() => {
    });
  }
  getFilePath(file) {
    if (file instanceof import_obsidian7.TFolder) {
      if (file.isRoot())
        return "";
      return this.getFilePath(file.parent) + "/" + file.name;
    }
    if (file instanceof import_obsidian7.TFile) {
      return this.getFilePath(file.parent) + "/" + file.name;
    }
    return this.getFilePath(file.parent) + "/" + file.name;
  }
  watchVaultRenameAsync(file, oldFile) {
    return __async(this, null, function* () {
      Logger(`${oldFile} renamed to ${file.path}`, LOG_LEVEL.VERBOSE);
      try {
        yield this.applyBatchChange();
      } catch (ex) {
        Logger(ex);
      }
      if (file instanceof import_obsidian7.TFolder) {
        const newFiles = this.GetAllFilesRecursively(file);
        for (const i of newFiles) {
          try {
            const newFilePath = (0, import_obsidian7.normalizePath)(this.getFilePath(i));
            const newFile = this.app.vault.getAbstractFileByPath(newFilePath);
            if (newFile instanceof import_obsidian7.TFile) {
              Logger(`save ${newFile.path} into db`);
              yield this.updateIntoDB(newFile);
            }
          } catch (ex) {
            Logger(ex);
          }
        }
        Logger(`delete below ${oldFile} from db`);
        yield this.deleteFromDBbyPath(oldFile);
      } else if (file instanceof import_obsidian7.TFile) {
        try {
          Logger(`file save ${file.path} into db`);
          yield this.updateIntoDB(file);
          Logger(`deleted ${oldFile} into db`);
          yield this.deleteFromDBbyPath(oldFile);
        } catch (ex) {
          Logger(ex);
        }
      }
      this.gcHook();
    });
  }
  addLog(_0) {
    return __async(this, arguments, function* (message, level = LOG_LEVEL.INFO) {
      if (level < LOG_LEVEL.INFO && this.settings && this.settings.lessInformationInLog) {
        return;
      }
      if (this.settings && !this.settings.showVerboseLog && level == LOG_LEVEL.VERBOSE) {
        return;
      }
      const valutName = this.app.vault.getName();
      const timestamp = new Date().toLocaleString();
      const messagecontent = typeof message == "string" ? message : message instanceof Error ? `${message.name}:${message.message}` : JSON.stringify(message, null, 2);
      const newmessage = timestamp + "->" + messagecontent;
      this.logMessage = [].concat(this.logMessage).concat([newmessage]).slice(-100);
      console.log(valutName + ":" + newmessage);
      if (level >= LOG_LEVEL.NOTICE) {
        if (messagecontent in this.notifies) {
          clearTimeout(this.notifies[messagecontent].timer);
          this.notifies[messagecontent].count++;
          this.notifies[messagecontent].notice.setMessage(`(${this.notifies[messagecontent].count}):${messagecontent}`);
          this.notifies[messagecontent].timer = setTimeout(() => {
            const notify = this.notifies[messagecontent].notice;
            delete this.notifies[messagecontent];
            try {
              notify.hide();
            } catch (ex) {
            }
          }, 5e3);
        } else {
          const notify = new import_obsidian7.Notice(messagecontent, 0);
          this.notifies[messagecontent] = {
            count: 0,
            notice: notify,
            timer: setTimeout(() => {
              delete this.notifies[messagecontent];
              notify.hide();
            }, 5e3)
          };
        }
      }
      if (this.addLogHook != null)
        this.addLogHook();
    });
  }
  ensureDirectory(fullpath) {
    return __async(this, null, function* () {
      const pathElements = fullpath.split("/");
      pathElements.pop();
      let c = "";
      for (const v of pathElements) {
        c += v;
        try {
          yield this.app.vault.createFolder(c);
        } catch (ex) {
          if (ex.message && ex.message == "Folder already exists.") {
          } else {
            Logger("Folder Create Error");
            Logger(ex);
          }
        }
        c += "/";
      }
    });
  }
  doc2storage_create(docEntry, force) {
    return __async(this, null, function* () {
      const pathSrc = id2path(docEntry._id);
      if (shouldBeIgnored(pathSrc)) {
        return;
      }
      const doc = yield this.localDatabase.getDBEntry(pathSrc, { rev: docEntry._rev });
      if (doc === false)
        return;
      const path = id2path(doc._id);
      if (doc.datatype == "newnote") {
        const bin = base64ToArrayBuffer(doc.data);
        if (bin != null) {
          if (!isValidPath(path)) {
            Logger(`The file that having platform dependent name has been arrived. This file has skipped: ${path}`, LOG_LEVEL.NOTICE);
            return;
          }
          yield this.ensureDirectory(path);
          try {
            const newfile = yield this.app.vault.createBinary((0, import_obsidian7.normalizePath)(path), bin, {
              ctime: doc.ctime,
              mtime: doc.mtime
            });
            Logger("live : write to local (newfile:b) " + path);
            this.app.vault.trigger("create", newfile);
          } catch (ex) {
            Logger("could not write to local (newfile:bin) " + path, LOG_LEVEL.NOTICE);
            Logger(ex, LOG_LEVEL.VERBOSE);
          }
        }
      } else if (doc.datatype == "plain") {
        if (!isValidPath(path)) {
          Logger(`The file that having platform dependent name has been arrived. This file has skipped: ${path}`, LOG_LEVEL.NOTICE);
          return;
        }
        yield this.ensureDirectory(path);
        try {
          const newfile = yield this.app.vault.create((0, import_obsidian7.normalizePath)(path), doc.data, {
            ctime: doc.ctime,
            mtime: doc.mtime
          });
          Logger("live : write to local (newfile:p) " + path);
          this.app.vault.trigger("create", newfile);
        } catch (ex) {
          Logger("could not write to local (newfile:plain) " + path, LOG_LEVEL.NOTICE);
          Logger(ex, LOG_LEVEL.VERBOSE);
        }
      } else {
        Logger("live : New data imcoming, but we cound't parse that." + doc.datatype, LOG_LEVEL.NOTICE);
      }
    });
  }
  deleteVaultItem(file) {
    return __async(this, null, function* () {
      const dir = file.parent;
      if (this.settings.trashInsteadDelete) {
        yield this.app.vault.trash(file, false);
      } else {
        yield this.app.vault.delete(file);
      }
      Logger(`deleted:${file.path}`);
      Logger(`other items:${dir.children.length}`);
      if (dir.children.length == 0) {
        if (!this.settings.doNotDeleteFolder) {
          Logger(`all files deleted by replication, so delete dir`);
          yield this.deleteVaultItem(dir);
        }
      }
    });
  }
  doc2storate_modify(docEntry, file, force) {
    return __async(this, null, function* () {
      const pathSrc = id2path(docEntry._id);
      if (shouldBeIgnored(pathSrc)) {
        return;
      }
      if (docEntry._deleted) {
        const lastDocs = yield this.localDatabase.getDBEntry(pathSrc);
        if (lastDocs === false) {
          yield this.deleteVaultItem(file);
        } else {
          yield this.pullFile(pathSrc, null, true);
          Logger(`delete skipped:${lastDocs._id}`);
        }
        return;
      }
      const localMtime = ~~(file.stat.mtime / 1e3);
      const docMtime = ~~(docEntry.mtime / 1e3);
      if (localMtime < docMtime || force) {
        const doc = yield this.localDatabase.getDBEntry(pathSrc);
        let msg = "livesync : newer local files so write to local:" + file.path;
        if (force)
          msg = "livesync : force write to local:" + file.path;
        if (doc === false)
          return;
        const path = id2path(doc._id);
        if (doc.datatype == "newnote") {
          const bin = base64ToArrayBuffer(doc.data);
          if (bin != null) {
            if (!isValidPath(path)) {
              Logger(`The file that having platform dependent name has been arrived. This file has skipped: ${path}`, LOG_LEVEL.NOTICE);
              return;
            }
            yield this.ensureDirectory(path);
            try {
              yield this.app.vault.modifyBinary(file, bin, { ctime: doc.ctime, mtime: doc.mtime });
              Logger(msg);
              this.app.vault.trigger("modify", file);
            } catch (ex) {
              Logger("could not write to local (modify:bin) " + path, LOG_LEVEL.NOTICE);
            }
          }
        } else if (doc.datatype == "plain") {
          if (!isValidPath(path)) {
            Logger(`The file that having platform dependent name has been arrived. This file has skipped: ${path}`, LOG_LEVEL.NOTICE);
            return;
          }
          yield this.ensureDirectory(path);
          try {
            yield this.app.vault.modify(file, doc.data, { ctime: doc.ctime, mtime: doc.mtime });
            Logger(msg);
            this.app.vault.trigger("modify", file);
          } catch (ex) {
            Logger("could not write to local (modify:plain) " + path, LOG_LEVEL.NOTICE);
          }
        } else {
          Logger("live : New data imcoming, but we cound't parse that.:" + doc.datatype + "-", LOG_LEVEL.NOTICE);
        }
      } else if (localMtime > docMtime) {
      } else {
      }
    });
  }
  handleDBChanged(change) {
    return __async(this, null, function* () {
      const targetFile = this.app.vault.getAbstractFileByPath(id2path(change._id));
      if (targetFile == null) {
        if (change._deleted) {
          return;
        }
        const doc = change;
        yield this.doc2storage_create(doc);
      } else if (targetFile instanceof import_obsidian7.TFile) {
        const doc = change;
        const file = targetFile;
        yield this.doc2storate_modify(doc, file);
        this.queueConflictedCheck(file);
      } else {
        Logger(`${id2path(change._id)} is already exist as the folder`);
      }
    });
  }
  parseReplicationResult(docs) {
    return __async(this, null, function* () {
      this.refreshStatusText();
      for (const change of docs) {
        if (change._id.startsWith("ps:")) {
          if (this.settings.notifyPluginOrSettingUpdated) {
            this.triggerCheckPluginUpdate();
          }
          continue;
        }
        if (change._id.startsWith("h:")) {
          continue;
        }
        if (change.type != "leaf" && change.type != "versioninfo" && change.type != "milestoneinfo" && change.type != "nodeinfo") {
          Logger("replication change arrived", LOG_LEVEL.VERBOSE);
          yield this.handleDBChanged(change);
        }
        if (change.type == "versioninfo") {
          if (change.version > VER) {
            this.localDatabase.closeReplication();
            Logger(`Remote database updated to incompatible version. update your self-hosted-livesync plugin.`, LOG_LEVEL.NOTICE);
          }
        }
        this.gcHook();
      }
    });
  }
  triggerCheckPluginUpdate() {
    (() => __async(this, null, function* () {
      return yield this.checkPluginUpdate();
    }))();
  }
  checkPluginUpdate() {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.settings.usePluginSync)
        return;
      yield this.sweepPlugin(false);
      const { allPlugins, thisDevicePlugins } = yield this.getPluginList();
      const arrPlugins = Object.values(allPlugins);
      let updateFound = false;
      for (const plugin of arrPlugins) {
        const ownPlugin = thisDevicePlugins[plugin.manifest.id];
        if (ownPlugin) {
          const remoteVersion = versionNumberString2Number(plugin.manifest.version);
          const ownVersion = versionNumberString2Number(ownPlugin.manifest.version);
          if (remoteVersion > ownVersion) {
            updateFound = true;
          }
          if ((plugin.mtime / 1e3 | 0) > (ownPlugin.mtime / 1e3 | 0) && ((_a = plugin.dataJson) != null ? _a : "") != ((_b = ownPlugin.dataJson) != null ? _b : "")) {
            updateFound = true;
          }
        }
      }
      if (updateFound) {
        const fragment = createFragment((doc) => {
          doc.createEl("a", null, (a) => {
            a.text = "There're some new plugins or their settings";
            a.addEventListener("click", () => this.showPluginSyncModal());
          });
        });
        new import_obsidian7.Notice(fragment, 1e4);
      } else {
        Logger("Everything is up to date.", LOG_LEVEL.NOTICE);
      }
    });
  }
  clearPeriodicSync() {
    if (this.periodicSyncHandler != null) {
      clearInterval(this.periodicSyncHandler);
      this.periodicSyncHandler = null;
    }
  }
  setPeriodicSync() {
    if (this.settings.periodicReplication && this.settings.periodicReplicationInterval > 0) {
      this.clearPeriodicSync();
      this.periodicSyncHandler = this.setInterval(() => __async(this, null, function* () {
        return yield this.periodicSync();
      }), Math.max(this.settings.periodicReplicationInterval, 30) * 1e3);
    }
  }
  periodicSync() {
    return __async(this, null, function* () {
      yield this.replicate();
    });
  }
  clearPluginSweep() {
    if (this.periodicPluginSweepHandler != null) {
      clearInterval(this.periodicPluginSweepHandler);
      this.periodicPluginSweepHandler = null;
    }
  }
  setPluginSweep() {
    if (this.settings.autoSweepPluginsPeriodic) {
      this.clearPluginSweep();
      this.periodicPluginSweepHandler = this.setInterval(() => __async(this, null, function* () {
        return yield this.periodicPluginSweep();
      }), PERIODIC_PLUGIN_SWEEP * 1e3);
    }
  }
  periodicPluginSweep() {
    return __async(this, null, function* () {
      yield this.sweepPlugin(false);
    });
  }
  realizeSettingSyncMode() {
    return __async(this, null, function* () {
      this.localDatabase.closeReplication();
      this.clearPeriodicSync();
      this.clearPluginSweep();
      yield this.applyBatchChange();
      if (this.suspended)
        return;
      if (this.settings.autoSweepPlugins) {
        yield this.sweepPlugin(false);
      }
      if (this.settings.liveSync) {
        yield this.localDatabase.openReplication(this.settings, true, false, this.parseReplicationResult);
        this.refreshStatusText();
      }
      this.setPeriodicSync();
      this.setPluginSweep();
    });
  }
  refreshStatusText() {
    const sent = this.localDatabase.docSent;
    const arrived = this.localDatabase.docArrived;
    let w = "";
    switch (this.localDatabase.syncStatus) {
      case "CLOSED":
      case "COMPLETED":
      case "NOT_CONNECTED":
        w = "\u23F9";
        break;
      case "STARTED":
        w = "\u{1F300}";
        break;
      case "PAUSED":
        w = "\u{1F4A4}";
        break;
      case "CONNECTED":
        w = "\u26A1";
        break;
      case "ERRORED":
        w = "\u26A0";
        break;
      default:
        w = "?";
    }
    this.statusBar.title = this.localDatabase.syncStatus;
    let waiting = "";
    if (this.settings.batchSave) {
      waiting = " " + this.batchFileChange.map((e3) => "\u{1F6EB}").join("");
      waiting = waiting.replace(/(🛫){10}/g, "\u{1F680}");
    }
    const procs = getProcessingCounts();
    const procsDisp = procs == 0 ? "" : ` \u23F3${procs}`;
    const message = `Sync:${w} \u2191${sent} \u2193${arrived}${waiting}${procsDisp}`;
    this.setStatusBarText(message);
  }
  setStatusBarText(message) {
    if (this.lastMessage != message) {
      this.statusBar.setText(message);
      if (this.settings.showStatusOnEditor) {
        const root = document.documentElement;
        root.style.setProperty("--slsmessage", '"' + message + '"');
      } else {
        const root = document.documentElement;
        root.style.setProperty("--slsmessage", '""');
      }
      this.lastMessage = message;
    }
  }
  replicate(showMessage) {
    return __async(this, null, function* () {
      if (this.settings.versionUpFlash != "") {
        new import_obsidian7.Notice("Open settings and check message, please.");
        return;
      }
      yield this.applyBatchChange();
      if (this.settings.autoSweepPlugins) {
        yield this.sweepPlugin(false);
      }
      yield this.localDatabase.openReplication(this.settings, false, showMessage, this.parseReplicationResult);
    });
  }
  initializeDatabase(showingNotice) {
    return __async(this, null, function* () {
      yield this.openDatabase();
      yield this.syncAllFiles(showingNotice);
    });
  }
  replicateAllToServer(showingNotice) {
    return __async(this, null, function* () {
      if (this.settings.autoSweepPlugins) {
        yield this.sweepPlugin(showingNotice);
      }
      return yield this.localDatabase.replicateAllToServer(this.settings, showingNotice);
    });
  }
  markRemoteLocked() {
    return __async(this, null, function* () {
      return yield this.localDatabase.markRemoteLocked(this.settings, true);
    });
  }
  markRemoteUnlocked() {
    return __async(this, null, function* () {
      return yield this.localDatabase.markRemoteLocked(this.settings, false);
    });
  }
  markRemoteResolved() {
    return __async(this, null, function* () {
      return yield this.localDatabase.markRemoteResolved(this.settings);
    });
  }
  syncAllFiles(showingNotice) {
    return __async(this, null, function* () {
      let notice = null;
      if (showingNotice) {
        notice = new import_obsidian7.Notice("Initializing", 0);
      }
      const filesStorage = this.app.vault.getFiles();
      const filesStorageName = filesStorage.map((e3) => e3.path);
      const wf = yield this.localDatabase.localDatabase.allDocs();
      const filesDatabase = wf.rows.filter((e3) => !e3.id.startsWith("h:") && !e3.id.startsWith("ps:") && e3.id != "obsydian_livesync_version").map((e3) => id2path(e3.id));
      const onlyInStorage = filesStorage.filter((e3) => filesDatabase.indexOf(e3.path) == -1);
      const onlyInDatabase = filesDatabase.filter((e3) => filesStorageName.indexOf(e3) == -1);
      const onlyInStorageNames = onlyInStorage.map((e3) => e3.path);
      const syncFiles = filesStorage.filter((e3) => onlyInStorageNames.indexOf(e3.path) == -1);
      Logger("Initialize and checking database files");
      Logger("Updating database by new files");
      this.setStatusBarText(`UPDATE DATABASE`);
      const runAll = (procedurename, objects, callback) => __async(this, null, function* () {
        const count = objects.length;
        Logger(procedurename);
        let i = 0;
        const procs = objects.map((e3) => __async(this, null, function* () {
          try {
            yield callback(e3);
            i++;
            if (i % 25 == 0) {
              const notify = `${procedurename} : ${i}/${count}`;
              if (notice != null)
                notice.setMessage(notify);
              Logger(notify);
              this.setStatusBarText(notify);
            }
          } catch (ex) {
            Logger(`Error while ${procedurename}`, LOG_LEVEL.NOTICE);
            Logger(ex);
          }
        }));
        if (!Promise.allSettled) {
          yield Promise.all(procs.map((p) => p.then((value) => ({
            status: "fulfilled",
            value
          })).catch((reason) => ({
            status: "rejected",
            reason
          }))));
        } else {
          yield Promise.allSettled(procs);
        }
      });
      yield runAll("UPDATE DATABASE", onlyInStorage, (e3) => __async(this, null, function* () {
        Logger(`Update into ${e3.path}`);
        yield this.updateIntoDB(e3);
      }));
      yield runAll("UPDATE STORAGE", onlyInDatabase, (e3) => __async(this, null, function* () {
        Logger(`Pull from db:${e3}`);
        yield this.pullFile(e3, filesStorage, false, null, false);
      }));
      yield runAll("CHECK FILE STATUS", syncFiles, (e3) => __async(this, null, function* () {
        yield this.syncFileBetweenDBandStorage(e3, filesStorage);
      }));
      this.setStatusBarText(`NOW TRACKING!`);
      Logger("Initialized,NOW TRACKING!");
      if (showingNotice) {
        notice.hide();
        Logger("Initialize done!", LOG_LEVEL.NOTICE);
      }
    });
  }
  deleteFolderOnDB(folder) {
    return __async(this, null, function* () {
      Logger(`delete folder:${folder.path}`);
      yield this.localDatabase.deleteDBEntryPrefix(folder.path + "/");
      for (const v of folder.children) {
        const entry = v;
        Logger(`->entry:${entry.path}`, LOG_LEVEL.VERBOSE);
        if (entry.children) {
          Logger(`->is dir`, LOG_LEVEL.VERBOSE);
          yield this.deleteFolderOnDB(entry);
          try {
            if (this.settings.trashInsteadDelete) {
              yield this.app.vault.trash(entry, false);
            } else {
              yield this.app.vault.delete(entry);
            }
          } catch (ex) {
            if (ex.code && ex.code == "ENOENT") {
            } else {
              Logger(`error while delete folder:${entry.path}`, LOG_LEVEL.NOTICE);
              Logger(ex);
            }
          }
        } else {
          Logger(`->is file`, LOG_LEVEL.VERBOSE);
          yield this.deleteFromDB(entry);
        }
      }
      try {
        if (this.settings.trashInsteadDelete) {
          yield this.app.vault.trash(folder, false);
        } else {
          yield this.app.vault.delete(folder);
        }
      } catch (ex) {
        if (ex.code && ex.code == "ENOENT") {
        } else {
          Logger(`error while delete filder:${folder.path}`, LOG_LEVEL.NOTICE);
          Logger(ex);
        }
      }
    });
  }
  renameFolder(folder, oldFile) {
    return __async(this, null, function* () {
      for (const v of folder.children) {
        const entry = v;
        if (entry.children) {
          yield this.deleteFolderOnDB(entry);
          if (this.settings.trashInsteadDelete) {
            yield this.app.vault.trash(entry, false);
          } else {
            yield this.app.vault.delete(entry);
          }
        } else {
          yield this.deleteFromDB(entry);
        }
      }
    });
  }
  getConflictedDoc(path, rev) {
    return __async(this, null, function* () {
      try {
        const doc = yield this.localDatabase.getDBEntry(path, { rev }, false, false);
        if (doc === false)
          return false;
        let data = doc.data;
        if (doc.datatype == "newnote") {
          data = base64ToString(doc.data);
        } else if (doc.datatype == "plain") {
          data = doc.data;
        }
        return {
          ctime: doc.ctime,
          mtime: doc.mtime,
          rev,
          data
        };
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          return false;
        }
      }
      return false;
    });
  }
  getConflictedStatus(path) {
    return __async(this, null, function* () {
      const test = yield this.localDatabase.getDBEntry(path, { conflicts: true }, false, false);
      if (test === false)
        return false;
      if (test == null)
        return false;
      if (!test._conflicts)
        return false;
      if (test._conflicts.length == 0)
        return false;
      const leftLeaf = yield this.getConflictedDoc(path, test._rev);
      const rightLeaf = yield this.getConflictedDoc(path, test._conflicts[0]);
      if (leftLeaf == false) {
        Logger(`could not get current revisions:${path}`, LOG_LEVEL.NOTICE);
        return false;
      }
      if (rightLeaf == false) {
        yield this.localDatabase.deleteDBEntry(path, { rev: test._conflicts[0] });
        yield this.pullFile(path, null, true);
        Logger(`could not get old revisions, automaticaly used newer one:${path}`, LOG_LEVEL.NOTICE);
        return true;
      }
      if (leftLeaf.data == rightLeaf.data) {
        let leaf = leftLeaf;
        if (leftLeaf.mtime > rightLeaf.mtime) {
          leaf = rightLeaf;
        }
        yield this.localDatabase.deleteDBEntry(path, { rev: leaf.rev });
        yield this.pullFile(path, null, true);
        Logger(`automaticaly merged:${path}`);
        return true;
      }
      if (this.settings.resolveConflictsByNewerFile) {
        const lmtime = ~~(leftLeaf.mtime / 1e3);
        const rmtime = ~~(rightLeaf.mtime / 1e3);
        let loser = leftLeaf;
        if (lmtime > rmtime) {
          loser = rightLeaf;
        }
        yield this.localDatabase.deleteDBEntry(path, { rev: loser.rev });
        yield this.pullFile(path, null, true);
        Logger(`Automaticaly merged (newerFileResolve) :${path}`, LOG_LEVEL.NOTICE);
        return true;
      }
      const dmp = new import_diff_match_patch3.diff_match_patch();
      const diff = dmp.diff_main(leftLeaf.data, rightLeaf.data);
      dmp.diff_cleanupSemantic(diff);
      Logger(`conflict(s) found:${path}`);
      return {
        left: leftLeaf,
        right: rightLeaf,
        diff
      };
    });
  }
  showMergeDialog(file, conflictCheckResult) {
    return new Promise((res, rej) => {
      Logger("open conflict dialog", LOG_LEVEL.VERBOSE);
      new ConflictResolveModal(this.app, conflictCheckResult, (selected) => __async(this, null, function* () {
        const testDoc = yield this.localDatabase.getDBEntry(file.path, { conflicts: true });
        if (testDoc === false) {
          Logger("Missing file..", LOG_LEVEL.VERBOSE);
          return res(true);
        }
        if (!testDoc._conflicts) {
          Logger("Nothing have to do with this conflict", LOG_LEVEL.VERBOSE);
          return res(true);
        }
        const toDelete = selected;
        const toKeep = conflictCheckResult.left.rev != toDelete ? conflictCheckResult.left.rev : conflictCheckResult.right.rev;
        if (toDelete == "") {
          const p = conflictCheckResult.diff.map((e3) => e3[1]).join("");
          yield this.app.vault.modify(file, p);
          yield this.updateIntoDB(file);
          yield this.localDatabase.deleteDBEntry(file.path, { rev: conflictCheckResult.left.rev });
          yield this.localDatabase.deleteDBEntry(file.path, { rev: conflictCheckResult.right.rev });
          yield this.pullFile(file.path);
          Logger("concat both file");
          setTimeout(() => {
            this.showIfConflicted(file);
          }, 500);
        } else if (toDelete == null) {
          Logger("Leave it still conflicted");
        } else {
          Logger(`resolved conflict:${file.path}`);
          yield this.localDatabase.deleteDBEntry(file.path, { rev: toDelete });
          yield this.pullFile(file.path, null, true, toKeep);
          setTimeout(() => {
            this.showIfConflicted(file);
          }, 500);
        }
        return res(true);
      })).open();
    });
  }
  queueConflictedCheck(file) {
    this.conflictedCheckFiles = this.conflictedCheckFiles.filter((e3) => e3 != file.path);
    this.conflictedCheckFiles.push(file.path);
    if (this.conflictedCheckTimer != null) {
      window.clearTimeout(this.conflictedCheckTimer);
    }
    this.conflictedCheckTimer = window.setTimeout(() => __async(this, null, function* () {
      this.conflictedCheckTimer = null;
      const checkFiles = JSON.parse(JSON.stringify(this.conflictedCheckFiles));
      for (const filename of checkFiles) {
        try {
          const file2 = this.app.vault.getAbstractFileByPath(filename);
          if (file2 != null && file2 instanceof import_obsidian7.TFile) {
            yield this.showIfConflicted(file2);
          }
        } catch (ex) {
          Logger(ex);
        }
      }
    }), 1e3);
  }
  showIfConflicted(file) {
    return __async(this, null, function* () {
      yield runWithLock("conflicted", false, () => __async(this, null, function* () {
        const conflictCheckResult = yield this.getConflictedStatus(file.path);
        if (conflictCheckResult === false) {
          return;
        }
        if (conflictCheckResult === true) {
          Logger("conflict:Automatically merged, but we have to check it again");
          setTimeout(() => {
            this.showIfConflicted(file);
          }, 500);
          return;
        }
        yield this.showMergeDialog(file, conflictCheckResult);
      }));
    });
  }
  pullFile(filename, fileList, force, rev, waitForReady = true) {
    return __async(this, null, function* () {
      const targetFile = this.app.vault.getAbstractFileByPath(id2path(filename));
      if (targetFile == null) {
        const doc = yield this.localDatabase.getDBEntry(filename, rev ? { rev } : null, false, waitForReady);
        if (doc === false)
          return;
        yield this.doc2storage_create(doc, force);
      } else if (targetFile instanceof import_obsidian7.TFile) {
        const file = targetFile;
        const doc = yield this.localDatabase.getDBEntry(filename, rev ? { rev } : null, false, waitForReady);
        if (doc === false)
          return;
        yield this.doc2storate_modify(doc, file, force);
      } else {
        Logger(`target files:${filename} is exists as the folder`);
      }
    });
  }
  syncFileBetweenDBandStorage(file, fileList) {
    return __async(this, null, function* () {
      const doc = yield this.localDatabase.getDBEntryMeta(file.path);
      if (doc === false)
        return;
      const storageMtime = ~~(file.stat.mtime / 1e3);
      const docMtime = ~~(doc.mtime / 1e3);
      if (storageMtime > docMtime) {
        Logger("STORAGE -> DB :" + file.path);
        Logger(`${storageMtime} > ${docMtime}`);
        yield this.updateIntoDB(file);
      } else if (storageMtime < docMtime) {
        Logger("STORAGE <- DB :" + file.path);
        Logger(`${storageMtime} < ${docMtime}`);
        const docx = yield this.localDatabase.getDBEntry(file.path, null, false, false);
        if (docx != false) {
          yield this.doc2storate_modify(docx, file);
        }
      } else {
      }
    });
  }
  updateIntoDB(file) {
    return __async(this, null, function* () {
      if (shouldBeIgnored(file.path)) {
        return;
      }
      yield this.localDatabase.waitForGCComplete();
      let content = "";
      let datatype = "newnote";
      if (!isPlainText(file.name)) {
        const contentBin = yield this.app.vault.readBinary(file);
        content = yield arrayBufferToBase64(contentBin);
        datatype = "newnote";
      } else {
        content = yield this.app.vault.read(file);
        datatype = "plain";
      }
      const fullpath = path2id(file.path);
      const d = {
        _id: fullpath,
        data: content,
        ctime: file.stat.ctime,
        mtime: file.stat.mtime,
        size: file.stat.size,
        children: [],
        datatype
      };
      const isNotChanged = yield runWithLock("file:" + fullpath, false, () => __async(this, null, function* () {
        const old = yield this.localDatabase.getDBEntry(fullpath, null, false, false);
        if (old !== false) {
          const oldData = { data: old.data, deleted: old._deleted };
          const newData = { data: d.data, deleted: d._deleted };
          if (JSON.stringify(oldData) == JSON.stringify(newData)) {
            Logger("not changed:" + fullpath + (d._deleted ? " (deleted)" : ""), LOG_LEVEL.VERBOSE);
            return true;
          }
        }
        return false;
      }));
      if (isNotChanged)
        return;
      yield this.localDatabase.putDBEntry(d);
      Logger("put database:" + fullpath + "(" + datatype + ") ");
      if (this.settings.syncOnSave && !this.suspended) {
        yield this.replicate();
      }
    });
  }
  deleteFromDB(file) {
    return __async(this, null, function* () {
      const fullpath = file.path;
      Logger(`deleteDB By path:${fullpath}`);
      yield this.deleteFromDBbyPath(fullpath);
      if (this.settings.syncOnSave && !this.suspended) {
        yield this.replicate();
      }
    });
  }
  deleteFromDBbyPath(fullpath) {
    return __async(this, null, function* () {
      yield this.localDatabase.deleteDBEntry(fullpath);
      if (this.settings.syncOnSave && !this.suspended) {
        yield this.replicate();
      }
    });
  }
  resetLocalDatabase() {
    return __async(this, null, function* () {
      yield this.localDatabase.resetDatabase();
    });
  }
  tryResetRemoteDatabase() {
    return __async(this, null, function* () {
      yield this.localDatabase.tryResetRemoteDatabase(this.settings);
    });
  }
  tryCreateRemoteDatabase() {
    return __async(this, null, function* () {
      yield this.localDatabase.tryCreateRemoteDatabase(this.settings);
    });
  }
  getPluginList() {
    return __async(this, null, function* () {
      const db = this.localDatabase.localDatabase;
      const docList = yield db.allDocs({ startkey: `ps:`, endkey: `ps;`, include_docs: false });
      const oldDocs = (yield Promise.all(docList.rows.map((e3) => __async(this, null, function* () {
        return yield this.localDatabase.getDBEntry(e3.id);
      })))).filter((e3) => e3 !== false).map((e3) => JSON.parse(e3.data));
      const plugins = {};
      const allPlugins = {};
      const thisDevicePlugins = {};
      for (const v of oldDocs) {
        if (typeof plugins[v.deviceVaultName] === "undefined") {
          plugins[v.deviceVaultName] = [];
        }
        plugins[v.deviceVaultName].push(v);
        allPlugins[v._id] = v;
        if (v.deviceVaultName == this.deviceAndVaultName) {
          thisDevicePlugins[v.manifest.id] = v;
        }
      }
      return { plugins, allPlugins, thisDevicePlugins };
    });
  }
  sweepPlugin(showMessage = false) {
    return __async(this, null, function* () {
      if (!this.settings.usePluginSync)
        return;
      yield runWithLock("sweepplugin", false, () => __async(this, null, function* () {
        const logLevel = showMessage ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO;
        if (!this.settings.encrypt) {
          Logger("You have to encrypt the database to use plugin setting sync.", LOG_LEVEL.NOTICE);
          return;
        }
        if (!this.deviceAndVaultName) {
          Logger("You have to set your device and vault name.", LOG_LEVEL.NOTICE);
          return;
        }
        Logger("Sweeping plugins", logLevel);
        const db = this.localDatabase.localDatabase;
        const oldDocs = yield db.allDocs({
          startkey: `ps:${this.deviceAndVaultName}-`,
          endkey: `ps:${this.deviceAndVaultName}.`,
          include_docs: true
        });
        Logger("OLD DOCS.", LOG_LEVEL.VERBOSE);
        const pl = this.app.plugins;
        const manifests = Object.values(pl.manifests);
        for (const m of manifests) {
          Logger(`Reading plugin:${m.name}(${m.id})`, LOG_LEVEL.VERBOSE);
          const path = (0, import_obsidian7.normalizePath)(m.dir) + "/";
          const adapter = this.app.vault.adapter;
          const files = ["manifest.json", "main.js", "styles.css", "data.json"];
          const pluginData = {};
          for (const file of files) {
            const thePath = path + file;
            if (yield adapter.exists(thePath)) {
              pluginData[file] = yield adapter.read(thePath);
            }
          }
          let mtime = 0;
          if (yield adapter.exists(path + "/data.json")) {
            mtime = (yield adapter.stat(path + "/data.json")).mtime;
          }
          const p = {
            _id: `ps:${this.deviceAndVaultName}-${m.id}`,
            dataJson: pluginData["data.json"],
            deviceVaultName: this.deviceAndVaultName,
            mainJs: pluginData["main.js"],
            styleCss: pluginData["styles.css"],
            manifest: m,
            manifestJson: pluginData["manifest.json"],
            mtime,
            type: "plugin"
          };
          const d = {
            _id: p._id,
            data: JSON.stringify(p),
            ctime: mtime,
            mtime,
            size: 0,
            children: [],
            datatype: "plain"
          };
          Logger(`check diff:${m.name}(${m.id})`, LOG_LEVEL.VERBOSE);
          yield runWithLock("plugin-" + m.id, false, () => __async(this, null, function* () {
            const old = yield this.localDatabase.getDBEntry(p._id, null, false, false);
            if (old !== false) {
              const oldData = { data: old.data, deleted: old._deleted };
              const newData = { data: d.data, deleted: d._deleted };
              if (JSON.stringify(oldData) == JSON.stringify(newData)) {
                oldDocs.rows = oldDocs.rows.filter((e3) => e3.id != d._id);
                Logger(`Nothing changed:${m.name}`);
                return;
              }
            }
            yield this.localDatabase.putDBEntry(d);
            oldDocs.rows = oldDocs.rows.filter((e3) => e3.id != d._id);
            Logger(`Plugin saved:${m.name}`, logLevel);
          }));
        }
        Logger(`Deleting old plugins`, LOG_LEVEL.VERBOSE);
        const delDocs = oldDocs.rows.map((e3) => {
          e3.doc._deleted = true;
          return e3.doc;
        });
        yield db.bulkDocs(delDocs);
        Logger(`Sweep plugin done.`, logLevel);
      }));
    });
  }
  applyPluginData(plugin) {
    return __async(this, null, function* () {
      yield runWithLock("plugin-" + plugin.manifest.id, false, () => __async(this, null, function* () {
        const pluginTargetFolderPath = (0, import_obsidian7.normalizePath)(plugin.manifest.dir) + "/";
        const adapter = this.app.vault.adapter;
        const stat = this.app.plugins.enabledPlugins.has(plugin.manifest.id) == true;
        if (stat) {
          yield this.app.plugins.unloadPlugin(plugin.manifest.id);
          Logger(`Unload plugin:${plugin.manifest.id}`, LOG_LEVEL.NOTICE);
        }
        if (plugin.dataJson)
          yield adapter.write(pluginTargetFolderPath + "data.json", plugin.dataJson);
        Logger("wrote:" + pluginTargetFolderPath + "data.json", LOG_LEVEL.NOTICE);
        if (stat) {
          yield this.app.plugins.loadPlugin(plugin.manifest.id);
          Logger(`Load plugin:${plugin.manifest.id}`, LOG_LEVEL.NOTICE);
        }
      }));
    });
  }
  applyPlugin(plugin) {
    return __async(this, null, function* () {
      yield runWithLock("plugin-" + plugin.manifest.id, false, () => __async(this, null, function* () {
        const stat = this.app.plugins.enabledPlugins.has(plugin.manifest.id) == true;
        if (stat) {
          yield this.app.plugins.unloadPlugin(plugin.manifest.id);
          Logger(`Unload plugin:${plugin.manifest.id}`, LOG_LEVEL.NOTICE);
        }
        const pluginTargetFolderPath = (0, import_obsidian7.normalizePath)(plugin.manifest.dir) + "/";
        const adapter = this.app.vault.adapter;
        if ((yield adapter.exists(pluginTargetFolderPath)) === false) {
          yield adapter.mkdir(pluginTargetFolderPath);
        }
        yield adapter.write(pluginTargetFolderPath + "main.js", plugin.mainJs);
        yield adapter.write(pluginTargetFolderPath + "manifest.json", plugin.manifestJson);
        if (plugin.styleCss)
          yield adapter.write(pluginTargetFolderPath + "styles.css", plugin.styleCss);
        if (stat) {
          yield this.app.plugins.loadPlugin(plugin.manifest.id);
          Logger(`Load plugin:${plugin.manifest.id}`, LOG_LEVEL.NOTICE);
        }
      }));
    });
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
